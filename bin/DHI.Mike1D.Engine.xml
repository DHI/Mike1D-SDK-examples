<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DHI.Mike1D.Engine</name>
    </assembly>
    <members>
        <member name="T:DHI.Mike1D.Engine.AddOns.ADDecayCalculator">
            <summary>
            Engine data item for calculating decay for a single time step in AD module.
            <para>
            Pull-based, i.e. only calculated on request
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADDecayCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Factory method for creating a dataitem that calculates AD decay.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="adComponentIndex">Index of component to calculate decay for</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.ADDecayCalculator.ADDecayReachCalculator">
            <summary>
             Helper class for calculating AD Decay 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADDecayCalculator.ADDecayReachCalculator.#ctor">
            <summary>
            Helper class to calculate energy levels on a reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADDecayCalculator.ADDecayReachCalculator.CreateEngineDataForReach(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Int32,System.Double)">
            <summary>
             Create calculator for a given reach in the engine net
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADDecayCalculator.ADDecayNodeCalculator.CreateEngineDataForNode(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Int32,System.Double)">
            <summary>
             Create calculator for a given reach in the engine net
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.ADDecayAccumulatedCalculator">
            <summary>
            Engine data item that calculcates the accumuated decay in mass units, usually [kg].
            Data item is updated every time step
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.ADDecayAccumulatedCalculator.Detailed">
            <summary>
            Indicating whether detailed volume data are calculated.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADDecayAccumulatedCalculator.SetupDetailed">
            <summary>
            Enable detailed calculations, for all nodes and grid points in the network
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADDecayAccumulatedCalculator.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADDecayAccumulatedCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADDecayAccumulatedCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Create helper class for calculating the maximum volume in a reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.ADMassErrorAccumulatedCalculator">
            <summary>
            Data Item for calculating the accumulated mass error or mass balance checksum.
            <para>
            The data item can either accumulate with sign, or accumulate the absolute 
            values of the error/checksum.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADMassErrorAccumulatedCalculator.Setup">
            <summary>
            Setup calculator
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADMassErrorAccumulatedCalculator.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADMassErrorAccumulatedCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADMassErrorAccumulatedCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Create Data Item for calculating the accumulated mass error or mass balance checksum
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="adComponentIndex">AD Component index</param>
            <param name="checksum">If set, calculating the accumulated mass balance checksum</param>
            <param name="abs">If set, the abs-accumulated mass error/balance checksum is calculated</param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.ADTransportAccumulatedCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Create helper class for calculating the maximum volume in a reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged">
            <summary>
            A calculator that calculates the mass error for the latest time step. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.StoringFrequencyUnitType">
            <summary>
            Type/unit of storing frequency
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.StoringFrequency">
            <summary>
            Storing frequence for <see cref="P:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.StoringFrequencyUnitType"/> as <see cref="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.PerTimeStep"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.StoringFrequencySpan">
            <summary>
            Storing frequence span, for all <see cref="P:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.StoringFrequencyUnitType"/> but <see cref="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.PerTimeStep"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.UpdateValues">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.DoStore(System.DateTime)">
            <summary>
            Determines when file is storing, used for determining when to reset the average.
            <para>
            Must be synchronized with ResultData.DoStore method
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeStepAveraged.Create(DHI.Mike1D.Engine.EngineNet,System.DateTime)">
            <summary>
            Create calculator
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDFloodedArea">
            <summary>
            Helper class for calculating total flooded area in network
            <para>
            Flooded area is surface area of open parts of the network.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFloodedArea.Prepare">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDFloodedArea.FloodedAreaTotal">
            <summary>
            Helper class for calculating total flooded area in network
            <para>
            Flooded area is surface area of open parts of the network.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFloodedArea.FloodedAreaTotal.#ctor(DHI.Mike1D.Engine.ModuleHD.HDModule)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFloodedArea.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Create helper class for calculating total inflow to a reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDSurchargeNodeItem">
            <summary>
            Engine data item that provides surcharge in nodes.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDSurchargeNodeCalculator">
            <summary>
            Surcharge calculator for nodes, where water level is above the ground level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDSurchargeNodeCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create surcharge data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDTimeNodeCalculatorBase.UpdateValues">
            <summary>
            Update the total spill time for this node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDSpillVolumeNodeCalculator">
            <summary>
            Spill volume calculator, one value for each node. Contains the total spilled volume in a node
            Data is calculated when UpdateValues is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDSpillVolumeNodeCalculator.#ctor(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="nodeIndex">Index of reach to calculate velocities on</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDSpillVolumeNodeCalculator.UpdateValues">
            <summary>
            Update the total spill volume for this node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDSpillVolumeNodeCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create spill volume data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDSpillTimeNodeCalculatorNew">
            <summary>
            Spill time calculator, one value for each node. Contains the total time that water level is spilling
            for this node (only positive for nodes with a spilling cover)
            Data is calculated when UpdateValues is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDSpillTimeNodeCalculatorNew.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create spill time data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDSpillTimeNodeCalculator">
            <summary>
            Spill time calculator, one value for each node. Contains the total time that water level is spilling
            for this node (only positive for nodes with a spilling cover)
            Data is calculated when UpdateValues is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDSpillTimeNodeCalculator.#ctor(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="nodeIndex">Index of reach to calculate velocities on</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDSpillTimeNodeCalculator.UpdateValues">
            <summary>
            Update the total spill time for this node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDSpillTimeNodeCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create spill time data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDFloodTimeNodeCalculator">
            <summary>
            Flood time calculator, one value for each node. Contains the total time that water level is above
            ground level for this node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFloodTimeNodeCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create flood time data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDDischargeOfFullPipeCalculator">
            <summary>
            Pull version of calculating discharge of a full pipe on q-grid points
            Data is calculated when GetValues is called.
            For reaches that do not run full (open channel that are not pipes)
            null is returned.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeOfFullPipeCalculator.GetValue(System.Int32)">
            <summary>
            Return the full-running capacity on the gridpont with the given index
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeOfFullPipeCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Factory method for creating a dataitem that calculates full-running capacity.
            </summary>
            <param name="engineNet">EngineNet</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDTotalDischargeInReachCalculator">
            <summary>
            Calculate total discharge in the FIRST q-grid point a a reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDTotalDischargeInReachCalculator.#ctor(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="reachIndex">Index of reach to calculate velocities on</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDTotalDischargeInReachCalculator.ElementCount">
            <summary>
            Number of element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDTotalDischargeInReachCalculator.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDTotalDischargeInReachCalculator.UpdateValues">
            <summary>
            Set the current minimum and maximum waterlevels.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDTotalDischargeInReachCalculator.IndexList">
            <summary>
            Indices of gridpoints that data belongs to
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDTotalDischargeInReachCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create min and max water level data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDVelocityMinMaxCalculator">
            <summary>
            Pull version of calculating min/max velocity in the LAST q-grid point of a reach
            Data is calculated when UpdateValues are called 
            </summary>
            <remarks>
            To build the index list, use the engineReach, since the hdReach
            does not have gridpoints before prepare is called, and we need
            to insert this before prepare (otherwise ResultData will not
            find it).
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityMinMaxCalculator.#ctor(DHI.Mike1D.Engine.EngineNet,System.Int32,DHI.Mike1D.Engine.ModuleData.EngineDataItemAll{System.Double})">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="reachIndex">Index of reach to calculate velocities on</param>
            <param name="velocity"> </param>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDVelocityMinMaxCalculator.ElementCount">
            <summary>
            Number of element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDVelocityMinMaxCalculator.ElementValues">
            <summary>
            Element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDVelocityMinMaxCalculator.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityMinMaxCalculator.UpdateValues">
            <summary>
            Set the current minimum and maximum waterlevels.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDVelocityMinMaxCalculator.IndexList">
            <summary>
            Indices of gridpoints that data belongs to
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityMinMaxCalculator.Create(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleData.EngineDataItemAll{System.Double})">
            <summary>
             Factory class to create min and max water level data
            </summary>
            <param name="engineNet"></param>
            <param name="velocity"> </param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterLevelNodeMinMaxCalculator">
            <summary>
            Max water level, one value for one reach (not per grid point).
            Data is calculated when UpdateValues is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelNodeMinMaxCalculator.#ctor(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="nodeIndex">Index of reach to calculate velocities on</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelNodeMinMaxCalculator.UpdateValues">
            <summary>
            Set the current minimum and maximum waterlevels.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelNodeMinMaxCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create min and max water level data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterFlowRateAboveGroundCalculator">
            <summary>
            Engine data item that can provide the water volume in nodes above ground.
            <para>
            This version only calculates values on request, using buffering
            in case values are requested more than once.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterFlowRateAboveGroundCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Create helper class for calculating total inflow to a reach
            </summary>
            <param name="engineNet"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeRetainedInMaxInflowToNodesCalculator">
            <summary>
            Engine data item that can provide the water volume that is retained in 
            nodes with a restriction in inflow capacity. This will always be zero unless
            the inflow to a node is restricted.
            <para>
            This version only calculates values on request, using buffering
            in case values are requested more than once.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeRetainedInMaxInflowToNodesCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Create helper class for calculating total inflow to a reach
            </summary>
            <param name="engineNet"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeRetainedInMaxInflowToNodesCalculator.VolumeRetained">
            <summary>
            Helper class for calculating volume for a node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeRetainedInMaxInflowToNodesCalculator.VolumeRetained.GetValue">
            <summary>
            Get the current values. A new array will be returned every time called.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator">
            <summary>
            Engine data item that can provide the volume in the network.
            <para>
            Handles the total volume, and only volume in reaches and
            nodes in case <see cref="P:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.M11Compatibility"/> is set.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.Detailed">
            <summary>
            Indicating whether detailed volume data are calculated.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.M11Compatibility">
            <summary>
            If true, then water volume is calculated from water level at time nph. If false, then
            water level at np1 is used.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.SetupDetailed">
            <summary>
            Enable detailed calculations, for all nodes and grid points in the network
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.Create(DHI.Mike1D.Engine.EngineNet,System.Boolean)">
            <summary>
             Create helper class for calculating total inflow to a reach
            </summary>
            <param name="engineNet"></param>
            <param name="volumeFromWidths"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.VolumeInNode">
            <summary>
            Helper class for calculating volume for a node
            Only used when <see cref="P:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.M11Compatibility"/>
            is set.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.VolumeInNode.GetValue">
            <summary>
            Get the current values. A new array will be returned every time called.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.VolumeInReach">
            <summary>
            Helper class for calculating volume for a reach
            Only used when <see cref="P:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.M11Compatibility"/>
            is set.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator.VolumeTotal">
            <summary>
            Helper class for calculating total volume in network
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator">
            <summary>
            Engine data item that can provide the maximum volume in the network.
            The maximum volume is only calculated once (ie the network is assumed to be static)
            <para>
            Pull version only calculates values on request.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.Detailed">
            <summary>
            Indicating whether detailed volume data are calculated.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.M11Compatibility">
            <summary>
            If true, then water volume is calculated from water level at time nph. If false, then
            water level at np1 is used.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.SetupDetailed">
            <summary>
            Enable detailed calculations, for all nodes and grid points in the network
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.Create(DHI.Mike1D.Engine.EngineNet,System.Boolean,System.Boolean)">
            <summary>
             Create helper class for calculating the maximum volume in a reach
            </summary>
            <param name="engineNet"></param>
            <param name="pull"></param>
            <param name="volumeFromWidths"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.MaxVolumeInNode">
            <summary>
            Helper class for calculating volume for a node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.MaxVolumeInNode.GetValue">
            <summary>
            Get the current values. A new array will be returned every time called.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.MaxVolumeInReach">
            <summary>
            Helper class for calculating volume for a reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterMaxVolumeCalculator.MaxVolumeTotal">
            <summary>
            Helper class for calculating total maximum volume in network.
            The volume is only calculated the first time GetValues() is called.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDBedShearStressCalculator">
            <summary>
             Helper class to calculate bed shear stress
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDBedShearStressCalculator.ReachCalculator.#ctor(System.Boolean,DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDBedShearStressCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Factory method for creating a dataitem that calculates Bed Shear Stress for HDModule at
            H gridpoints
            </summary>
            <param name="engineNet">EngineNet</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDBedShearStressCalculator.CreateEngineDataForReach(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Factory method for creating a dataitem that calculates Bed Shear Stress for HDModule on h-point on
            a given reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDMassErrorCalculator">
            <summary>
            A calculator that calculates the mass error for the latest time step. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDMassErrorCalculator.M11Compatibility">
            <summary>
            Setting this flag, and if calculating volume by integrating up
            the 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Create calculator
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedCalculator">
            <summary>
            A calculator that sums up the mass error for all time steps. 
            <para>
            The calculator is based on an <see cref="T:DHI.Mike1D.Engine.AddOns.HDMassErrorCalculator"/>, which
            must be created first, and it must also be updated before this calculator,
            in order to get the correct mass error numbers. Hence, this must be added
            AFTER the <see cref="T:DHI.Mike1D.Engine.AddOns.HDMassErrorCalculator"/> to the list of 
            data items in the <see cref="T:DHI.Mike1D.Engine.ModuleData.DataModule"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedCalculator.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedCalculator.Create(DHI.Mike1D.Engine.EngineNet,System.Boolean,DHI.Mike1D.Engine.AddOns.HDMassErrorCalculator)">
            <summary>
            Create calculator
            </summary>
            <param name="engineNet">Engine net of model</param>
            <param name="absError">Flag indicating if the absolute error or error with sign should be accumulated.</param>
            <param name="massErrorCalculator">Calculator that calculates the mass error.</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDMassErrorChecksumCalculator">
            <summary>
            A calculator that calculates a mass error check sum for the latest time step. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorChecksumCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorChecksumCalculator.Create(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.AddOns.HDInOutFlowCalculator,DHI.Mike1D.Engine.AddOns.HDInOutFlowCalculator,DHI.Mike1D.Engine.AddOns.HDWaterVolumeChangeCalculator,DHI.Mike1D.Engine.AddOns.HDMassErrorCalculator)">
            <summary>
            Create calculator
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedChecksumCalculator">
            <summary>
            A calculator that calculates a mass error check sum accumulated since start of simulation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedChecksumCalculator.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedChecksumCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedChecksumCalculator.Create(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.AddOns.HDInOutFlowCalculator,DHI.Mike1D.Engine.AddOns.HDInOutFlowCalculator,DHI.Mike1D.Engine.AddOns.HDWaterVolumeCalculator,DHI.Mike1D.Engine.AddOns.HDMassErrorAccumulatedCalculator)">
            <summary>
            Create calculator
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDMaxContinuityImbalanceCalculator">
            <summary>
            Update version of calculating max continuity imbalance
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMaxContinuityImbalanceCalculator.#ctor(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDMaxContinuityImbalanceCalculator.ElementCount">
            <summary>
            Number of element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDMaxContinuityImbalanceCalculator.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMaxContinuityImbalanceCalculator.UpdateValues">
            <summary>
            Set the current maximum continuity imbalance.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMaxContinuityImbalanceCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create min and max water level data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDMaxContinuityImbalanceCalculator.GetValues">
            <summary>
            Get the current values. A new array will be returned every time called.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDMaxContinuityImbalanceCalculator.ElementSet">
            <summary>
            ElementSet describing geometry of each <see cref="!:IEngineData&lt;T&gt;.ElementValues"/>.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDInOutFlowType">
            <summary>
            Enum for different types of in and out flow.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDInOutFlowType.TotalInflow">
            <summary>
            Total inflow, from beginning of simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDInOutFlowType.TotalOutflow">
            <summary>
            Total outflow, from beginning of simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDInOutFlowType.TimestepInflow">
            <summary>
            Inflow for the current time step
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDInOutFlowType.TimestepOutflow">
            <summary>
            Outflow for the current time step
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDInOutFlowCalculator">
            <summary>
            Helper class providing the inflow to the network. 
            
            
            <para>
            This is a lazy/pull driven version, only retrieving values
            when required. If the same values are retrieved more than once, 
            they are recalculated from scratch.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDInOutFlowCalculator.SetupDetailed">
            <summary>
            Enable detailed calculations, for all nodes and grid points in the network
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDInOutFlowCalculator.Create(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.AddOns.HDInOutFlowType,System.Boolean)">
            <summary>
            Create an engine data item that provides in/outflow into/from the model.
            <para>
            It can produce the general in/out flow and also detailed in/out flow of all
            nodes/reaches/gridpoints. Set the <paramref name="detailed"/> to true to get
            detailed results.
            </para>
            </summary>
            <param name="engineNet">Engine net with model</param>
            <param name="flowtype">Type of flow output</param>
            <param name="detailed">Flag indicating whether detailed results are produced. </param>
            <returns>An engine data item providing in/outflow into/from model.</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator">
            <summary>
            Helper class to calculate the total inflow/outflow to/from the entire network, 
            for many different categories.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory">
            <summary>
             Types of inflow or outflow to return.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory.All">
            <summary>
             All flow into or out of network
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory.Reaches">
            <summary>
             All flow into or out of reaches
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory.WaterLevelBoundaryNodes">
            <summary>
             All flow into or out of water level boundary nodes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory.InflowBoundaryNodes">
            <summary>
             All flow into or out of inflow boundary nodes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory.QhBoundaryNodes">
            <summary>
             All flow into or out of QH boundary nodes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory.NonBoundaryNodes">
            <summary>
             All flow into or out of node that are not boundary nodes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory.ExternalStructureReachNodes">
            <summary>
            All flow into and out of water level boundaries connected to structure reaches (external structures)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.GetValuesInUserUnits">
            <summary>
            Get the current values. A new array will be returned every time called.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.GetValues">
            <summary>
            Get the current values. A new array will be returned every time called.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.Create(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.AddOns.HDInOutFlowType,DHI.Mike1D.Engine.AddOns.HDTotalInOutflowCalculator.FlowCategory)">
            <summary>
             Create helper class for calculating toal inflow to a network
            </summary>
            <param name="engineNet"></param>
            <param name="type">Type of flows to include</param>
            <param name="category">Which sections of the flow to sum up</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDMinMaxReachCalculatorBase.ElementCount">
            <summary>
            Number of element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDMinMaxReachCalculatorBase.ElementValues">
            <summary>
            Element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDMinMaxReachCalculatorBase.IndexList">
            <summary>
            Indices of gridpoints that data belongs to
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDDischargeMinMaxCalculator">
            <summary>
            Pull version of calculating max discharge
            Data is calculated when UpdateValues are called 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeMinMaxCalculator.#ctor(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="reachIndex">Index of reach to calculate velocities on</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeMinMaxCalculator.UpdateValues">
            <summary>
            Set the current minimum and maximum waterlevels.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeMinMaxCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create min and max water level data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterLevelMinMaxCalculator">
            <summary>
            Max water level, one value for each h-grid point in a reach.
            Data is calculated when UpdateValues is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelMinMaxCalculator.#ctor(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="reachIndex">Index of reach to calculate velocities on</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelMinMaxCalculator.GetValues">
            <summary>
            Pull version of the calculator
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelMinMaxCalculator.GetValues(DHI.Mike1D.Engine.AddOns.MinMaxValueContainer[])">
            <summary>
            Pull version of the calculator
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelMinMaxCalculator.GetValue(System.Int32)">
            <summary>
            Pull version of the calculator
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDWaterLevelMinMaxCalculator.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelMinMaxCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create min and max water level data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeChangeCalculator">
            <summary>
            Helper class to calculate the change of volume of water in a timestep in the network
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeChangeCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Create helper class for calculating total inflow to a reach
            </summary>
            <param name="engineNet"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeChangeCalculator.UpdateValues">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeInNodesAboveGroundCalculator">
            <summary>
            Engine data item that can provide the water volume in nodes above ground.
            <para>
            This version only calculates values on request, using buffering
            in case values are requested more than once.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeInNodesAboveGroundCalculator.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Create helper class for calculating total inflow to a reach
            </summary>
            <param name="engineNet"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterVolumeInNodesAboveGroundCalculator.VolumeInNodeAboveGround">
            <summary>
            Helper class for calculating volume for a node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterVolumeInNodesAboveGroundCalculator.VolumeInNodeAboveGround.GetValue">
            <summary>
            Get the current values. A new array will be returned every time called.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDDischargeHPointsCalculator">
            <summary>
             Helper class to calculate discharge on h-points
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeHPointsCalculator.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeHPointsCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Factory method for creating a dataitem that calculates Discharge for HDModule at
            H gridpoints
            </summary>
            <param name="engineNet">EngineNet</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDDischargeHPointsCalculator.CreateEngineDataForReach(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
             Create a discharge calculator on a given reach
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDEnergyLevelCalculator">
            <summary>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDEnergyLevelCalculator.#ctor">
            <summary>
            Helper class to calculate energy levels on a reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDEnergyLevelCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Factory method for creating a dataitem that calculates Froude Numbers for HDModule at
            Q gridpoints
            </summary>
            <param name="engineNet">EngineNet</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDEnergyLevelCalculator.CreateEngineDataForReach(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
             Create energy level data for a given reach in the engine net
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDEnergyLevelSlopeCalculator">
            <summary>
             Helper class to calcualte energy level slope on an HDReach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDEnergyLevelSlopeCalculator.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDEnergyLevelSlopeCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Factory method for creating a dataitem that calculates Froude Numbers for HDModule at
            Q gridpoints
            </summary>
            <param name="engineNet">EngineNet</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDEnergyLevelSlopeCalculator.CreateEngineDataForReach(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
             Create the energy level slope data on a specific reach in the engine net.
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDFroudeCalculator">
            <summary>
             Helper class to calculate the froude number 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFroudeCalculator.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFroudeCalculator.CreateForGridPoints(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Boolean,System.Boolean)">
            <summary>
             Create helper class for calculating the Froude number on h- and/or q-points
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
            <param name="hPoints"></param>
            <param name="qPoints"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFroudeCalculator.CreateForEndPoints(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Boolean,System.Boolean)">
            <summary>
             Create helper class for calculating the Froude number on reach end points
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFroudeCalculator.CreateDataItemForGridPoints(DHI.Mike1D.Engine.EngineNet,System.Boolean,System.Boolean)">
            <summary>
            Factory method for creating a dataitem that calculates Froude Numbers for HDModule for the 
            gridpoints specified
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="hGridPoints">Boolean defining whether the Froude Number should be calculated on H-gridpoints</param>
            <param name="qGridPoints">Boolean defining whether the Froude Number should be calculated on Q-gridpoints, including structure points</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDFroudeCalculator.CreateDataItemForEndPoints(DHI.Mike1D.Engine.EngineNet,System.Boolean,System.Boolean)">
            <summary>
            Factory method for creating a dataitem that calculates Froude for HDModule for the 
            first and/or last gridpoint.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="first">Boolean defining whether the Froude Number should be calculated on first gridpoint</param>
            <param name="last">Boolean defining whether the Froude Number should be calculated on last gridpoint</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDReachInflowSource">
            <summary>
            Helper class to calculate the total inflow into a reach. Pull version
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDReachInflowSource.GetValues">
            <summary>
            Get the current values. A new array will be returned every time called.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDReachInflowSource.ElementCount">
            <summary>
            Number of element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDReachInflowSource.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDReachInflowSource.Prepare">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDReachInflowSource.ElementSet">
            <summary>
            ElementSet describing geometry of each <see cref="!:IEngineData&lt;T&gt;.ElementValues"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDReachInflowSource.Create(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
             Create helper class for calculating total inflow to a reach
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDReachInflowSource.CreateDataItemForGridPoints(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Factory method for creating a dataitem that calculates total inflow
            </summary>
            <param name="engineNet">EngineNet</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDWaterLevelSlopeCalculator">
            <summary>
             Helper class to calculate water level slope 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelSlopeCalculator.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelSlopeCalculator.GetValues(System.Double[],System.Double)">
            <summary>
            Get water level slope on all defined grid points
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelSlopeCalculator.CreateDataItem(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Factory method for creating a dataitem that calculates Froude Numbers for HDModule at
            Q gridpoints
            </summary>
            <param name="engineNet">EngineNet</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDWaterLevelSlopeCalculator.CreateEngineDataForReach(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Factory method for creating a dataitem that calculates Froude Numbers for HDModule on q-point on
            a given reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.MinMaxValueContainer">
            <summary>
            Class for recording min and max value, including time
            where min and max value occurred.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.MinMaxValueContainer.MinimumValue">
            <summary>
            Minimum value recorded
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.MinMaxValueContainer.MaximumValue">
            <summary>
            Maximum value recorded
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.MinMaxValueContainer.TimeOfMinimum">
            <summary>
            Time of minimum value
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.AddOns.MinMaxValueContainer.TimeOfMaximum">
            <summary>
            Time of maximum value
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.MinMaxValueContainer.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.MinMaxValueContainer.Update(System.Double,System.DateTime)">
            <summary>
            Update min/max value, value is larger/smaller than
            the currently recorded min/max value.
            </summary>
            <param name="value">Value to check</param>
            <param name="dateTime">Time that value belongs to</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator">
            <summary>
            Pull version of calculating velocity on grid points
            Data is calculated when GetValues are called 
            </summary>
            <remarks>
            To build the index list, use the engineReach, since the hdReach
            does not have gridpoints before prepare is called, and we need
            to insert this before prepare (otherwise ResultData will not
            find it).
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator.GetValue(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator.CreateForGridPoints(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Boolean,System.Boolean)">
            <summary>
             Factory class for creating velocity data structures on h- and/or q-points
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
            <param name="hPoints"></param>
            <param name="qPoints"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator.CreateForGridPoints(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
             Factory class for creating velocity data structures on h- and/or q-points
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
            <param name="gridPointIndices"> </param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator.CreateForEndPoints(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Boolean,System.Boolean)">
            <summary>
             Factory class for creating velocity data structures on reach end points
            </summary>
            <param name="engineNet"></param>
            <param name="reachIndex"></param>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator.CreateForEndPoints(DHI.Mike1D.Engine.EngineNet,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
             Factory class for creating velocity data structures on reach end points
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="reachIndex">Index of engine reach</param>
            <param name="hGridPoints">Boolean if h grid points must be used. When false, q grid points are used,</param>
            <param name="first">Boolean if first grid point should be included</param>
            <param name="last">Boolean if last grid point should be included</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator.CreateDataItemForGridPoints(DHI.Mike1D.Engine.EngineNet,System.Boolean,System.Boolean)">
            <summary>
            Factory method for creating a dataitem that calculates velocities for HDModule for the 
            gridpoints specified
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="hGridPoints">Boolean defining whether the velocity should be calculated on H-gridpoints</param>
            <param name="qGridPoints">Boolean defining whether the velocity should be calculated on Q-gridpoints</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator.CreateDataItemForEndPoints(DHI.Mike1D.Engine.EngineNet,System.Boolean,System.Boolean)">
            <summary>
            Factory method for creating a dataitem that calculates velocities for HDModule for the 
            first and/or last gridpoint.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="first">Boolean defining whether the velocity should be calculated on first gridpoint</param>
            <param name="last">Boolean defining whether the velocity should be calculated on last gridpoint</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculator.CreateDataItemForEndPoints(DHI.Mike1D.Engine.EngineNet,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Factory method for creating a dataitem that calculates velocities for HDModule for the 
            first and/or last gridpoint.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="hGridPoints">Boolean defining whether the velocity is calculated on H or Q grid points</param>
            <param name="first">Boolean defining whether the velocity should be calculated on first gridpoint</param>
            <param name="last">Boolean defining whether the velocity should be calculated on last gridpoint</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull">
            <summary>
            Pull version of calculating velocity on all QPoints
            Data is calculated when GetValues are called 
            
            pro: Only calculated when used
            con: Recalculated if two components requests the same data
            </summary>
            <remarks>
            To build the index list, use the engineReach, since the hdReach
            does not have gridpoints before prepare is called, and we need
            to insert this before prepare (otherwise ResultData will not
            find it).
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull.#ctor(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="reachIndex">Index of reach to calculate velocities on</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull.BuildIndexList(DHI.Mike1D.Engine.EngineReach)">
            Build indexlist based on EngineReach (since HDReach does not have 
            any gridpoints until prepare have been called.
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull.ElementCount">
            <summary>
            Number of element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull.Prepare">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull.IndexList">
            <summary>
            Indices of gridpoints that the velocities belong to
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull.GetValues">
            <summary>
            Get the current velocities. A new array will be returned every time this function is called.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPull.Create(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Factory class to create velocity data
            </summary>
            <param name="engineNet"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPush">
            <summary>
            Push version of calculating velocity on all QPoints.
            
            Data must be calculated at an EndOfTimeStep event of HDModule, by calling <see cref="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPush.CalculateQPointVelocities"/>.
            
            Pro: Data is stored and can be reused by many components.
            
            Con: If data is not used, they are calculated and stored for no reason. Takes a bit more memory than pull
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.AddOns.HDVelocityCalculatorQPointsPush.CalculateQPointVelocities">
            <summary>
            Calculate velocities on Q points
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.CoefficientDebugInfo">
            <summary>
            Internal class, for debugging purposes
            <para>
            It is setup based on an additional parameter. 
            <code>
            debug=0                                  // disable
            debug=x                                  // Write debug info every X times
            debug=1;19900919T000000                  // Write debug info, start at this time
            debug=1;19900919T000000;19900919T010000  // Write debug info, start/end at specified times
            </code>
            <para>
            Date format is: yyyyMMddTHHmmss
            </para>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.CoefficientDebugInfo.#ctor">
            <summary>
            Default constructor, setting default values.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.CoefficientDebugInfo.Frequency">
            <summary>
            How often to apply debugging - timestep frequence
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.CoefficientDebugInfo.Start">
            <summary>
            Only apply after this time
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.CoefficientDebugInfo.End">
            <summary>
            Only apply before this time
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.CoefficientDebugInfo.BaseFilePath">
            <summary>
            Base filepath of where debug output is stored. Set to simulation file path.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.CoefficientDebugInfo.Parse(System.String)">
            <summary>
            Parse from string
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.CoefficientDebugInfo.Create(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Get from additional data. Returns null if not found.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.CouplingException">
            <summary>
            Exception that is thrown in a coupling context.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.CouplingsUtil">
            <summary>
            Methods useful for finding string matches or Q points in a network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.DisableDispersion(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Disable dispersion for AD on the <paramref name="enode"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.SetWeirCrestLevel(DHI.Mike1D.StructureModule.IStructure,System.Double)">
            <summary>
            Set crest level of weir
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.NorthAngleDegrees(DHI.Mike1D.Generic.Spatial.Geometry.Vector)">
            <summary>
            Angle to north in degrees
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.FindReachesWithLinkInside(DHI.Mike1D.Engine.Couplings.LateralLink,DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Find index of all reaches that are inside the <paramref name="link"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.FindPreviousQPoint(System.Double,System.Double@,DHI.Mike1D.Engine.EngineReaches,System.Boolean)">
            <summary>
            Find previous Q point. If the previous Q point is on the other side of a junction node compared to <paramref name="chainage"/>
            the previous reach Q point is being used.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.FindNextQPoint(System.Double,System.Double@,DHI.Mike1D.Engine.EngineReaches,System.Boolean)">
            <summary>
            Find next Q point. If the next Q point is on the other side of a junction node compared to <paramref name="chainage"/>
            the next reach Q point is being used.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.GetAdjustedBoundaryValue(System.Double[],System.Double,System.Double,System.Double[])">
            <summary>
            
            </summary>
            <param name="realWaterLevel">water level to be adjusted. Old MzCouplings requires it to be an array. Otherwise it could become a double</param>
            <param name="bottomLevelAssignerModel"> bottom level of the model provifing the boundary value</param>
            <param name="bottomLevelWLBoundaryModel"> bottom level of the model having a water level boundary </param>
            <param name="m21ExchangeWeights"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.GetAdjustedBoundaryValue(System.Double,System.Double,System.Double)">
            <summary>
            Calculate an adjusted water level boundary value.
            </summary>
            <param name="realWaterLevel">water level to be adjusted</param>
            <param name="bottomLevelAssignerModel"> bottom level of the model providing the boundary value</param>
            <param name="bottomLevelWLBoundaryModel"> bottom level of the model having a water level boundary </param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.IsOutflowReversed(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Figure out if the internal discharge direction in the HD module matches outflow.
            <para>
            Discharge is reversed, if the link is at the start of the reach. And the flag is
            flipped, if the <see cref="P:DHI.Mike1D.Engine.EngineReach.ReverseDirection"/> flag is set.
            </para>
            <para>
            Works for open boundary nodes only.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.CouplingsUtil.LimitArraysToSpan(System.Double,System.Double,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Linit arrays to min-max chainage span. This method is called when the chainage array goes beyond the chainage limits of the river reach. 
            </summary>
            <param name="minChainage">Minimum chainage</param>
            <param name="maxChainage">Maximum chainage</param>
            <param name="xarray"></param>
            <param name="yarray"></param>
            <param name="chainageArray"></param>
            <returns>True if arrays was limited. False if arrays was kept untouched</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkCrestSource">
            <summary>
            Specifies who decides the crest height of a lateral link.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkCrestSource.External">
            <summary>
            Crest levels are defined in an external file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkCrestSource.River">
            <summary>
            River bank markers levels define the crest levels
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkCrestSource.Surface">
            <summary>
            Surface bottom levels define the crest levels
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkCrestSource.RiverSurfaceMax">
            <summary>
            The maximum of the river bank marker level and surface bottom levels define the crest levels
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkStructureType">
            <summary>
            Type of lateral link structure
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkStructureType.Weir1">
            <summary> Weir type 1 is a VillemonteWeir formulation </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkStructureType.Weir2">
            <summary> Weir type 2 is a HonmaWeir formulation </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkStructureType.QHTable">
            <summary> Qt table uses a Q-H table </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkStructureType.QdTable">
            <summary> Not implemented </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.LateralLinkStructureType.FormLoss">
            <summary> Not implemented </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkWaterLevelBoundaryType">
            <summary>
            Type of water level boundary for standard links.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkWaterLevelBoundaryType.Direct">
            <summary> Setting raw water level at boundary. Classic (original) coupling type </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkWaterLevelBoundaryType.Coupled">
            <summary> Setting water level boundary, tring to match H=h at end of time step </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkWaterLevelBoundaryType.CoupledQ">
            <summary> Setting water level boundary, tring to match H=h at end of time step, including a correction term from discharge of first/last grid piont </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkDischargeType">
            <summary>
            Type of discharge exchange for standard links.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkDischargeType.ActualOutflow">
            <summary> The actual outflow is the amount of water leaving the model, being the outflow at the outlet/the end of reach. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkDischargeType.LastQPointFlow">
            <summary>
            The discharge exchanged over the link is the flow of the last Q-point in the link.
            <para>This will not take into account any volume changes and sources on the last H grid point in the network.</para>
            <para>It does imply a delay in the exchange of data through the standard link, and hence can have a stabilizing effect.</para>
            <para>Classic (original) coupling type.</para>
            </summary>
            <remarks>
            Artifacts can occur.
            Example: If water flows into the last H grid point both from upstream the branch (last Q grid point)
            and from the lateral link: The flow over the link is evaluated as positive, water leaving the network,
            because of the discharge from the last Q grid point, however water actually flows into MIKE 1D. 
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.Enumerations.UrbanRiverLinkType">
            <summary>
            Link type between an urban and river a model
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.UrbanRiverLinkType.Undefined">
            <summary> Undefined </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.UrbanRiverLinkType.RiverOutlet">
            <summary> River outlet water level boundary, discharge (point source) node boundary in urban </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.UrbanRiverLinkType.UrbanOutlet">
            <summary> Urban outlet water level boundary, discharge (point source) location boundary in river </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.UrbanRiverLinkType.UrbanWeirToRiver">
            <summary> Urban Weir outlet water level boundary, discharge (point source) location boundary in river </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.UrbanRiverLinkType.UrbanPumpToRiver">
            <summary> Urban Pump outlet water level boundary, discharge (point source) location boundary in river </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType">
            <summary>
            Type of urban link
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanInlet">
            <summary> Link to an urban inlet, a manhole or a basin. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanOutlet">
            <summary> Link to an urban outlet. This is very similar to <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.Standard"/> type </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanWeir">
            <summary> Link to an urban weir outlet. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanPump">
            <summary> Link to an urban pump outlet. </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType">
            <summary>
            Type of link
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.Invalid">
            <summary> Undefined/invalid </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.Lateral">
            <summary> Lateral link, connecting to several grid points within a span of a reach. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.ImplicitStructure">
            <summary> Implicit structure, used by old coupling procedure (M21 classic). </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.ZeroXflow">
            <summary> Used by old coupling procedure, data is transferred to surface model. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.ZeroYflow">
            <summary> Used by old coupling procedure, data is transferred to surface model. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.Standard">
            <summary> Standard link is a link to a river/urban outlet </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.Urban">
            <summary> Link is a urban link type, <see cref="T:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType"/> </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.UrbanRiver">
            <summary> Link is a urban-river link type, <see cref="T:DHI.Mike1D.Engine.Couplings.Enumerations.UrbanRiverLinkType"/> </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.Enumerations.CouplingLinkType.SideStructure">
            <summary> Link is a side-structure link type </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.LateralLink">
            <summary>
            A lateral link computes the exchange through a set of link-<see cref="F:DHI.Mike1D.Engine.Couplings.LateralLink.Faces"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLink.LinkSpan">
            <summary> Span that this lateral link covers </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLink.LateralLinkReaches">
            <summary> Reaches that this lateral link overlaps </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLink.NumberOfFaces">
            <summary> Number of faces in link </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLink.Faces">
            <summary> Faces in the lateral link </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLink.SideOfRiver">
            <summary>
            Side of river that the lateral links is appled to.
            <para>
            Side of river is when walking in positive chainage direction.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLink.StructureType">
            <summary> Type of structure in faces </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLink.CrestSource">
            <summary> Source of crest level for the structures </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLink.StructureDelh">
            <summary>
            Delh parameter for structures in the faces of the lateral link. Only applies to some structures.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLink.WeirCoefficient">
            <summary> Weir coefficient for the <see cref="T:DHI.Mike1D.StructureModule.VillemonteWeir"/> and <see cref="T:DHI.Mike1D.StructureModule.HonmaWeir"/>. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLink.StartTime">
            <summary> Start time of simulation </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLink.CurrentTime">
            <summary> Current time of simulation </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.#ctor(DHI.Mike1D.Generic.LocationSpan)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetDt(System.Double)">
            <summary>
            Set current simulation time step 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetCurrentTime(System.DateTime)">
            <summary> Set Current time </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetStartTime(System.DateTime)">
            <summary>
            Set start time of simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetNumberOfFaces(System.Int32)">
            <summary>
            Set number of faces that the lateral link is connected to
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetFacesCoordinates(System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Set face coordinates, (x, y, chainage) for start and end of each face
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetLinkDryingDepth(System.Double)">
            <summary>
            Set drying depth of link
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.ApplyCouplingForcing(System.DateTime,System.DateTime)">
            <summary>
            This function is called by the perform time step routine,
            and adds the discharge of each face (lateral link structure) to
            MIKE 1D as an implicit source contribution
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.ApplyADCouplingForcing">
            <summary>
            This function is called by the perform time step routine,
            It evaluates the discharges of each face (lateral link structure)
            to calculate the actual discharges, and use those to
            add component contributions (AD) to MIKE 1D
            (after HD timestep, but before AD time step)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.ApplyExponentialSmoothing">
            <summary>
            Apply exponential smoothing on the water level inputs
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetSurfaceWaterLevel(System.Double[],System.Double[])">
            <summary>
            Set surface water level and depth to all faces and propagate to all weirs
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetSurfaceVolumes(System.Double[])">
            <summary>
            Set surface volumes to all faces
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.GetDischarges">
            <summary>
            Get discharge for all faces
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.PrepareForTimeStep">
            <summary>
            Prepare for time step. Also read external levee file data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.SetSurfaceConcentrationOnFaces(System.Int32,System.Double[])">
            <summary>
            Set external concentrations on each face for the specified component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.CalculateFaceDischarges(System.Double[])">
            <summary>
            Calculate face discharges
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.GetFacesOutflowConcentrations(System.Int32,DHI.Mike1D.Engine.EngineNet,System.Double[])">
            <summary>
            Get outflow concentration for each face for specified component
            </summary>
            <param name="iComp"></param>
            <param name="net"></param>
            <param name="faceOutflowConcentrations"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.PrepareHD(System.Double[][],DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.CrossSectionModule.CrossSectionData,System.DateTime)">
            <summary>
            Prepare link for HD, creating faces and structures
            </summary>
            <param name="coords">Face coordinates</param>
            <param name="net">EngineNet</param>
            <param name="crossSections">Cross sections</param>
            <param name="startTime">Start time of simulation</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.PrepareAD(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Prepare link for AD.
            </summary>
            <param name="net"></param>
            <param name="nfaces"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLink.UpdateCrestLevels">
            <summary> Update crest levels for all lateral link structures </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.LateralLinkFactory">
            <summary>
            Factory class for creating lateral links
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLinkFactory.LateralLinkReaches">
            <summary>
            LateralLinkReachesis renewed for each link
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkFactory.#ctor(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Default constructor, with <paramref name="engineNet"/> argument
            </summary>
            <param name="net"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkFactory.SetupLateralLinkReaches(DHI.Mike1D.Engine.Couplings.LateralLink)">
            <summary>
            Setup list of reaches with the id of the <see cref="P:DHI.Mike1D.Engine.Couplings.LateralLink.LinkSpan"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.LateralLinkOutputSpec">
            <summary>
            Handles output for lateral links.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkOutputSpec.DefineLinkFLowResultDataItems">
            <summary>
            
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkOutputSpec.SetupDataForReaches(DHI.Mike1D.Engine.ModuleData.EngineDataItemAll{System.Double},DHI.Mike1D.Engine.EngineNet,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.List{System.ValueTuple{System.Double,System.Double}}},System.Boolean)">
            <summary>
            Create engine data for the reaches and spans specified in <paramref name="reachSpans"/>
            </summary>
            <param name="engineDataItem">Engine data item to update</param>
            <param name="engineNet">EngineNet to setup up data for</param>
            <param name="match"></param>
            <param name="reachSpans">Key is reach index, values is list of spans to setup data for.</param>
            <param name="setupForAllGridpoints">Boolean indicating whether to set up data for all grid points in the reach, or just those covered by one of the spans.</param>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.WeirEngineReach">
            <summary> Reach that structure is connected to </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.WeirLinkHpoint">
            <summary> H-point that structure is connected to </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.HpointIndex">
            <summary> Index of H-point that structure is connected to </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.WeirWidth">
            <summary> Width of this weir </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LateralLinkStructure._weirWidthFactor">
            <summary> Factor on discharge, in case discharge calculation is a "per-length" calculation</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.WeirCenteredChainage">
            <summary>
            Chainage at center of structure
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.WeirStructure">
            <summary>
            Lateral link weir structure
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.Discharge">
            <summary> Get the discharge into MIKE 1D. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.SurfaceGroundLevel">
            <summary> Ground level of surface in the middle of the structure </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.RiverCrestLevel">
            <summary> Crest level of river in the middle of the structure </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.CouplingCrestLevel">
            <summary> Crest level used in coupling calculations in the middle of the structure </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.GetM1DCrestLevel(DHI.Mike1D.Generic.ReachSide,DHI.Mike1D.Engine.EngineReaches,System.Double,DHI.Mike1D.CrossSectionModule.CrossSectionData,System.Boolean)">
            <summary>
            Gets the crest level (mark 1 or mark 3) from the cross section data of a river model node, 
            if it exists, interpolating the values of the closest available x-section data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.GetInternalConcentration(System.Int32,DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Get outflow concentration for lateral link structure for specified component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.EvaluateWeirDischarge">
            <summary>
            Evalueate the weir discharge (which is implicit), and multiply by weir width factor.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.GetweirDischarge">
            <summary>
            Get the discharge into MIKE 1D.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LateralLinkStructure.SetupAd(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Setup AD for structure
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.LinkBase">
            <summary>
            Base class for engine links.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LinkBase.SmoothingFactor">
            <summary>
            Smoothing factor for exponential smoothing.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LinkBase._smoothingFact">
            <summary> Smoothing factor for exponential smoothing. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LinkBase.IsAdLink">
            <summary> Bool indicating if this will transfer AD </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LinkBase._externalConcentrations">
            <summary> Inflow/outside concentration </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.LinkFace">
            <summary>
            A link face contains one or more <see cref="F:DHI.Mike1D.Engine.Couplings.LinkFace.FaceWeirs"/>,
            which shares the same external water level (and component concentrations),
            but may be distributed over several H grid points in the 1D model
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LinkFace.StartChainage">
            <summary> Start chainage of face </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LinkFace.EndChainage">
            <summary> End chainage of face </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LinkFace.FaceWeirs">
            <summary> Weir structures along face </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LinkFace._surfaceWaterLevel">
            <summary>
            Water level (surface elevation) from surface model
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LinkFace._surfaceWaterLevelOldAssigned">
            <summary> Flag indicating if <see cref="P:DHI.Mike1D.Engine.Couplings.LinkFace._surfaceWaterLevelOld"/> has been assigned - it is not in the very first time step </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LinkFace.SurfaceGroundLevel">
            <summary> Ground level of surface in the middle of the face </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.LinkFace.SurfaceVolume">
            <summary> Available volume on the surface side </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LinkFace.X1">
            <summary>
            coordinates of lateral link faces
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LinkFace.X2">
            <summary>
            coordinates of lateral link faces
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LinkFace.Y1">
            <summary>
            coordinates of lateral link faces
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.LinkFace.Y2">
            <summary>
            coordinates of lateral link faces
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LinkFace.#ctor(System.Double,System.Double,DHI.Mike1D.Engine.Couplings.LateralLink)">
            <summary>
            
            </summary>
            <param name="startChainage"></param>
            <param name="endChainage"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.LinkFace.CalculateFaceOutflowConcentration(System.Int32,DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Calculate concentration of flow out of the link for the specified component
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.SourceLink">
            <summary>
            A Source can connect to an outlet or to a manhole.
            <para>
            When connected to an outlet, it works as a standard link
            </para>
            <para>
            When connected to a manhole, water is exchanged through the top
            of the manhole, using a weir-type calculation.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.SourceLink.EquationTypes">
            <summary>
            Inlet equation types
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.SourceLink.InletParameters">
            <summary> Parameters for <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanInlet"/>, see <see cref="F:DHI.Mike1D.Engine.Couplings.SourceLink.SourceLinkType"/> </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.SourceLink.SourceLinkType">
            <summary>
            Type of source link
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.SourceLink.UrbanInletParameters">
            <summary>
            Parameters for <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanInlet"/>.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.SourceLink.ManHolesInflowSource">
            <summary>
            Inflow source, when <see cref="F:DHI.Mike1D.Engine.Couplings.SourceLink.SourceLinkType"/> is <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanInlet"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.SourceLink.AllowBackflow">
            <summary>
            Flag indicating if backflow is allowed, i.e. flow from source into outlet.
            <para>
            Flag is true by default, but historically disabled for urban-weir outlet and urban-pump outlet.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.SourceLink.InletNode">
            <summary> for <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanInlet"/>, the <see cref="F:DHI.Mike1D.Engine.Couplings.StandardLink.LinkNode"/> as a <see cref="T:DHI.Mike1D.Engine.EngineNodeVolume"/> </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.PrepareADInlet(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Prepare running with AD. Setting up AD boundaries on inlet.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.ApplyCouplingForcing(System.DateTime,System.DateTime)">
            <summary>
            This function is called by the perform time step routine, and it implements the interaction (water flows) coming from M21
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.QInflowFromCoupling(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            M21 to inlet calculates the exchange discharge and introduces it in the appropriate man hole. 
            Exponential smoothing is used for the water level transferred  from MIKE 21. Further an upper 
            limit is placed on the discharge in the form of the Qmax which is a user parameter. These 
            parameters along with a number of others parameters are read by M1D but not passed back to 
            M21 e.g. crest width, discharge coefficient etc. Note that the discharge passed to Mouse 
            consists of two contributions namely RR and the overland flow. The sum of these two are 
            confined by the Qmax. If the sum of contributions is greater than Qmax then the limitation
            is applied to overland flow first and then to the RR contribution. If the latter is also 
            restricted by Qmax then the excess is transferred into the MIKE 21 model i.e. the manhole is 
            surcharged and the flow may spill into MIKE 21 against a possible water level difference. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.InitializeInlet(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Initialize inlet link
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.InitializeInletSource(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Initialize the link for <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanInlet"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.InitializeStandardLink(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Initialize standard link
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.CheckGroundLevels(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Check that ground levels match. This is valid for inlet links
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.PrepareForTimeStep(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Prepare for next time step. Calculates discharge through link
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.GetDischarge">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLink.GetRunOffDischarge">
            <summary>
            Discharge from runoff out of link and into external model.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLinkFactory.SetupInletNode(System.String)">
            <summary> Setup inlet from node id </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.SourceLinkFactory.InitializeInlet(DHI.Mike1D.Engine.Couplings.SourceLink)">
            <summary>
            Initialize the link for <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.SourceLinkType.UrbanInlet"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.StandardLinkFactory._outletEngineNet">
            <summary> Engine net where the water level boundary is applied </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.SetupOutletNode(System.String)">
            <summary> Setup outlet from node id </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.SetupOutletReach(System.String,System.Double)">
            <summary> Setup outlet from reach location </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.SetupOutletStructure(System.String)">
            <summary> Setup outlet from structure id </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.SetupOutletSideStructure(System.String,System.Double)">
            <summary> Setup outlet of side structure from structure location (location on "main" branch) </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.SetupOutletPump(System.String)">
            <summary> Setup outlet from pump id </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.SetupOutletWeir(System.String)">
            <summary> Setup outlet from weir id </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.FindOutletLocation(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.ILocation)">
            <summary>
            Find outlet node from location. Throwing <see cref="T:DHI.Mike1D.Engine.Couplings.CouplingException"/> if there is no outlet
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.FindOutletStructure(DHI.Mike1D.Engine.EngineNet,System.String)">
            <summary>
            Find outlet from structure id, assuming structure is an outlet structure.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.FindOutletSideStructureLocation(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.StructureModule.IStructureCollection,DHI.Mike1D.Generic.ILocation,DHI.Mike1D.StructureModule.IStructure@)">
            <summary> Find outlet from side-structure id </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.FindOutletPump(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.StructureModule.IStructureCollection,System.String)">
            <summary> Find outlet from pump id, assuming pump is an outlet pump </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.FindOutletWeir(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.StructureModule.IStructureCollection,System.String)">
            <summary> Find outlet from weir id, assuming weir is an outlet weir </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLinkFactory.StructureIsMUTypeWeir(DHI.Mike1D.StructureModule.IStructure)">
            <summary> Flag out MU type weirs </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.StandardLink">
            <summary>
            A standard link is connected to an outlet.
            <para>
            Before each time step, an <see cref="P:DHI.Mike1D.Engine.Couplings.StandardLink.ExternalWaterLevel"/> is provided as input.
            This water level is adjusted to match bottom levels etc.
            </para>
            <para>
            The discharge out of the model is <see cref="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetDischarge"/>.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.StandardLink.LinkNode">
            <summary> Node that link is connected to. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.StandardLink.LinkLocation">
            <summary> Original location of link, or null if link is based on a node or structure id. Used for error reporting only </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.StandardLink._dischargeGetter">
            <summary> Getter for discharge out of the link </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.StandardLink._bnd">
            <summary> Open source boundary which the water level is applied on </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.StandardLink._constantWaterLevelBoundaryItem">
            <summary> Boundary item for <see cref="F:DHI.Mike1D.Engine.Couplings.StandardLink._bnd"/> water level boundary which the water leevl is applied on </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.StandardLink.WaterLevelBoundaryType">
            <summary> Type of water level boundary applied for standard links. Default is <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkWaterLevelBoundaryType.Coupled"/> </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.StandardLink.DischargeBoundaryType">
            <summary> Type of discharge transfer applied for standard links. Default is <see cref="F:DHI.Mike1D.Engine.Couplings.Enumerations.StandardLinkWaterLevelBoundaryType.Coupled"/> </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.StandardLink._internalAdComponentSource">
            <summary> Concentration inside the MIKE 1D model </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetLinkNode">
            <summary>
            Get outlet/link node
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.SetLinkNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Set outlet/link node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetM1DGroundLevel">
            <summary>
            Internal ground level
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.StandardLink.ExternalWaterLevel">
            <summary>
            External (surface) water level
            Unit: [m]
            Default: 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.StandardLink.ExternalGroundLevel">
            <summary>
            External (surface) ground level/bottom level
            Unit: [m]
            Default: 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.#ctor">
            <summary>
            Standard Link basic constructor, based on a boundary node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.SetInternalComponentInfo(System.String[],DHI.Generic.MikeZero.eumQuantity[])">
            <summary>
            Id of internal components.
            <para>
            Required for setting up the
            internal boundary condition.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetOutflowDirectionAngle">
            <summary>
            Get compass heading in degrees of outlet outflow direction.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.Initialize(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Initialize standard link
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.PrepareHD(DHI.Mike1D.Engine.EngineNet,System.DateTime,System.DateTime)">
            <summary>
            Prepare link, reassing boundary to network
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.PrepareAD(DHI.Mike1D.Engine.EngineNet,System.DateTime,System.DateTime)">
            <summary>
            Prepare running with AD. Setting up AD boundaries on outlet.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.InitializeAdBoundaries(System.Int32)">
            <summary>
            Setup constant boundary components for outlet boundary
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.TransferState">
            <summary>
            Prepare for time step, transferring current values to "old" values state
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.SetExternalWaterLevel(System.Double)">
            <summary>
            Set external water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.AssignExternalWaterLevelToOutletBoundary">
            <summary> 
            Assign water level to outlet boundary.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.AssignExternalConcentrationsToOutletBoundary">
            <summary> 
            Assign external concentrations to outlet boundary.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.SetExternalGroundLevel(System.Double)">
            <summary> Set the external ground level </summary>
            <param name="externalGroundLevel"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.SetExternalCoupledArea(System.Double)">
            <summary> Set the external coupled area </summary>
            <param name="externalGroundLevel"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetDischarge">
            <summary>
            Discharge out of link into external model, positive into external model.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetWaterLevel">
            <summary>
            Water level on the internal side of the link
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetInternalConcentration(System.Int32)">
            <summary>
            Outflow concentration, concentration in MIKE 1D.
            </summary>
            <param name="jCompIndex">MIKE 1D component index</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.SetExternalConcentration(System.Int32,System.Double)">
            <summary>
            Set boundary concentration for component at index <paramref name="compj"/>, i.e. concentration on the outside of the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetExternalConcentration(System.Int32)">
            <summary>
            Set boundary concentration for component at index <paramref name="compj"/>, i.e. concentration on the outside of the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.SetExternalConcentrations(System.Double[])">
            <summary>
            Set external concentrations for all components
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.CheckLinkBottomLevels(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Check bottom levels of outlet and surface, and produce
            a warning if there is a mismatch.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.ApplyExponentialSmoothing">
            <summary>
            Apply smoothing on the water level value.
            <para>
            Smoothing must be applied after calling <see cref="M:DHI.Mike1D.Engine.Couplings.StandardLink.AdjustWaterLevelBoundaryValue"/>.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.AdjustWaterLevelBoundaryValue">
            <summary>
            Adjust water level boundary value. When external water depth is small, a similar small depth is
            applied to MIKE 1D, handling differences in external and 1D bottom levels.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.StandardLink.GetWaterLevelBoundaryValue">
            <summary> Get value of the water level that was applied to the outlet boundary </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.UrbanRiverOutputSpecs">
            <summary>
            The UrbanRiverOutputSpecs handles output from urban/river model
            for urban-river links and surface-source (manhole-inlet) links
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.UrbanRiverOutputSpecs.ToModelType">
            <summary>
            Type of model that recieves data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverOutputSpecs.#ctor(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverOutputSpecs.SetupCoupledOutputForGridPoint(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Engine.GridPoint)">
            <summary>
            Setup output for grid point. This is for a river-urban link only.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverOutputSpecs.AddResultSpecifications(System.Collections.Generic.List{DHI.Mike1D.ResultDataAccess.ResultSpecification})">
            <summary>
            Add data items to data module and add result
            specification to the "DefaultHDResults" output file.
            </summary>
            <param name="resultsSpecs">List of result specifications from MIKE 1D Data object.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverOutputSpecs.TransferSurfaceNodeOutput2Results(DHI.Mike1D.Engine.EngineNode,System.Double,System.Double,System.Double)">
            <summary>
            Set output data for node coupled to surface.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverOutputSpecs.TransferRiverUrbanNodeOutput2Results(DHI.Mike1D.Engine.EngineNode,System.Double,System.Double)">
            <summary>
            Set output data for node coupled to another river/urban model.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.UrbanRiverLink">
            <summary>
            An Urban-River links connects two 1D models, typically an urban and a river model,
            but it can also connect two river models or two urban models.
            <para>
            On the one side the link is connected to an outlet.
            On the other side the link is connected to a source point.
            The link provides the outlet with a water level boundary value from the "source" side.
            The outlet provides a discharge back to the source as inflow.
            </para>
            <para>
            In river context, an outlet is an open water level boundary.
            </para>
            <para>
            The "internal" side of the link is the outlet side. The "external" side is the
            source point.
            </para>
            <para>
            On the urban side, the link is connected to an outlet, manhole or structure.
            </para>
            <para>
            On the river side, the link is connected to any connection to the reach. 
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Couplings.UrbanRiverLink.AllowBackflow">
            <summary>
            Flag indicating if backflow is allowed, i.e. flow from source into outlet.
            <para>
            Flag is true by default, but historically disabled for urban-weir outlet and urban-pump outlet.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.UrbanRiverLink.SourcePoint">
            <summary> Source point for river connection, used when the river model is the point source </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.UrbanRiverLink.SourcePointUrbanManhole">
            <summary> Source point for urban connection, used when the urban model is the point source </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.UrbanRiverLink._sourcePointComponents">
            <summary> Component source point for source side </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.UrbanRiverLink._internalComponentIndex">
            <summary> Index of AD component inside the link</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.UrbanRiverLink._sourceToInternalComponentConversion">
            <summary> Conversion factor from source to internal component concentrations </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverLink.GetSourceWaterLevel">
            <summary>
            Get water level from source point, and adjust for bottom levels from each side of the link.
            Water level is stored for later use
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverLink.GetSourcePointWaterLevel">
            <summary>
            Get raw water level from source point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverLink.ApplyCouplingForcing(System.DateTime,System.DateTime)">
            <summary>
            Get discharge from link (outlet - internal model)
            and add it as a source contribution to the "external" source
            part of the link.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.WeirLevee.SetExternalLeveeDfs1FileReadingTime(System.TimeSpan)">
            <summary>
            Reads the content of the external dfs1 file, containing the data of the levee crest level, which is used in a lateral link.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.WeirLevee.InterpolateLeveeData(System.Double)">
            <summary>
            when the data of the chainages of the lateral link is faced against the external levee data, the later must be interpolated in order to match the former.
            </summary>
            <param name="normalizedLinkchainage">The lateral link chainages from the couple file enters normalized, ie, involving values between 0 and 1.0</param>
            <returns> interpolated bed level</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.WeirLevee.ExtrapolateDfs1LeveeData(System.Double,System.TimeSpan)">
            <summary>
            This function reads the dfs1 file with external data for the crest level at the lateral link.
            </summary>
            <param name="normalizedLinkchainage"></param>
            <param name="latLinkSideRiver"></param>
            <param name="simulatedTime"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.WeirLevee.ReadExternalLeveeFile(System.IO.FileStream,System.Collections.Generic.List{System.Double}@,System.Collections.Generic.List{System.Double}@)">
            <summary>
            M1D Reads the .txt file for the crest level (or bed level) used in the parametrization of the lateral links
            coupling between M21 and the river models (M11 or M1D).
            </summary>
            <param name="txtFileStream"></param>
            <param name="chainages"> Chainages specifying the location of the bed levels</param>
            <param name="bedLevels"> Bed levels data to be used at the lateral link</param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.Couplings.UrbanRiverLinkBuilder">
            <summary>
            Helper class for building an <see cref="P:DHI.Mike1D.Engine.Couplings.UrbanRiverLinkBuilder.UrbanRiverLink"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Couplings.UrbanRiverLinkBuilder._sourcePointNet">
            <summary> Engine net where the discharge point source boundary is applied </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverLinkBuilder.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Create class, bulding a river-urban link
            </summary>
            <param name="outletEngineNet">Outlet model engine net</param>
            <param name="sourceEngineNet">Source model engine net</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverLinkBuilder.SetupSourceNode(System.String)">
            <summary>
            Setup source point on node. Node must be an internal node.
            <para>
            This is usually on the urban model (river outlet spilling into urban node)
            </para>
            <para>
            This sets up source points for adding source contributions, and
            water level getters, for providing a water level to the outlet.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverLinkBuilder.SetupSourceReach(System.String,System.Double)">
            <summary>
            Setup source point on reach grid point.
            <para>
            This is usually on the river model (urban outlet spilling into river)
            </para>
            <para>
            This sets up source points for adding source contributions, and
            water level getters, for providing a water level to the outlet.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Couplings.UrbanRiverLinkBuilder.Initialize">
            <summary>
            Initialize standard link
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.LateralLinkCrestLevels">
            <summary>
            Crest levels of lateral link, river model and surface model.
            <para>
            Can store the crest level as cross section data.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineCatchmentValueBuffer._timeOld">
            <summary>
            Variable holding information on the latest calulated time
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNetBoundaryConnector">
            <summary>
            Class for connecting boundaries to EngineNet (HD).
            <para>
            It can also connect boundaries to XXX, for creating an LTS job list where EngineNet and HD is not required.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetBoundaryConnector._engineNet">
             Open boundaries:
             - There can only be one open boundary source per open boundary in the model.
               Validation is performed as a final step.
             - The boundary source is assigned directly to the engine node, and handled by the
               engine node (HD node) while setting up node coefficients.
            
             Point boundaries
             - Are connected to the engine using a point-source-handler
             - Are applied at ApplyExternalSources-event
            
             Distributed boundaries
             - Are connected to the engine using a distributed-source-handler
             - Are applied at ApplyExternalSources-event
             - Those depending on HD (surface area) cannot be applied without HD running
            
             Global boundaries
             - Are connected to the engine using a global-source-handler
             - Are applied at ApplyExternalSources-event
             - Most are depending on HD (surface area), and cannot be applied without HD running
            <summary>
            EngineNet, can be null when connecting to LTS
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNetBoundaryConnector.IncludeOnlyStormRunoff">
            <summary>
            Flag used to include only Storm Runoff inflow.
            This is used by the LTSJobListCreator.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetBoundaryConnector.AssignBoundaries(DHI.Mike1D.BoundaryModule.BoundaryData)">
            <summary>
             Assign all but open boundaries from the BoundaryData object
            </summary>
            <param name="bndData"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetBoundaryConnector.AssignOpenBoundaries(DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
             Assign all boundaries from the BoundaryData object
            </summary>
            <param name="bndData"></param>
            <param name="runtimeDiagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetBoundaryConnector.AssignPointSourceBoundary(DHI.Mike1D.BoundaryModule.IPointSourceBoundary)">
            <summary>
            Assign a single point source boundary
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetBoundaryConnector.AssignDistributedBoundary(DHI.Mike1D.BoundaryModule.IDistributedSourceBoundary)">
            <summary>
            Assign a single distributed boundary
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetBoundaryConnector.AssignBoundarySource(DHI.Mike1D.BoundaryModule.IPointSourceBoundary)">
            <summary>
            Assign a single boundary by adding boundary source to each module.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetBoundaryConnector.AssignBoundarySource(DHI.Mike1D.BoundaryModule.IDistributedSourceBoundary)">
            <summary>
            Assign a single boundary by adding boundary source to each module.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetBoundaryConnector.AssignBoundarySource(DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary)">
            <summary>
            Assign a single boundary by adding boundary source to each module.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ValueIdListItemSource">
            <summary>
            Helper class, wrapping an entry into <see cref="T:DHI.Mike1D.Generic.Collections.ValueIdList"/>
            into an <see cref="T:DHI.Mike1D.Engine.ISourcePoint"/>.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNetCatchmentConnector">
            <summary>
            Class connecting catchments to HD
            <para>
            It handles both live catchment values and
            values from RR result files.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNetCatchmentConnector.IncludeOnlyStormRunoff">
            <summary>
            Flag used to include only Storm Runoff inflow.
            This is used by the LTSJobListCreator.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetCatchmentConnector.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.RainfallRunoffModule.RainfallRunoffData,DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.STDataAccess.STData,DHI.Mike1D.ResultDataAccess.ResultDataBuffer)">
            <summary>
            Create connector for connecting to <see cref="T:DHI.Mike1D.Engine.EngineNet"/>, i.e. the network engine
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetCatchmentConnector.#ctor(DHI.Mike1D.Generic.Collections.NetworkValueIdList,DHI.Mike1D.RainfallRunoffModule.RainfallRunoffData,DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.ResultDataAccess.ResultDataBuffer)">
            <summary>
            Create connector for connecting to <see cref="T:DHI.Mike1D.Generic.Collections.NetworkValueIdList"/>, i.e. when storing values for other processing
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentRRCDHandler">
            <summary> Helper class for <see cref="M:DHI.Mike1D.Engine.EngineNetCatchmentConnector.ConnectCatchments(DHI.Mike1D.Generic.IDiagnostics)"/> </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetCatchmentConnector.SetupNetRainfall(DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase,System.Collections.Generic.List{DHI.Mike1D.BoundaryModule.CatchmentComponentSourceBoundary})">
            <summary>
            NetRainfall concentrations is applied on NetRainfall from catchments,
            but only for distributed catchment connections (<see cref="T:DHI.Mike1D.Engine.EngineDistributedSourceRunoffHandler"/>)
            and only if the flag <see cref="P:DHI.Mike1D.NetworkDataAccess.CatchmentConnection.IsOverlappingRiverArea"/> is set.
            </summary>
            <param name="handler">Distributed Source Runoff Handler</param>
            <param name="ccsbList">Catchment component sources: Only NetRainfall quantities are used, the rest is discarded.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetCatchmentConnector.FindCatchmentComponentSources(DHI.Mike1D.BoundaryModule.BoundaryData)">
            <summary>
            For each CatchmentId, collect all CatchmentComponentSourceBoundary's
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNetCatchmentConnector.ResultFileData">
            <summary>
            Helper class, storing one ResultData object and additional
            data objects related to that ResultData object.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentResultFileData">
            <summary>
            Helper class, storing one ResultData object and additional
            data objects related to that ResultData object.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentResultFileData.CatchmentResultFile">
            <summary> Origin of this object </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentResultFileData.AdaptiveEvaluater">
            <summary> Evaluator for adaptive boundaries. Only relevant for HD boundaries, so not stored in CatchmentResultFileData </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentResultFileData.PointSourceHandlerMap">
            <summary> Map for reusing point source boundary handlers for RR and CD </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentResultFileData.ComponentResultFiles">
            <summary> ResultFileData matching <see cref="P:DHI.Mike1D.BoundaryModule.CatchmentResultFile.ComponentResultFiles"/> </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentResultFileData.ComponentResultFileComponents">
            <summary> ComponentId's for all ComponentResultFiles. Null if valid for all components </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentAdaptiveTimeSeriesEvaluator">
            <summary>
            Helper class to calculate preferred time step based on a
            list of times and a list of values.
            <para>
            This class is intended for cases where only one value serie
            use this time axis.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentAdaptiveTimeSeriesEvaluator.#ctor(DHI.Mike1D.RainfallRunoffModule.Catchment,DHI.Mike1D.RainfallRunoffModule.CatchmentValueBuffer,System.Collections.Generic.IReadOnlyList{System.Double})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetCatchmentConnector.CatchmentAdaptiveTimeSeriesEvaluator.GetPreferredTimeStep(System.DateTime,System.TimeSpan,System.TimeSpan,System.Double,System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineShadowReach">
            <summary>
            A shadowreach is a used during MPI execution to store reach state for the reaches that connects different subdomains.
            </summary>
            An <see cref="T:DHI.Mike1D.Engine.EngineShadowReach"/> deliberatly extends from an EngineReach, 
            since the method can not be changed during the simulation.
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineShadowReach.Domain">
            <summary>
            domain number of reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineShadowReach.DivideAt(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Cuts away the piece of the reach that is after location and returns the cut
            away piece as a new reach. Node is used for connecting the two.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineShadowReach.CreateNewReach">
            <summary>
            Create a new empty EngineReach of the correct type. 
            Used by the <see cref="M:DHI.Mike1D.Engine.EngineShadowReach.DivideAt(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.Engine.EngineNode)"/> method.
            <para>
            Override to return a specialized version of the <see cref="T:DHI.Mike1D.Engine.EngineReach"/>
            </para>
            </summary>
            <returns>A new empty engine reach of the correct type</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.NetworkStateWriter`1">
            <summary>
            Helper class for writing network state to state file.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NetworkStateWriter`1.ReachCount">
            <summary>
            Number of reaches in state
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateWriter`1.GetReachIndices(System.Int32)">
            <summary>
            Index list (which grid points) to get values from for reach with index <paramref name="i"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateWriter`1.GetReachValues(System.Int32)">
            <summary>
            Values for each with index <paramref name="i"/>, number of values must match the
            list returned by <see cref="M:DHI.Mike1D.Engine.NetworkStateWriter`1.GetReachIndices(System.Int32)"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateWriter`1.WriteState(DHI.Mike1D.ModelState.ModelStateWriter,System.String)">
            <summary>
            Write network state to <paramref name="writer"/>, using <paramref name="name"/>.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.NetworkStateWriter`2">
            <summary>
            Helper class for writing network state to state file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateWriter`2.WriteState(DHI.Mike1D.ModelState.ModelStateWriter,System.String)">
            <summary>
            Write network state to <paramref name="writer"/>, using <paramref name="name"/>.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.NetworkStateReader`2">
            <summary>
            Helper class for applying a network state to the network module.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateReader`2.#ctor(DHI.Mike1D.Engine.IModuleNetwork{`0,`1},DHI.Mike1D.Generic.NetworkData{System.Double},System.Func{`1,System.Int32[]},System.Action{`1,System.Int32,System.Double})">
            <summary>
            Create network state reader class
            </summary>
            <param name="network">Module with network data</param>
            <param name="data">State data</param>
            <param name="reachIndexListSelector">Index list selector, usually returning the H- or Q-indexlist for the network reach</param>
            <param name="gpValueSetter">Action for setting a grid point value to the grid point on the specified reach and specified grid opint index.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateReader`2.#ctor(DHI.Mike1D.Engine.IModuleNetwork{`0,`1},DHI.Mike1D.Generic.NetworkData{System.Double},System.Action{`0,System.Double},System.Func{`1,System.Int32[]},System.Action{`1,System.Int32,System.Double})">
            <summary>
            Create network state reader class
            </summary>
            <param name="network">Module with network data</param>
            <param name="data">State data</param>
            <param name="nodeValueSetter">Action for setting a node value on the specified node</param>
            <param name="reachIndexListSelector">Index list selector, usually returning the H- or Q-indexlist for the network reach</param>
            <param name="gpValueSetter">Action for setting a grid point value to the grid point on the specified reach and specified grid opint index.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateReader`2.#ctor(DHI.Mike1D.Engine.IModuleNetwork{`0,`1},DHI.Mike1D.Generic.NetworkData{System.Double},System.Action{`0,System.Double})">
            <summary>
            Create network state reader class
            </summary>
            <param name="network">Module with network data</param>
            <param name="data">State data</param>
            <param name="nodeValueSetter">Action for setting a node value on the specified node</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateReader`2.ApplyValues">
            <summary>
            Apply state values.
            <para>
            Loops over all nodes adn grid points, checks if a local value is available,
            and if found, applies the local value
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.NetworkDataStateReader">
            <summary>
            Extension class handling network state reading
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkDataStateReader.ReadNetworkState(DHI.Mike1D.ModelState.ModelStateReader,System.Int32[],System.Int32[])">
            <summary>
            Read a network state, based on the indices of nodes and reaches specified, 
            storing values in a <see cref="T:DHI.Mike1D.Generic.NetworkData`1"/> object.
            <para>
            A network states contains one array of node values, matching the <paramref name="nodes"/>input, 
            and a number of arrays of reach values, matching the <paramref name="reaches"/> input. For 
            reaches, the array must contain values on all H grid points or all Q grid points.
            </para>
            </summary>
            <returns><see cref="T:DHI.Mike1D.Generic.NetworkData`1"/> object containing state values.</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNodeStructure">
            <summary>
            A node without volume, but with <see cref="T:DHI.Mike1D.Engine.INodeStructure"/> functionality.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeStructure.OutletReachId">
            <summary>
            ID of outlet structure
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeStructure.Structure">
            <summary>
            Node structure
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeStructure.#ctor(System.String,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.INodeStructure">
            <summary>
            Interface for a node structure.
            <para>
            A node structure must have three reaches connected, 
            and the 3rd reach is a special reach where the discharge
            into the reach is controlled by the <see cref="M:DHI.Mike1D.Engine.INodeStructure.CalculateDischarge(System.DateTime)"/>
            method.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.INodeStructure.Initialize(DHI.Mike1D.Engine.ModuleHD.IHDStructureNode,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize structure.
            </summary>
            <param name="hdNode">The HD node that the structure is connected to</param>
            <param name="diagnostics">Diagnostics to report issues to</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.INodeStructure.CalculateDischarge(System.DateTime)">
            <summary>
            Calculate discharge through structure.
            <para>
            This is the maximum discharge that will go through the structure.
            If there are less water available than what is calculated here, 
            the actual discharge through the structure may be less.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.INodeStructure.FinalizeTimestep(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Finalize time step. Can be used to update statistics or issue warnings.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.LinkRegulationStructure">
            <summary>
            Link regulation structure, specific for link regulation reaches. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.LinkRegulationStructure.ActualDischarge">
            <summary>
            Discharge for a single structure. 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.LinkRegulationStructure._discharge">
            <summary>
            Discharge for a single structure. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.Initialize(DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.CrossSectionModule.ICrossSection,System.Boolean,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Set up structure and set runtime diagnostics object
            </summary>
            <param name="isLinkStructure"> </param>
            <param name="diagnostics">Diagnostics that errors are reported to</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.ValueGetter(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.SetWaterLevels(System.Double,System.Double)">
            <summary>
            Sets up- and down- stream water level. For DischargeGate, SetWaterLevels() does nothing else 
            than implements limits on discharge if _upstreamWaterLevelMinMaxTable != null.
            </summary>
            <param name="upStreamWaterLevel">Upstream water level [m]</param>
            <param name="downStreamWaterLevel">Downstream water level [m]</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.LinkRegulationStructure.Type">
            <summary>
            Structure type, unique for each structure.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.Validate">
            <summary>
            Writes errors, warnings and hints into their respective member classes. The member objects are initially cleared.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.LinkRegulationStructure.InvertLevelUpstream">
            <summary>
            Invert level up stream
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.LinkRegulationStructure.InvertLevelDownstream">
            <summary>
            Invert level down stream
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.ResetControlledState">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.ControlSetDischarge(System.Double,System.Int32)">
            <summary>
            Set the discharge to use
            </summary>
            <param name="newDischarge">New discharge</param>
            <param name="controlStrategyId">Control strategy id currently used.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.ControlClose(System.Int32)">
            <summary>
            Close gate, set the discharge to zero
            </summary>
            <param name="controlStrategyId">Control strategy id currently used.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.GetControlAction(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.GetCurrentValue(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.LinkRegulationStructure.ToString">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADDomain.Components">
            <summary>  AD components, shortcut to AD Data components list</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADDomain.Domain">
            <summary>
            Domain identifyer
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADDomain.ADReaches">
            <summary>
            List of all HD reaches in network. 
            <para>
            Need not include all Engine reaches, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetHDReach(DHI.Mike1D.Engine.EngineReach)"/> 
            to check if a given engine reach also has a corresponding HD reach.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADDomain.ADNodes">
            <summary>
            List of all HD nodes in network. 
            <para>
            Need not include all Engine nodes, use the <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetADNode(DHI.Mike1D.Engine.EngineNode)"/> 
            to check if a given engine node also has a corresponding AD node.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADDomain.#ctor(System.Int32,DHI.Mike1D.Engine.ModuleAD.ADModule)">
            <summary>
            Constructor creating a new ADDomain and initializing it with the given EngineNet and
            AD parameters.
            </summary>
            <param name="domain"></param>
            <param name="adModule"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADDomain.PerformTimestep(System.Int32[])">
            <summary>
             Perform timestep and return true if solution is accepted. 
             Can be called several times for different values of Dt.
            </summary>
            <returns>True on success</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADDataItems">
            <summary>
            Class that contains data items (AD add-ons) that can be reused.
            </summary>
            <remarks>
            This class is intended to avoid several versions
            of the same data item (AD add-ons) are created, 
            if e.g. you need to calculate a value 
            in more than one location, the same data item is used.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADDataItems.EnsureExistence``1(``0[]@)">
            <summary>
            If array is null, create it.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADDataItems.TransportAccumulated(System.Int32)">
            <summary>
            Enable Accumulated transport in network for component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADDataItems.DecayAccumulated(System.Int32)">
            <summary>
            Enable decay accumulated data-item/results in network for component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADDataItems.DecayAccumulated(System.Int32,System.Boolean)">
            <summary>
            Enable decay accumulated data-item/results in network for component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADDataItems.MassErrorAccumulated(System.Int32)">
            <summary>
            Enable Mass error accumulated data-item/results for component in network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADDataItems.MassBalanceChecksumAccumulated(System.Int32)">
            <summary>
            Enable Mass balance checksum accumulated data-item/results for component in network.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADTotalValuesCalculator">
            <summary>
            Helper class for calculating total values of mass balance
            terms. One class with one update function, in order to
            visit iterate the entire AD module only once per timestep
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADTotalValuesAccumulatedCalculator">
            <summary>
            Helper class to calculate accumulated total values of mass balance
            terms. One class with one update function, in order to
            visit the entire AD module only once per timestep
            <para>
            It uses the <see cref="T:DHI.Mike1D.Engine.ModuleAD.ADTotalValuesCalculator"/> to calculate
            the values, in output units.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADInitialConditions">
            <summary>
            Setting of AD initial conditions, wrapping the 
            different options for statestart, hostart, parameter 
            conditions.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.IADGridPoint">
            <summary>
            Interface for an AD grid point, containing component values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADGridPoint.ValuesNp1">
            <summary>
            Component values in grid point
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADGridPoint.GridPoint">
            <summary>
            The HD gridpoint used as basis for the AD calculations
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.Scheme.M11">
            <summary>
            Original M11 scheme, semi-implicit with an explicit
            3rd order correction term.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.Scheme.Direct">
            <summary>
            The direct (unlimited) method, if order = 3 it is 
            matching the Quickest scheme. Order = 3,4,5 is available
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.Scheme.Ultimate">
            <summary>
            Using the Ultimate limiter on the direct method. 
            Order = 3,4,5 is available
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.Scheme.Eno">
            <summary>
            ENO scheme
            Order = 1,2,3 is available. Order = 1: 1st order upwinding.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.Scheme.Weno">
            <summary>
            WENO scheme. Always order 3/5.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint._hdhGridPoint">
            <summary>H gridpoint that AD gridpoint belongs to</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint._adReach">
            <summary>ADReach for grid point</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint._dispersionParameters">
            <summary>
            The dispersion parameters for this grid point
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.LocalDecayCoefficients">
            <summary>
            Local decay coefficients for all components. Pointing to global set of coefficients, if no values are defined.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.ValuesNp1">
            <summary>
            Array of component values (concentrations) at time Np1.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.ValuesN">
            <summary>
            Array of component values (concentrations) at time N.
            <para>
            Only required for additional outputs (mass error, decay etc), 
            not required for basic AD scheme.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.VolumeN">
            <summary>
            Volume at time N. 
            <para>
            This will by default equal the HD grid point volume, unless
            the AD module is sub-stepping the HD time step
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.VolumeNp1">
            <summary>
            Volume at time N+1. 
            <para>
            This will by default equal the HD grid point volume, unless
            the AD module is sub-stepping the HD time step
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.CourantNumber">
            <summary>
            Courant number for current time step, extracted from HD module
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SourceInflowMassPerSecForComponent">
            <summary> The inflow mass per second ([kg/s] if SI) in this timestep from an external source per component. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.DispersionParameters">
            <summary>
            The dispersion parameters for this grid point
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.HDHGridPoint">
            <summary>
            The HDHGridPoint covered by this ADGridPoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.PrepareForTimeStep(System.Int32[],DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Copy calculated value for component to temporary value used in the computation
            </summary>
            <param name="activeComponents"></param>
            <param name="time"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.StartEndDispersionCoefficient">
            <summary>
            Returns the D*A dispersion coefficient for the current
            time step for the first/last grid point in the reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SetupCoefficientsInside(System.Int32[],System.Double,System.Double)">
            <summary>
            Setup coefficients inside this gridpoint, i.e. the parts that does not depend on
            neighbouring AD grid points (only setting values to _co2 and _co4)
            </summary>
            <param name="hdVolumeError">Volume error in [m3]</param>
            <param name="ddt">Time step (inverse)</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.CalculateAdvectionTransport(DHI.Mike1D.Engine.ModuleAD.ADReach,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Calculate boundary flux over the the boundary between grid point i and i+1, where i is the
            <paramref name="faceIndex"/>.
            </summary>
            <param name="adReach">Reach</param>
            <param name="componentIndex">Index of component</param>
            <param name="faceIndex">Index of face, first face (index 0) is in between ad grid point 0 and 1</param>
            <param name="q">Discharge on phase</param>
            <param name="ddt">Inverse time step</param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.CalculateBoundaryValue(DHI.Mike1D.Engine.ModuleAD.ADReach,System.Int32,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Calculate boundary flux over the the boundary between grid point i and i+1, where i is the
            <paramref name="faceIndex"/>.
            </summary>
            <param name="adReach"></param>
            <param name="componentIndex"></param>
            <param name="faceIndex">Index of face, first face (index 0) is in between ad grid point 0 and 1</param>
            <param name="hPrevIndex"> </param>
            <param name="ddt"></param>
            <param name="q"> </param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SetStartCEqualCCoefficients">
            <summary>
            Set coefficients for this grid point connected to EndNode
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SetEndCEqualCCoefficients">
            <summary>
            Set coefficients for this grid point connected to EndNode
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SetStartCEqualCPrevCoefficients">
            <summary>
            Set coefficients for this grid point matching 
            concentration of prev grid point (boundary, 
            grid point with out volume and no boundary value
            available (outlet))
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SetEndCEqualCPrevCoefficients">
            <summary>
            Set coefficients for this grid point matching 
            concentration of prev grid point (boundary, 
            grid point with out volume and no boundary value
            available (outlet))
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.CalculateDecay(System.Int32)">
            <summary>
            Calculate the amount of decay (mass/s) in last time step.
            <para>
            This must only be called after the completion of a time step
            </para>
            <para>
            Synchronized with implementation in <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SetupCoefficientsInside(System.Int32[],System.Double,System.Double)"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.Evaluate(System.Int32,System.Double,System.Double)">
            <summary>
            Based on firstValue (value on start node) and lastValue
            (value on end node), calculate solution on each gridpoint
            in reach based on:
               val = e0*firstValue + e1*lastValue + f
            </summary>
            <param name="solIndex">solution index</param>
            <param name="firstValue">Value at start node</param>
            <param name="lastValue">Value at end node</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.Offers">
            <summary>
            List of data types that is offered, i.e., that you can get a ValueGetter for.
            </summary>
            <returns>List of data types offered</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.Accepts">
            <summary>
            List of data types that is accepted, i.e., that you can get a ValueSetter for.
            </summary>
            <returns>List of data types accepted</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.ValueGetter(System.Int32)">
            <summary>
            Get value setter for the specified data quantity
            </summary>
            <param name="quantityIndex">Requested Quantity, index in <see cref="M:DHI.Mike1D.Generic.IQuantityProxy.Offers"/></param>
            <returns>A value getter delegate that can set the value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.ValueSetter(System.Int32)">
            <summary>
            Get value setter for the specified data type
            </summary>
            <param name="quantityIndex">Requested Quantity, index in <see cref="M:DHI.Mike1D.Generic.IQuantityProxy.Accepts"/></param>
            <returns>A value setter delegate that can set the value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.AddSourceContribution(System.Int32,System.Double)">
            <summary>
             Add a mass contribution to the AD source for the specified component.
            </summary>
            <param name="componentIndex"> </param>
            <param name="massPerSec"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.AddSourceContribution(System.Int32,System.Double,System.Double)">
            <summary>
             Add a concentration contribution to the source for the specified component.
            </summary>
            <param name="componentIndex"> </param>
            <param name="concentration">Value to add to source</param>
            <param name="inflow">Discharge </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.GetChainageIph(System.Int32,DHI.Mike1D.Engine.ModuleAD.ADReach)">
            <summary>
            Return the chainage coordinate at i+, i.e. the border of
            gridpoint i and i+1
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADModule">
            <summary>
            AD module handles component transport
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADModule.UseHighOrderMethod">
            <summary>
            Flag to always use low order method, for testing purposes.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADModule.WaterVolumeErrorConcentrationCorrection">
            <summary>
            Flag indicating how water volume errors are handled for AD components.
            When true, the concentration is kept constant, and mass is added/removed matching the volume error.
            When false, the mass is kept constant, and the concentration changes with the volume error.
            Default is true
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADModule.STWaterVolumeErrorConcentrationCorrection">
            <summary>
            Flag indicating how water volume errors are handled for suspended ST components.
            When true, the concentration is kept constant, and mass is added/removed matching the volume error.
            When false, the mass is kept constant, and the concentration changes with the volume error.
            Default is false
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADModule.ADTransportComponents">
            <summary> Mapping an AD-transport component index to an AD-data component index </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.Components">
            <summary>  AD components, shortcut to AD Data components list</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.DataItems">
            <summary>
            Data items for the HD module that can be reused.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.RuntimeDiagnostics">
            <summary>
            Diagnostics instance for the AD module. Used during runtime.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.HDModule">
            <summary>
            HD module instance used in the AD module. Used during runtime.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.ADCourantStatistics">
            <summary>
            HD module instance used in the AD module. Used during runtime.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Maps an <see cref="T:DHI.Mike1D.Engine.EngineNode"/> to the corresponding AD Node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Maps an <see cref="T:DHI.Mike1D.Engine.EngineReach"/> to the corresponding AD Reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetProxy(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a proxy for the node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a proxy for the gridpoint in the reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADModule.FaceProxy">
            <summary>
            Helper class for providing face transport on a grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetProxy(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, covering a number of gridpoints
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetProxyReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, generic data (not gridpoint associated)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetProxy">
            <summary>
            Get a proxy for generic/global data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.Id">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.Order">
            <summary>
            Order of module. Modules are processed in order. 
            The AD module must run after the HD module. The HD module has order 200.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.Reaches">
            <summary>
            List of AD Reaches
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADModule.Nodes">
            <summary>
            List of AD Nodes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Prepare module for first time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.PrepareForTimeStep(System.Int32)">
            <summary>
             Prepare module for time step (set state(n+1) = state(n)).
             <para>
             </para>
            </summary>
             <param name="redoCount">
             Number of times this time step is redone. First time called
             for one time step, it will have the value of zero, and 
             if a time step needs to be redone, this will be larger than zero
             </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.PerformTimestep">
            <summary>
             Perform timestep and return true if solution is accepted. 
             Can be called several times for different values of Dt.
            </summary>
            <returns>True on success</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.PerformTimestep(System.Int32[])">
            <summary>
             Perform timestep and return true if solution is accepted. 
             Can be called several times for different values of Dt.
            </summary>
            <returns>True on success</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.FinalizeTimestep">
            <summary>
            FinalizeTimeStep allows the modules to do operations required when 
            a time step has successfully completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.Finish">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.PreferredTimeStep(System.Boolean,System.TimeSpan)">
            <summary>
             Returns the preferred time step for the current state. It is called between every time step
             and can increase as well as decrease the time step.
             <para>
             Used when <see cref="P:DHI.Mike1D.Engine.EngineTime.AdaptiveTimeSteppingActivated"/> is true.
             </para>
             <para>
             Do return the maximum of the allowed time step; in case a buffer is required, this is handled
             by a time step controller.
             </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.DecompositionNodeAndReachList">
            <summary>
            Domain decomposition using METIS 
            
            </summary>
            <returns>
            A list representing which nodes/reaches is associated with which domain
            </returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetSourcePointProxy(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a source point proxy for the node.
            <para>
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </para>
            </summary>
            <param name="node">Node to get source point proxy for</param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.GetSourcePointProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a source point proxy for the gridpoint in the reach.
            <para>
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </para>
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="gridPointIndex">Index to gridpoint to get source point for</param>
            <returns>A source point proxy</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADModule.WriteState(DHI.Mike1D.ModelState.ModelStateWriter)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADModule.SourcePointProxyNode">
            <summary>
            Simple proxy for ADNode to turn it into a ISourcePointProxy
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADModule.SourcePointProxyGridPoint">
            <summary>
            Simple proxy for ADNode to turn it into a ISourcePointProxy
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.IADReach">
            <summary>
            A reach in the AD module, containing a number of AD grid points.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADReach.HDReach">
            <summary>
            The HD reach which this ADReach "covers"
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADReach.StartNode">
            <summary>
            Upstream node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADReach.EndNode">
            <summary>
            Downstream node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADReach.GridPoints">
            <summary>
            List of AD grid points
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADReach.ComponentTransport">
            <summary>
            Component transport. For each component contains
            value of transport from one grid point to the next.
            <para>
            All reaches but structure reaches include a transport point at the
            beginning and the end of the reach, specifying the transport into/out-of 
            the reach in the first/last grid point. Hence, the number of transport points 
            is number of AD gridpoints + 1 (-1 for structure reaches)
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADReach">
            <summary>
            Advection Dispersion reach that holds a list of ADGridPoints. An ADReach "covers" a HDReach
            with one ADGridPoint per HDHGridPoint in the HDHReach.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReach._hdReach">
            <summary>
            The HDReach which this ADReach "covers"
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReach._offersFace">
            <summary>
            Offers on faces (in between grid points), must be synchronized with ADGridPoint implementation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReach._offersGridpoint">
            <summary>
            Offers in grid points, must be synchronized with ADGridPoint implementation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReach._adGridPoints">
            <summary>
            Each entry in this list is an AD grid point. The number of values in
            each array of double is the number of AD components.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReach._startNode">
            <summary>
            Up- and downstream AD nodes.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReach._dispersionCoeffOnFace">
            <summary> 
            Dispersion coefficients (dAreaOverD2x) used over each face, also boundary/node-faces. 
            <para> It has one more element than the number of AD grid points. </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReach._componentTransport">
            <summary>
            For component and each face, component transport over the face in [adCompUnit * m3/s],
            so if ad component unit is [g/m3], component transport is in [g/s].
            <para>
            All reaches but structure reaches include a face transport point at the
            beginning and the end of the reach, i.e. number of faces is number of 
            AD gridpoints + 1 (-1 for structure reaches)
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.ComponentTransport">
            <summary>
            For component and each face, component transport over the face in [adCompUnit * m3/s],
            so if ad component unit is [g/m3], component transport is in [g/s].
            <para>
            All reaches but structure reaches include a face transport point at the
            beginning and the end of the reach, i.e. number of faces is number of 
            AD gridpoints + 1 (-1 for structure reaches)
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReach.DispersionDelta">
            <summary>
            Set to 1 to have fully implicit dispersion. Set to 0.5 for most accurate dispersion. Do not set below 0.5.
            See also ADNode dispersion calculations, which need to match this
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.HDReach">
            <summary>
            The HD reach which this ADReach "covers"
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.IndexList">
            <summary>
            Index list of AD gridpoints, matching that one of HD H-gridpoints.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.IndexListFace">
            <summary>
            Face index list, including first and last face between node and first/last grid point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.#ctor(DHI.Mike1D.Engine.ModuleAD.ADModule,DHI.Mike1D.Engine.ModuleHD.IHDReach,DHI.Mike1D.Engine.ModuleAD.ADNode,DHI.Mike1D.Engine.ModuleAD.ADNode)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetConnection(DHI.Mike1D.Engine.ModuleAD.ADReachConnection)">
            <summary>
            Set a start or end connection
            </summary>
            <param name="connection"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.GetHDFromADIndex(System.Int32)">
            <summary>
            From an ad grid point index number, return the index of the HD grid point belonging
            to the AD grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.Initialize(System.Double[],DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize this ADReach
            </summary>
            <param name="globalDecayConstants"> </param>
            <param name="runtimeDiagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.Prepare(System.Collections.Generic.List{DHI.Mike1D.ADDataAccess.ADComponent},DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Prepare sets the initial concentrations for all components
            </summary>
            <param name="components"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.PrepareForTimeStep(System.Int32[],DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Prepare component for next time step
            </summary>
            <param name="activeComponents"></param>
            <param name="time"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetupReachEndCoefficients(System.Int32[],System.Double,System.DateTime)">
            <summary>
            SetupReachEndCoefficients() calls the up- and downstream nodes in order to setup the coefficients
            at both reach ends. The nodes then ask the reach to setup the correct coefficients.
            The reason for this round-about construction is that SetupReachEndCoefficients() is called
            from ADModule before SolveFirstPart() and those two can be run in parallel for all reaches.
            If ADModule was to call ADNode.SetupReachCoefficients() directly to setup all coefficients
            on the reaches around that node, then SetupReachEndCoefficients() and SolveFirstPart() could not
            be run in the same parallel block.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetupCoefficients(System.Double,System.Int32[])">
            <summary>
            Set coefficients for internal grid points (all but face between node and first/last gridpoint)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetupCoefficientsOnFace(System.Int32,System.Double,System.Int32[],System.Boolean,System.Double)">
            <summary>
            Set up coefficients on face. Handles advection and dispersion over face.
            <para>
            If the start/end connection is set, the coefficients are stored in the
            connection instead of in the grid point, because it is a boundary gridpoint
            </para>
            </summary>
            <param name="faceIndex">Index of face, between grid point at index i and i+1</param>
            <param name="discharge">Discharge at face</param>
            <param name="activeComponents"></param>
            <param name="includeDispersion">Include dispersion</param>
            <param name="ddt"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetupCoefficientsDispersion(DHI.Mike1D.Engine.ModuleAD.ADGridPoint,DHI.Mike1D.Engine.ModuleAD.ADGridPoint,System.Double,System.Double,System.Double,System.Int32[])">
            <summary>
            Setup coefficients for dispersion over face between prev and next AD grid point, i.e.
            it updates both the previous and next AD grid point.
            </summary>
            <returns>It returns the D*A/D2x coefficient used</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateTransport(System.Int32[])">
            <summary>
            Update FaceTransport array, matching transport implementation in <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetupCoefficients(System.Double,System.Int32[])"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateTransportOnFace(System.Int32,System.Double,System.Int32[],System.Boolean)">
            <summary>
            Calculate the face transport, i.e. mass/s transported over each of the internal faces.
            <para>
            This is synchronized with the transport implementation in <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetupCoefficientsOnFace(System.Int32,System.Double,System.Int32[],System.Boolean,System.Double)"/>
            </para>
            <para>
            This is a post processing step after each time step. The solution at time Np1 is required
            in order to calculate the actual face transport.
            </para>
            </summary>
            <param name="faceIndex">Index of face, between grid point at index i and i+1</param>
            <param name="discharge">Discharge at face</param>
            <param name="includeDispersion">Include dispersion</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateTransportDispersion(System.Int32,DHI.Mike1D.Engine.ModuleAD.ADGridPoint,DHI.Mike1D.Engine.ModuleAD.ADGridPoint,System.Double,System.Int32[],System.Double,System.Double)">
            <summary>
            Calculates the actual dispersion of the face between prev and next AD grid point.
            <para>
            Synchronized with <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetupCoefficientsDispersion(DHI.Mike1D.Engine.ModuleAD.ADGridPoint,DHI.Mike1D.Engine.ModuleAD.ADGridPoint,System.Double,System.Double,System.Double,System.Int32[])"/>.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetStartCEqualCCoefficients">
            <summary>
            Set coefficients for start of reach (low chainage), 
            transferring existing coefficients to start connection
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetEndCEqualCCoefficients">
            <summary>
            Set coefficients for end of reach (high chainage)
            transferring existing coefficients to end connection
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetStartCEqualCPrevCoefficients">
            <summary>
            Set coefficients for start of reach (low chainage)
            matching concentration of prev grid point (boundary, 
            grid point with out volume and no boundary value
            available (outlet))
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetEndCEqualCPrevCoefficients">
            <summary>
            Set coefficients for end of reach (high chainage)
            matching concentration of prev grid point (boundary, 
            grid point with out volume and no boundary value
            available (outlet))
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetStartInOutflowCoefficients(System.Int32[],System.Double[],System.Double)">
            <summary>
            Sets inflow/outflow coefficients between node and first gridpoint
            </summary>
            <param name="activeComponents"></param>
            <param name="boundaryConcentration">Concentration at boundary</param>
            <param name="ddt">Time step inverse</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateStartInOutflowTransport(System.Int32[],System.Double[])">
            <summary>
            Calculate inflow/outflow transport between node and first gridpoint, 
            matching <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetStartInOutflowCoefficients(System.Int32[],System.Double[],System.Double)"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetEndInOutflowCoefficients(System.Int32[],System.Double[],System.Double)">
            <summary>
            Sets inflow/outflow coefficients between node and first gridpoint
            </summary>
            <param name="activeComponents"></param>
            <param name="boundaryConcentration">Concentration at boundary</param>
            <param name="ddt">Time step inverse</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateEndInOutflowTransport(System.Int32[],System.Double[])">
            <summary>
            Calculate inflow/outflow transport between node and first gridpoint, 
            matching <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SetEndInOutflowCoefficients(System.Int32[],System.Double[],System.Double)"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateStartTransportJunctionNode(System.Int32[],System.Double)">
            <summary>
            Set up mass balance equation and find the transport from node to reach
            that matches this. This will be corrected in <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateZeroNetInflowToVolumeFreeNode"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateEndTransportJunctionNode(System.Int32[],System.Double)">
            <summary>
            Set up mass balance equation and find the transport from node to reach
            that matches this. This will be corrected in <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateZeroNetInflowToVolumeFreeNode"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.SolveFirstPart(System.Int32)">
            <summary>
            Perform the double sweep part of solution algorithm
            </summary>
            <param name="nrhs">Number of right hand sides</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.FinalizeTimeStep(System.Int32[],System.Double)">
            <summary>
            Store calculated value for component.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.StartSolverNode">
            <summary>
            Upstream node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.EndSolverNode">
            <summary>
            Downstream node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.ADGridPoints">
            <summary>
            Each entry in this list is an AD grid point. The number of values in
            each array of double is the number of AD components.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.StartNode">
            <summary>
            Upstream node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.EndNode">
            <summary>
            Downstream node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.Offers">
            <summary>
            List of data types that is offered, i.e., that you can get a ValueGetter for.
            </summary>
            <returns>
            List of data types offered
            </returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.Accepts">
            <summary>
            List of data types that is accepted, i.e., that you can get a ValueSetter for.
            </summary>
            <returns>
            List of data types accepted
            </returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.ValueGetter(System.Int32,System.Int32[]@)">
            <summary>
            Get value getter for the specified data quantity, also provides a list of grid point indices
             where the element values belong to.
            </summary>
            <param name="quantityIndex">Requested Quantity</param>
            <param name="indexList">List of indices to gridpoints where each element values belongs to</param>
            <returns>
            An interface providing functionality to get the value
            </returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.ValueSetter(System.Int32,System.Int32[]@)">
            <summary>
            Get value setter for the specified data quantity, also provides a list of grid point indices
             where the element values belong to.
            </summary>
            <param name="quantityIndex">Requested Quantity</param>
            <param name="indexList">List of indices to gridpoints where each element values belongs to</param>
            <returns>
            An interface providing functionality to get the value
            </returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateMassError(System.Int32,System.Int32)">
            <summary>
            Calculate mass error for the specified grid point and component, in mass unit, i.g. [g] 
            for ad component in [g/m3] = [mg/L].
            </summary>
            <param name="gridpointIndex">Index of AD grid point</param>
            <param name="componentIndex">Index of component</param>
            <returns>Mass error</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateMassError(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Calculate mass error for the specified grid point and component, in mass unit, i.g. [g] 
            for ad component in [g/m3] = [mg/L].
            </summary>
            <param name="gridpointIndex">Index of AD grid point</param>
            <param name="componentIndex">Index of component</param>
            <param name="checksum">Bool indicating whether to calculate mass error or mass balance checksum </param>
            <returns>Mass error</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.CalculateMassError(DHI.Mike1D.Engine.ModuleAD.ADGridPoint,System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate mass error for component. By default set <paramref name="hdVolumeError"/> to zero. Setting the <paramref name="hdVolumeError"/>
            to the actual mass error will then calculate a mass balance check sum, which should always return zero (with rounding errors).
            <para>
            Implementation is matching the <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SetupCoefficientsInside(System.Int32[],System.Double,System.Double)"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.MassBalance(DHI.Mike1D.Engine.ModuleAD.ADGridPoint,System.Int32,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Returns parts of the mass balance equation for the component
            By default set <paramref name="hdVolumeError"/> to zero. Setting the <paramref name="hdVolumeError"/>
            to the actual mass error will then calculate <paramref name="massErrorFromHDVolumeError"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.MassError(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            By default set <paramref name="massErrorFromHDVolumeError"/> to zero. Setting the <paramref name="massErrorFromHDVolumeError"/>
            to the actual mass error will then calculate a mass balance check sum, which should always return zero (with rounding errors).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.ReachVectorConcentrationGetter.ElementCount">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADReach.ReachVectorConcentrationGetter.SetValue(System.Int32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADReach.ReachVectorGetter.ElementCount">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.IADNode">
            <summary>
            Interface for an AD node.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADNode.ValuesNp1">
            <summary>
            Component values in node.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADNode.SourceInflowMassPerSecForComponent">
            <summary>
            Component values in node.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADNode.Reaches">
            <summary>
            List of Reach connections, each specyfing a connection between
            the node and a reach.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADNode.HDNode">
            <summary>
            The HD node used as basis for the AD calculations
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADNode.UseDispersion">
            <summary>
            Flag indicating whether dispersion is to be applied between 
            node and reaches, or for open boundary nodes, between
            the node and the external waters.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.IADNode.OutflowConcentration(System.Int32)">
            <summary>
            The outflow concentration, i.e. concentration of component in water flowing out of the point.
            </summary>
            <param name="componentIndex">Index of component</param>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADNode.ValuesN">
            <summary>
            Each entry in this list is an AD grid point. The number of values in
            each array of double is the number of AD components.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADNode.ValuesNp1">
            <summary>
            Each entry in this list is an AD grid point. The number of values in
            each array of double is the number of AD components.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADNode._sourceInflowMassPerSecForComponent">
            <summary> The inflow mass per second ([kg/s] if SI) in this timestep from an external source per component. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADNode.SourceInflowMassPerSecForComponent">
            <summary> The inflow mass per second ([kg/s] if SI) in this timestep from an external source per component. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADNode._componentBoundaryIndex">
            <summary>
            Index into _hdNode.EngineNode.OpenSourceBoundary.Components. Only used for OpenSourceBoundary nodes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADNode.HDNode">
            <summary>
            The HD node used as basis for the AD calculations
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADNode.UseDispersion">
            <summary>
            Flag indicating whether dispersion is to be applied between 
            node and reaches, or for open boundary nodes, between
            the node and the external waters.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.GetComponentIndex(DHI.Mike1D.Generic.IQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.GetComponentIndex(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.MassError(System.Int32,System.Boolean)">
            <summary>
            Calculate mass error for component in mass unit ([kg])
            <para>
            Setting <paramref name="checksum"/>, Mass error checksum is calculated,
            i.e. calculate the mass error and subtract the expected
            mass error due to the HD volume error, i.e. the checksum should always
            be zero.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.OutflowConcentration(System.Int32)">
            <summary>
            Concentration of component for water extracted from the node
            </summary>
            <param name="componentIndex">Index of component</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.MassBalance(System.Int32,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Returns parts of the mass balance equation for the component
            By default set <paramref name="hdVolumeError"/> to zero. Setting the <paramref name="hdVolumeError"/>
            to the actual mass error will then calculate <paramref name="massErrorFromHDVolumeError"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.MassError(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate mass error in mass unit ([kg])
            <para>
            By default set <paramref name="massErrorFromHDVolumeError"/> to zero. Setting the <paramref name="massErrorFromHDVolumeError"/>
            to the actual mass error will then calculate a mass balance check sum, which should always return zero (with rounding errors).
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetBoundaryValue(System.Int32,System.Double)">
            <summary>
            Set concentration for component explicitly.
            </summary>
            <param name="componentIndex">Index of component in AD module</param>
            <param name="boundaryConcentration">Concentration, in unit of AD component.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficientsInternalJunctionNode(System.Int32[],System.Double)">
            <summary>
            Sets up coefficients such that default reach coefficients
            are C = c and a total mass balance equation is set up for 
            the node and all the first reach grid points (apart from
            the decoupled ones).
            <para>
            This is always used for junction nodes, but it can also
            be used for volume nodes.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficentsIncludeReachStart(System.Int32[],DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Double@)">
            <summary>
            Setup coefficients including start of reach in mass balance equation, i.e.
            having a combined mass balance equation for the node and first grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficientsIncludeReachEnd(System.Int32[],DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Double@)">
            <summary>
            Setup coefficients including end of reach in mass balance equation, i.e.
            having a combined mass balance equation for the node and first grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficientsExcludeReachStart(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[],System.Double@)">
            <summary>
            Setup coefficients excluding start of reach from mass balance equation, i.e.
            having node and start grid point setting up each their own mass balance equation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficientsExcludeReachEnd(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[],System.Double@)">
            <summary>
            Setup coefficients excluding end of reach from mass balance equation, i.e.
            having node and start grid point setting up each their own mass balance equation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficientsInternalVolumeNode(System.Int32[],System.Double)">
            <summary>
            Sets up coefficients such that reach coefficients
            can have C != c and a local mass balance equation is set up for 
            the node and all the first reach grid points individually
            <para>
            This should not be used for junction nodes, but is ok
            for volume nodes.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficientsInside(System.Int32[],System.Double,System.Double@)">
            <summary>
            Setup coefficients inside this node, i.e. the parts that does not depend
            on neighbouring reaches. Effectively only for volume nodes.
            <para>
            Contributions to _rhs is added directly, while contribution to
            diagonal element are added to the <paramref name="diagonalElmtValue"/>
            and must be added to the matrix element manually
            </para>
            </summary>
            <param name="activeComponents"></param>
            <param name="ddt">Inverse time step</param>
            <param name="diagonalElmtValue">Amount to add to diagonal element value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficientsBoundaryNode(System.Int32[],System.Double)">
            <summary>
            Sets the boundary concentration on the node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupReachCoefficients(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[],System.Double,System.DateTime)">
            <summary>
            Setup reach end coefficients, the coefficients between 
            node and first grid point (node coefficient part is stoed in ADReachConnection)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateReachTransport(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[],System.Double)">
            <summary>
            Calculate final reach transport
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupReachCoefficientsInternalJunctionNode(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Double)">
            <summary>
            Setup reach coefficients for a junction node, which is setting up C = c
            coefficients, and transferring grid point coefficients to adReachConnection.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateReachTransportInternalJunctionNode(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[],System.Double)">
            <summary>
            Calculate final reach transport for internal junction node, 
            matching <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupCoefficientsInternalJunctionNode(System.Int32[],System.Double)"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupReachCoefficientsDecoupled(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[])">
            <summary>
            Setup reach end coefficients when water level and flow in reach is
            decoupled from that in node, either due to no-flow or free
            out-flow from reach into node
            <para>
            Coefficients are set up between first grid point and node
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateReachTransportDecoupled(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[])">
            <summary>
            Calculate final reach transport when water level and flow in reach is
            decoupled from that in node, 
            matching <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupReachCoefficientsDecoupled(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[])"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupReachCoefficientsInternalVolumeNode(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[])">
            <summary>
            Calculates transport (advection and dispersion) between first grid point and node,
            and sets up coefficients in grid point co1-4 and ADReachConnection (CoD, CoO, CoR)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateReachTransportInternalVolumeNode(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[])">
            <summary>
            Calculate final reach transport for internal volume node. Matching <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupReachCoefficientsInternalVolumeNode(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[])"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateReachTransportStructureReach(DHI.Mike1D.Engine.ModuleAD.ADReachConnection)">
            <summary>
            Calculate final reach transport through structure reaches, matching <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupReachCoefficientsStructureReach(DHI.Mike1D.Engine.ModuleAD.ADReachConnection)"/>
            </summary>
            <param name="adReachConnection"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateReachTransportInflow(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[])">
            <summary>
            Calculate final reach transport for inflow boundaries. Matching <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.SetupReachCoefficientsInflow(DHI.Mike1D.Engine.ModuleAD.ADReachConnection,System.Int32[],System.Double,System.DateTime)"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateZeroNetInflowToVolumeFreeNode">
            <summary>
            Correct transport on connecting reaches so that 
            the amount of mass running into the node is equal to zero.
            
            Only done for internal nodes with volume (i.e. NOT EngineNodeSewer)
            
            Structure reaches (no volume on first grid point) and decoupled reaches
            should not be corrected
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.FinalizeTimeStepForComponent">
            <summary>
            Store calculated value for component i.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.AddSourceContribution(System.Int32,System.Double)">
            <summary>
             Add a mass contribution to the specified component.
            </summary>
            <param name="componentIndex"> </param>
            <param name="massPerSec">Load - mass per second</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.AddSourceContribution(System.Int32,System.Double,System.Double)">
            <summary>
             Add a concentration contribution to the source for the specified component.
            </summary>
            <param name="componentIndex"> </param>
            <param name="concentration">Value to add to source</param>
            <param name="inflow">Discharge </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.Offers">
            <summary>
            List of data types that is offered, i.e., that you can get a ValueGetter for.
            </summary>
            <returns>List of data types offered</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.Accepts">
            <summary>
            List of data types that is accepted, i.e., that you can get a ValueSetter for.
            </summary>
            <returns>List of data types accepted</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.ValueGetter(System.Int32)">
            <summary>
            Get value setter for the specified data quantity
            </summary>
            <param name="quantityIndex">Requested Quantity, index in <see cref="M:DHI.Mike1D.Generic.IQuantityProxy.Offers"/></param>
            <returns>A value getter delegate that can set the value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.ADNode.ValueSetter(System.Int32)">
            <summary>
            Get value setter for the specified data type
            </summary>
            <param name="quantityIndex">Requested Quantity, index in <see cref="M:DHI.Mike1D.Generic.IQuantityProxy.Accepts"/></param>
            <returns>A value setter delegate that can set the value</returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.ADNode.Value">
            <summary>
            Solution value at this node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.IADReachConnection">
            <summary>
            A reach connection is used by the nodes, when listing which
            reaches that is connected to a node. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADReachConnection.ADReach">
            <summary> The reach that is connected to node. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADReachConnection.ADNode">
            <summary> The reach that is connected to node. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.IADReachConnection.HDReachConnection">
            <summary> The HD reach connection. </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.ADReachConnection">
            <summary>
            Structure containing ADReach and at which end the reach is connected
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReachConnection.DischargeNph">
            <summary>
            In ST mode the HD flow field may be modified due to passive branches, hence at the last in/out-flow face in the branch,
            another discharge must be used.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReachConnection.CoD">
            <summary> Diagonal coefficient, matching co2 </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReachConnection.CoO">
            <summary> Off-diagonal coefficient, matching co1 or co3, depending on end </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleAD.ADReachConnection.CoR">
            <summary> Rhs coefficient, matching co4 </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.#ctor">
            <summary>
            Private constructor to support singleton pattern
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.Instance">
            <summary>
            Get the singleton license checker instance
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseChecker">
            <summary>
            Provides access to the DHI license system through LicManCliWrapper2004.dll
            </summary>
            <remarks>
            This class is implemented as internal class in several modules that all require
            license checking functionality. Please update all LicenseChecker classes simultaneously.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseChecker.SelectLicense(System.String)">
            <summary>
            Add a DHI license identifier to the list of license that will be requested.
            </summary>
            <param name="licenseType"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseChecker.RequestLicense(System.Int32)">
            <summary>
            Request licenses. Calls DHI.Generic.MikeZero.License.LicenseWrapper.RequestLicenseWin()
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseChecker.GetMaxNodes">
            <summary>
            Get maximum number of nodes supported by the active license (returns MaxNode1).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseChecker.ConfirmLicense">
            <summary>
            Confirm that all license are still valid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseChecker.ReleaseLicense">
            <summary>
            Release all licenses.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseChecker.GetLicenseErrorDiagnosticsItem(System.Int32)">
            <summary>
            Convert a license error code to an error string
            </summary>
            <param name="rc"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple">
            <summary>
            A wrapper for making procedure calls in the DHI license managment DLL.
            This file is based on DHI.Generic.MIKEZero.LicenseWrapper.cs.
            Compared to that file, the following has been changed:
            1) Thread safety has been removed.
            2) Chaching of license checkout has been removed 
            3) Access to maximum node count information has been added
            
            The changes have been implemented in order to be able to check the same license 
            multiple times (DHI.Generic.MIKEZero.LicenseWrapper.cs has a 1 minute window)
            and point 3 above.
            
            TODO: Revert back to DHI.Generic.MIKEZero.LicenseWrapper.cs and move added functionality from
            here to that file, once it has been tested.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple._ReleaseAllLicensesApp">
            <summary>
            Releases all licenses checked out by the process.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple._ReleaseAllLicensesApp(System.String,System.String)">
            <summary>
            Releases specific licenses checked out by the process.
            </summary>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple._RequestLicenseApp(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.Int32)">
            <summary>
            Requests licenses for the specific module and submodule.
            </summary>
            <param name="rndNum">Random number used for scrambling of data.</param>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
            <param name="versionMajor">Major version number.</param>
            <param name="versionMinor">Minor version number.</param>
            <param name="maxNode1">Unspecified.</param>
            <param name="maxNode2">Unspecified.</param>
            <param name="maxNode3">Unspecified.</param>
            <param name="maxNode4">Unspecified.</param>
            <param name="startTimer">Non-zero, if wait-timer should be started.</param>
            <returns>0, if the function succeeded, otherwise number indicating error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple.ConfirmAllLicensesWin">
            <summary>
            Verifies, whether all requested licenses are still avialable.
            </summary>
            <returns>0, if all the licenses are still avialable, otherwise number indicating
            error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple.ReleaseAllLicensesWin">
            <summary>
            Releases all licenses checked out by the process.
            </summary>        
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple.ReleaseLicenseWin(System.String,System.String)">
            <summary>
            Releases specific licenses checked out by the process.
            </summary>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>   
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple.RequestLicenseWin(System.Int32,System.String,System.String,System.Int64,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int32)">
            <summary>
            Requests licenses for the specific module and submodule.
            </summary>
            <param name="rndNum">Random number used for scrambling of data.</param>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
            <param name="versionMajor">Major version number.</param>
            <param name="versionMinor">Minor version number.</param>
            <param name="maxNode1">Unspecified.</param>
            <param name="maxNode2">Unspecified.</param>
            <param name="maxNode3">Unspecified.</param>
            <param name="maxNode4">Unspecified.</param>
            <param name="startTimer">Non-zero, if wait-timer should be started.</param>
            <returns>0, if the function succeeded, otherwise number indicating error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleAD.LicenseCheckerSingleton.LicenseWrapperSimple.GetMaxNodesByModuleName(System.String,System.Int64@,System.Int64@,System.String@,System.String@)">
            <summary>
             Get maximum number of nodes for a specified license.
            </summary>
            <param name="moduleName"></param>
            <param name="maxNode1"></param>
            <param name="maxNode2"></param>
            <param name="maxNode3"></param>
            <param name="maxNode4"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1">
            <summary>
            An <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1"/> that can contain data for either no or all nodes,
            and either no or all reaches. Engine data is on the form of
            <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataNode`1"/> for nodes and <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataReach`1"/>
            for reaches. These are appropriate for pull-versions of data items, adding
            user implementations of the two interfaces.
            <para>
            The <see cref="T:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataNode`1"/> and <see cref="T:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataReach`1"/>
            can be used as base implementations for pull versions of engine data.
            </para>
            <para>
            This class contains a list of all reaches and nodes 
            in the engine network. In case a reach/node does not have data for a quantity, 
            the IEngineData for that reach/node will be null.
            </para>
            <para>
            A data item can either calculate its values on the fly, when its GetValues is called
            are called, or it can update its values during <see cref="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.UpdateValues"/>, 
            in which case the <see cref="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.UpdateValues"/> must be overwritten.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1._engineNet">
            <summary>
            EngineNet variable
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.IsLazy">
            <summary>
            Flag indicating if data item should apply lazy evaluation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.NodesData">
            <summary>
            Data on nodes. Null if no data on nodes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.ReachesData">
            <summary>
            Data on reaches. Null if no data on reaches
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.#ctor(DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Constructor required for lazy evaluation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.GetNodeData(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get engine data for the specified node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.ContainsDataNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Check whether there is data for the specified node
            </summary>
            <returns>True if data for node exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.GetValue(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get engine data for the specified node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.ValueGetter(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.ValueFractionGetter(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.DCreateNodeData`1">
            <summary>
             Delete which creates data on the reach
            </summary>
            <param name="net"></param>
            <param name="i"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.DCreateReachData`1">
            <summary>
             Delete which creates data on the reach
            </summary>
            <param name="net">EngineNet</param>
            <param name="i">Index of reach to create data for</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.ContainsDataReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Check whether there is data for the specified reach
            </summary>
            <returns>True if data for reach exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.GetDataReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get engine data for the specified reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.CreateReachesData(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.SetEngineDataReach(System.Int32,DHI.Mike1D.Engine.ModuleData.EngineDataReach{`0})">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.SetupDataForNodes(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleData.EngineDataItemAll{`0}.DCreateNodeData{`0})">
            <summary>
            Setup data for all nodes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.SetupDataForNodes(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Setup data for all nodes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.SetupDataForReaches(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleData.EngineDataItemAll{`0}.DCreateReachData{`0})">
            <summary>
            Set up reach data, based on delegate
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.SetupDataForReaches(DHI.Mike1D.Engine.EngineNet,System.Predicate{DHI.Mike1D.Engine.GridPoint})">
            <summary>
            Set up reach data, data on all gridpoints of a given instance type
            </summary>
            <param name="net">Net to take gridpoints from.</param>
            <param name="match">The Predicate delegate that defines the conditions for adding a gridpoint</param>
            <example>
            To get all gridpoints of a specific type, e.g., HGridPOints use:
            <code>
            dataItem.SetupDataForReaches(engineNet, typeof(HGridPoint));
            </code>
            </example>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.SetupDataForReaches(DHI.Mike1D.Engine.EngineNet,System.Type)">
            <summary>
            Set up reach data, data on all gridpoints of a given instance type
            </summary>
            <param name="net">Net to take gridpoints from.</param>
            <param name="tGridPoint">Type of gridpoint that a gridpoint must be an instance of to get in data</param>
            <example>
            To get all gridpoints of a specific type, e.g., HGridPOints use:
            <code>
            dataItem.SetupDataForReaches(engineNet, typeof(HGridPoint));
            </code>
            </example>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.CreateDataItemForAllReaches(DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleData.EngineDataItemAll{`0}.DCreateReachData{`0},System.Boolean)">
            <summary>
            Factory method for creating a dataitem containing data for all reaches. 
            The data for each reach are created by the delegate
            </summary>
            <param name="quantity">Quantity</param>
            <param name="engineNet">EngineNet</param>
            <param name="createReachData">Delegate which creates the reach data</param>
            <param name="defaultHDOnly">Set to true to only create for default HD reaches</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1.CreateGridPointMap(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Create a mapping from grid point index in reach to grid point index in enginedata item.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1" -->
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1._engineNet">
            <summary>
            EngineNet variable
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.IsLazy">
            <summary>
            Flag indicating if data item should apply lazy evaluation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.NodesData">
            <summary>
            Data on nodes. Null if no data on nodes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.ReachesData">
            <summary>
            Data on reaches. Null if no data on reaches
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.HasNodesData">
            <summary>
            Has Data on nodes. Null if on all nodes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.ContainsDataNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Check whether there is data for the specified node
            </summary>
            <returns>True if data for node exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.GetValue(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get engine data for the specified node.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.DCreateNodeData">
            <summary>
             Delete which creates data on the reach
            </summary>
            <param name="net"></param>
            <param name="i"></param>
             
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.DCreateReachData`1">
            <summary>
             Delete which creates data on the reach
            </summary>
            <param name="net">EngineNet</param>
            <param name="i">Index of reach to create data for</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.ContainsDataReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Check whether there is data for the specified reach
            </summary>
            <returns>True if data for reach exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.GetDataReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get engine data for the specified reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.CreateReachesData(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.SetEngineDataReach(System.Int32,DHI.Mike1D.Engine.ModuleData.EngineDataReach{`0})">
            <inheritdoc/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.SetupDataForNodes(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray{`0}.DCreateNodeData)" -->
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.SetupDataForNodes(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Setup data for all nodes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.SetupDataForReaches(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray{`0}.DCreateReachData{`0})">
            <summary>
            Set up reach data, based on delegate
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.SetupDataForReaches(DHI.Mike1D.Engine.EngineNet,System.Predicate{DHI.Mike1D.Engine.GridPoint})">
            <summary>
            Set up reach data, data on all gridpoints of a given instance type
            </summary>
            <param name="net">Net to take gridpoints from.</param>
            <param name="match">The Predicate delegate that defines the conditions for adding a gridpoint</param>
            <example>
            To get all gridpoints of a specific type, e.g., HGridPOints use:
            <code>
            dataItem.SetupDataForReaches(engineNet, typeof(HGridPoint));
            </code>
            </example>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllArray`1.SetupDataForReaches(DHI.Mike1D.Engine.EngineNet,System.Type)">
            <summary>
            Set up reach data, data on all gridpoints of a given instance type
            </summary>
            <param name="net">Net to take gridpoints from.</param>
            <param name="tGridPoint">Type of gridpoint that a gridpoint must be an instance of to get in data</param>
            <example>
            To get all gridpoints of a specific type, e.g., HGridPOints use:
            <code>
            dataItem.SetupDataForReaches(engineNet, typeof(HGridPoint));
            </code>
            </example>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataNode`1">
            <summary>
            Abstract class for supporting Pull version of calculating node data.
            Data is calculated when GetValues are called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataNode`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataNode`1.Prepare">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataReach`1">
            <summary>
            Abstract class for supporting Pull version of calculating reach data.
            Data is calculated when GetValues are called.
            </summary>
            <remarks>
            To build the index list, use the engineReach, since the hdReach
            does not have gridpoints before prepare is called, and the indexlist 
            is needed before prepare (otherwise ResultData will fail when setting up result files).
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataReach`1.GetValue(System.Int32)">
            <summary>
            Get the current values.
            </summary>
            <remarks>
            When implementing new code, be sure to return a copy of data, such that 
            engine data is not made available for editing with this call.
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataReach`1._indexList">
            <summary>
            List of indexes into points in a reach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataReach`1.ElementCount">
            <summary>
            Number of element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataReach`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataReach`1.Prepare">
            <summary>
            Prepare for new simulation. For pull versions, this is the empty function.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataReach`1.IndexList">
            <summary>
            Indices of gridpoints that data belongs to
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataGeneric">
            <summary>
            Abstract class for storing generic engine data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataGeneric.GetValue(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataGeneric.ElementCount">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataGeneric.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataGeneric.Prepare">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.AbstractEngineDataGeneric.ElementSet">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.DataModule">
            <summary>
            <para>
            The DataModule contains a set of IEngineDataItem with each their <see cref="T:DHI.Mike1D.Generic.IQuantity"/>.
            </para>
            <para>
            It implements the <see cref="T:DHI.Mike1D.Engine.IModule"/> interface, however, it has no timestepping functionality.
            </para>
            </summary>
            TODO: Make generic in AddDataItem
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.DataModule.Id">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.DataModule.Order">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.DataModule.WaterVolumeInNetworkAtStart">
            <summary>
            Get and set the water volume at the start of the simulations
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.Inititalize(DHI.Mike1D.Generic.StopwatchCollection)">
            <summary>
            Initialize module
            </summary>
            <param name="timings"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.AddDataItem(DHI.Mike1D.Engine.ModuleData.IEngineDataItem{System.Double})">
            <summary>
            Add a dataset to the datamodule
            </summary>
            <param name="dataItem"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.RemoveDataItem(DHI.Mike1D.Engine.ModuleData.IEngineDataItem{System.Double})">
            <summary>
            Remove a dataset from the datamodule
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.AddDataItem(DHI.Mike1D.Engine.ModuleData.IEngineDataItem{System.Int32})">
            <summary>
            Add a dataset to the datamodule
            </summary>
            <param name="dataItem"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.RemoveDataItem(DHI.Mike1D.Engine.ModuleData.IEngineDataItem{System.Int32})">
            <summary>
            Remove a dataset from the datamodule
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.AddDataItem(DHI.Mike1D.Engine.ModuleData.IEngineDataItem{DHI.Mike1D.Engine.AddOns.MinMaxValueContainer})">
            <summary>
            Add a dataset to the datamodule
            </summary>
            <param name="dataItem"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.RemoveDataItem(DHI.Mike1D.Engine.ModuleData.IEngineDataItem{DHI.Mike1D.Engine.AddOns.MinMaxValueContainer})">
            <summary>
            Remove a dataset from the datamodule
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.AddDataItem(DHI.Mike1D.Engine.ModuleData.IEngineDataItem{System.TimeSpan})">
            <summary>
            Add a dataset to the datamodule
            </summary>
            <param name="dataItem"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.RemoveDataItem(DHI.Mike1D.Engine.ModuleData.IEngineDataItem{System.TimeSpan})">
            <summary>
            Remove a dataset from the datamodule
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetDataItem(DHI.Mike1D.Generic.Quantity)">
            <summary>
            Get a dataset from the datamodule
            </summary>
            <param name="quantity"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetDataItemTimeSpan(DHI.Mike1D.Generic.Quantity)">
            <summary>
            Get a dataset from the datamodule
            </summary>
            <param name="quantity"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetDataItemInt(DHI.Mike1D.Generic.Quantity)">
            <summary>
            Get a dataset from the datamodule
            </summary>
            <param name="quantity"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetDataItemMinMax(DHI.Mike1D.Generic.Quantity)">
            <summary>
            Get a dataset from the datamodule
            </summary>
            <param name="quantity"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Prepare module for first time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.PrepareForTimeStep(System.Int32)">
            <summary>
             Prepare module for next time step (set state(n+1) = state(n)).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.PerformTimestep">
            <summary>
             Perform timestep and return true if solution is accepted. 
             Can be called several times for different values of Dt.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.FinalizeTimestep">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.PreferredTimeStep(System.Boolean,System.TimeSpan)">
            <summary>
             Increase time step after PerformTimestep() returned true. If possible, 
             the time step is increased before next PerformTimestep().
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.WriteState(DHI.Mike1D.ModelState.ModelStateWriter)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.Finish">
            <summary>
             Release any license and clean up
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetProxy(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a proxy for the node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a proxy for the gridpoint in the reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetProxy(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, covering a number of gridpoints
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetProxyReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, generic data (not gridpoint associated)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetProxy">
            <summary>
            Get a proxy for generic/global data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a source point for the gridpoint in the reach.
            
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="gridPointIndex">Index to gridpoint to get source point for</param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Type)">
            <summary>
            Get a source point covering all gridpoints in the reach of the specified type
            
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="TGridPoint">Type of gridpoint.</param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.DataModule.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Type,DHI.Mike1D.Generic.ILocationSpan)">
            <summary>
            Get a source point covering all gridpoints in the span of the specified type
            
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="TGridPoint">Type of gridpoint.</param>
            <param name="reachPartSpan"></param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.DataModule.NodeProxy">
            <summary>
            A helper class that implements the <see cref="T:DHI.Mike1D.Generic.IDoubleProxy"/> functionality for a node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.DataModule.GridPointProxy">
            <summary>
            A helper class that implements the <see cref="T:DHI.Mike1D.Generic.IDoubleProxy"/> functionality for a gridpoint
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.DataModule.ReachProxy">
            <summary>
            A helper class that implements the <see cref="T:DHI.Mike1D.Generic.IDoubleReachProxy"/> functionality for a reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.DataModule.GlobalProxy">
            <summary>
            A helper class that implements the <see cref="T:DHI.Mike1D.Generic.IDoubleProxy"/> functionality for a node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataNode`1">
            <summary>
            Base implementation of IEngineData, storing data in <see cref="P:DHI.Mike1D.Engine.ModuleData.EngineDataNode`1.Value"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineDataNode`1.Value">
            <summary>
            element values
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataNode`1.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataNode`1.GetValue">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineData`1">
            <summary>
            Base implementation of IEngineData, storing data in the <see cref="P:DHI.Mike1D.Engine.ModuleData.EngineData`1.Values"/> array
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineData`1.ElementCount">
            <summary>
            Number of element values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineData`1.Values">
            <summary>
            Values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineData`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineData`1.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineData`1.GetValue(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataGeneric`1">
            <summary>
            Base implementation of <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataGeneric`1"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineDataGeneric`1.ElementSet">
            <summary>
            ElementSet describing geometry of each value.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataReach`1">
            <summary>
            Base implementation of <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataReach`1"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineDataReach`1.IndexList">
            <summary>
            Indices of gridpoints that data belongs to
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1">
            <summary>
            An <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1"/> bas class that contains generic data and base functionality.
            <para>
            A data item can either calculate its values on the fly, when its GetValues is called
            are called, or it can update its values during <see cref="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.UpdateValues"/>, 
            in which case the <see cref="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.UpdateValues"/> must be overwritten.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.#ctor(DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Construct the EngineDataItem with the given quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.ReachGenericData">
            <summary>
            Generic data on reaches
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.GenericData">
            <summary>
            Generic data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.Quantity">
            <summary>
            Quantity of the data in this <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.UpdateValues">
            <summary>
            Update values of all pull items
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.ContainsDataReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Check whether there is generic data for the specified reach
            </summary>
            <returns>True if generic data for reach exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.GetDataReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get generic engine data for the specified reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.ContainsDataGeneric">
            <summary>
            Check whether there is data for the index reference
            </summary>
            <returns>True if data for index exists</returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.DataGeneric">
            <summary>
            Get engine data for the specified index reference.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.CreateReachesData(System.Int32)">
            <summary>
            Create ReachesData, usually array of all reaches
            </summary>
            <param name="count">Number of reaches in model</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.SetEngineDataReach(System.Int32,DHI.Mike1D.Engine.ModuleData.EngineDataReach{`0})">
            <summary>
            Set reach data to reaches array
            </summary>
            <param name="index">Index to set values to</param>
            <param name="reachData">Data to set</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllBase`1.SetupDataForReaches(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Set up reach data, data on all gridpoints
            </summary>
            <param name="net"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllUpdate`1">
            <summary>
            A version of the <see cref="T:DHI.Mike1D.Engine.ModuleData.EngineDataItemAll`1"/> based
            on objects that does the actual update.
            <para>
            This can be utilized for reach/node engine data that can update them selves, 
            by having the engine data class implement the <see cref="T:DHI.Mike1D.Engine.ModuleData.IUpdatable"/>
            and register it using the <see cref="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllUpdate`1.RegisterUpdater(DHI.Mike1D.Engine.ModuleData.IUpdatable)"/> method.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllUpdate`1.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Construct the EngineDataItem with the given quantity
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllUpdate`1.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllUpdate`1.UpdateValues">
            <summary>
            Update values of all pull items
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.EngineDataItemAllUpdate`1.RegisterUpdater(DHI.Mike1D.Engine.ModuleData.IUpdatable)">
            <summary>
            Register an item as a pull data item
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.IEngineData`1">
            <summary>
            Interface for a set of engine data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.IEngineData`1.Item(System.Int32)">
            <summary>
            Element value by index. It may not support setting.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineData`1.Prepare">
            <summary>
            Prepare for new simulation
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.IUpdatable">
            <summary>
            Interface for an updatable object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IUpdatable.Prepare">
            <summary>
            Prepare for new simulation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IUpdatable.UpdateValues">
            <summary>
            Update data values. For pull versions this is the empty function.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.IEngineDataGeneric`1">
            <summary>
            Interface for a set of engine data that matches a given <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.IEngineDataGeneric`1.ElementSet">
            <summary>
            ElementSet describing geometry of each value.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.IEngineDataReach`1">
            <summary>
            Interface for a set of engine data that belongs to a set of gridpoints in a reach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.IEngineDataReach`1.IndexList">
            <summary>
            Indices of gridpoints that data belongs to
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.IEngineDataNode`1">
            <summary>
            Interface for engine data on a node.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.IEngineDataNode`1.Value">
            <summary>
            Get value of specified element.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataNode`1.Prepare">
            <summary>
            Prepare for new simulation
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1">
            <summary>
            <para>
            An <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1"/> contains data for one quantity. 
            </para>
            <para>
            Data can be present on a node, on a set of gridpoints of a reach, as general data 
            on a reach, and as general data.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.Quantity">
            <summary>
            Quantity of the data in this <see cref="T:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.Prepare">
            <summary>
            Prepare for new simulation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.UpdateValues">
            <summary>
            Update values
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.ContainsDataNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Check whether there is data for the specified node
            </summary>
            <returns>True if data for node exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.ContainsDataReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Check whether there is data for the specified reach
            </summary>
            <returns>True if data for reach exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.ContainsDataReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Check whether there is generic data for the specified reach
            </summary>
            <returns>True if generic data for reach exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.ContainsDataGeneric">
            <summary>
            Check whether there is data for the index reference
            </summary>
            <returns>True if data for index exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.GetValue(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get engine data for the specified node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.ValueGetter(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Valuegetter for engine data for the specified node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.ValueFractionGetter(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Valuegetter for engine data for the specified node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.GetDataReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get engine data for the specified reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.GetDataReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get generic engine data for the specified reach.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleData.IEngineDataItem`1.DataGeneric">
            <summary>
            Get engine data for the specified index reference.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger">
            <summary>
            Interface for debugging ECO Lab while it is running
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger.HandleGeneral(System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            Handle a general set of messages, created during prepare and finalization of simulation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger.PreInitTimestep(System.Int32,System.DateTime)">
            <summary>
            Pre-init timestep messages, called once before the time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger.PostInitTimestep(System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            Handle post-init-timestep messages, called once for every ECO Lab instance for every time step
            but only if there are messages to report.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger.PreCalculateNode(DHI.Mike1D.Engine.ModuleAD.IADNode)">
            <summary>
            Method called before node is being processed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger.PostCalculateNode(DHI.Mike1D.Engine.ModuleAD.IADNode,System.Double[],System.Collections.Generic.List{System.String})">
            <summary>
            Method called after node has been processed
            <para>
            msgs can be null
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger.PreCalculateGridPoint(DHI.Mike1D.Engine.ModuleAD.IADGridPoint)">
            <summary>
            Method called before grid point is being processed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger.PostCalculateGridPoint(DHI.Mike1D.Engine.ModuleAD.IADGridPoint,System.Double[],System.Collections.Generic.List{System.String})">
            <summary>
            Method called after grid point has been processed
            <para>
            msgs can be null
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebuggerBase">
            <summary>
            Base class for an ECO Lab debugger
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebuggerBase.DebugLevel">
            <summary>
            ECO Lab debug level. Zero is no debug info, and 6 is full debug info.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebuggerBase._currentDebugLevel">
            <summary>
            Current debug level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebuggerBase.ReadDebugLevel">
            <summary>
            Read current debug level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebuggerBase.IsDebugging">
            <summary>
            Returns true if debug info is enabled.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebuggerBase.StartDebugging">
            <summary>
            Start creating debugging output from ECO Lab
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebuggerBase.StopDebugging">
            <summary>
            Stop creating debugging output from ECO Lab
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebuggerBase.SetDebugger(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleEcoLab.IEcoLabDebugger)">
            <summary>
            Set ECO Lab debugger
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger">
            <summary>
            ECO Lab debugger, 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.FilePath">
            <summary> File to write debug messages to </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.Start">
            <summary> Start time of debugging </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.End">
            <summary> End time of debugging </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger._writer">
            <summary> Writer to write debug info to </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger._isInitialized">
            <summary> True if debugger has been initialized </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.StartDebugging">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.Initialize">
            <summary>
            Initialize debugger
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.HandleGeneral(System.Int32,System.Collections.Generic.List{System.String})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.PreInitTimestep(System.Int32,System.DateTime)">
            <summary>
            Start or stop debugging of the current time step, based
            on the <see cref="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.Start"/> and <see cref="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.End"/> times
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.PostInitTimestep(System.Int32,System.Collections.Generic.List{System.String})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.PreCalculateNode(DHI.Mike1D.Engine.ModuleAD.IADNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.PostCalculateNode(DHI.Mike1D.Engine.ModuleAD.IADNode,System.Double[],System.Collections.Generic.List{System.String})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.PreCalculateGridPoint(DHI.Mike1D.Engine.ModuleAD.IADGridPoint)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.PostCalculateGridPoint(DHI.Mike1D.Engine.ModuleAD.IADGridPoint,System.Double[],System.Collections.Generic.List{System.String})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabDebugger.FlushFile">
            <summary>
            Flush to file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger">
            <summary>
            ECO Lab debugger, checking for NaN and infinity numbers
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.ComponentData">
            <summary>
            Component data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.ELData">
            <summary>
            ECO Lab data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.HandleGeneral(System.Int32,System.Collections.Generic.List{System.String})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.PreInitTimestep(System.Int32,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.PostInitTimestep(System.Int32,System.Collections.Generic.List{System.String})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.PreCalculateNode(DHI.Mike1D.Engine.ModuleAD.IADNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.PostCalculateNode(DHI.Mike1D.Engine.ModuleAD.IADNode,System.Double[],System.Collections.Generic.List{System.String})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.PreCalculateGridPoint(DHI.Mike1D.Engine.ModuleAD.IADGridPoint)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabNumberCheckDebugger.PostCalculateGridPoint(DHI.Mike1D.Engine.ModuleAD.IADGridPoint,System.Double[],System.Collections.Generic.List{System.String})">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModule.Id">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModule.Order">
            <summary>
            Order of module. Modules are processed in order. 
            The EcoLab module must run after the AD module. The HD module has order 300.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModule.PreferredTimeStep(System.Boolean,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModule.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModule.WriteState(DHI.Mike1D.ModelState.ModelStateWriter)">
            <inheritdoc/>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._engineELReach">
            <summary>
            As long as number of engine reaches, but only contains ELReaches.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing">
            <summary> 
            A common class for ECOLab constants and forcing
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing.ParameterTypes.ECOLabConstant">
            <summary>
            ECOLab constant, constant in time, may vary in space
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing.ParameterTypes.ECOLabForcing">
            <summary>
            EOCLab forcing, may vary in time and space
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing.ParameterType">
            <summary>
            differentiate between constant/forcing
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing.EcoLabID">
            <summary>
            EOCLab ID
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing.BuiltInID">
            <summary>
            builtin ID value
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing._parameterValue">
            <summary>
            private parameter value object
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing.ParameterValueGetter">
            <summary>
            getter to read a value through the parameter value object,
            when setting a new one, link to prober ECOLab ID
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ELConstantForcing.SourceIndex">
            <summary>
            the oringial index of the constant/forcing in the ecolab module
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._elConstantsForcing">
            <summary>
            A list of all ECOLab constants and forcings
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._globalConstantsForcingCount">
            <summary>
            counting the number of global parameters (constants and forcing)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._localConstantsForcingCount">
            <summary>
            counting the number of local parameters (constants and forcing)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._elGlobalConstantsForcing">
            <summary>
            Array with index to all global constants and forcings, needs to be updated
            once per time step
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._elLocalConstantsForcing">
            <summary>
            Array with index of all local constants and forcing, needs to be updated
            on every location/node
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._startTime">
            <summary> Simulation start time </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._lastUpdateTime">
            <summary> Time of last EcoLab evaluation </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._hdStepsSinceLastUpdate">
            <summary> Number of HD steps since last EcoLab evaluation </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._elStateVarToAdComponent">
            <summary>  For each EL state variable, identifies the AD component index </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.PreferredTimeStep(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.PrepareInitialValues">
            <summary>
            Called during prepare
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.PrepareLocalConstantsForcings(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Setup local constants / spatially varying constants
            <para>
            TODO EL: When new ECOLab memory manager is ready, constants are stored for each element and need 
                     not be stored locally in ElElmt
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.InitaliseConstantsForcings(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            count all global and local constants and forcings and distribute to
            the correct index list; set all global parameter values
            <para>
            Called during Prepare
            </para>
            </summary>
            <param name="diagnostics"></param>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel._msgs">
            <summary>
            Reusing list of messages
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.GetOtherOutputs(DHI.Mike1D.Engine.ModuleEcoLab.ELElement)">
            <summary>
            Gets toher outputs, used in PerformTimestep call
            </summary>
            <param name="elmt"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ElElmtProxy">
            <summary>
            Proxy class for an ElElmt, ELNode or ELGridPoint
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ReachProxy">
            <summary>
            Proxy class for an EL reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ReachVectorGetter">
            <summary>
            Class that can provide additional outputs from an EL reach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabModuleModel.ReachVectorGetter.ElementCount">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELElement">
            <summary>
            Base class for EcoLab computational elements
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELElement.ElementNumber">
            <summary>
            Element number in EcoLab engine. If zero, this is not
            part of the EcoLab simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELElement.Dry">
            <summary>
            flag if the element is dry or not (dry elements need to be re-inialised)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELElement.OtherOutputs">
            <summary>
            Other outputs from EcoLab for this element
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue">
            <summary>
            base class for ECOLab constants and forcing. Both constants and 
            forcing are acually based on the same data structure; 
            the differentiation between constants (== temporal constant) and 
            forcing (temporal and spatial varying) is done to force the ECOLab 
            user to structure the template
            </summary>
            
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.TimeTypes">
            <summary>
            Type of temporal variation of a parameter
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.TimeTypes.ConstantInTime">
            <summary>
            Constant in time
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.TimeTypes.VaryingInTime">
            <summary>
            Time series
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.SpaceTypes">
            <summary>
            Type of temporal variation of a parameter
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.SpaceTypes.SpatialVariationNone">
            <summary>
            Constant in space, 0D
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.SpaceTypes.SpatialVariationHorizontal">
            <summary>
            Varying in 2D, horizontaly
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.SpaceTypes.SpatialVariationHorizontalVertical">
            <summary>
            Varying in 3D, horizontal and verical (not relevant for Mike1D)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.SpatialVariation">
            <summary>
            Spatial variation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue._diagnostics">
            <summary>
            Diagnostic object for messages
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.EcolabID">
            <summary>
            ECOlab ID
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.DefaultValue">
            <summary>
            Assigned default value
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.diagnostics">
            <summary>
            Access the diagnostic object
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.IsGlobalValue">
            <summary>
            nice named constants for gloabl/local values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.IsGlobal">
            <summary>
            Bool indicating if forcing is global and to get value from <see cref="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.GlobalValue"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.Timetype">
            <summary>
            Temporal variation. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.TsFileName">
            <summary>
            Time series file, used if <see cref="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.Timetype"/> is
            <see cref="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.TimeTypes.VaryingInTime"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.TsItemNumber">
            <summary>
            Item number in time series file, used if <see cref="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.Timetype"/> is
            <see cref="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.TimeTypes.VaryingInTime"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue._tsItem">
            <summary>
            private time series item to query (local) varying time series values
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.LinkTimeSeries(DHI.Mike1D.Generic.IFilePath,System.Int32,DHI.Mike1D.Generic.TimeSeries.TsBuffer)">
            <summary>
            Link a time series to a parameter (global but varying in time)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.Values">
            <summary>
            Values of constant.
            <para>
            If <see cref="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.IsGlobal"/> is set, only the
            <see cref="P:DHI.Mike1D.Generic.INetworkData`1.GlobalValue"/> is used.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.GetValue">
            <summary>
            get the current value, base class uses default value  
            </summary>
            <returns>current value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.GlobalValue">
            <summary>
            Get the global value, base class uses simply GetValue <see cref="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.GetValue"/>
            Throws and exception if not a global parameter
            </summary>
            <returns>Global value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.NodeValue(DHI.Mike1D.Engine.ModuleEcoLab.ELNode)">
            <summary>
            Local node value. Throws a warning if <see cref="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.IsGlobal"/> is set.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.GridPointValue(DHI.Mike1D.Engine.ModuleEcoLab.ELReach,DHI.Mike1D.Engine.ModuleEcoLab.ELGridPoint)">
            <summary>
            Local grid point value. Throws a warning if <see cref="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.IsGlobal"/> is set.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.GlobalValue(System.DateTime)">
            <summary>
            Global value, when <see cref="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.IsGlobal"/> is set.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.NodeValue(DHI.Mike1D.Engine.ModuleEcoLab.ELNode,System.DateTime)">
            <summary>
            Local node value. Throws a warning if <see cref="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.IsGlobal"/> is set.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.GridPointValue(DHI.Mike1D.Engine.ModuleEcoLab.ELReach,DHI.Mike1D.Engine.ModuleEcoLab.ELGridPoint,System.DateTime)">
            <summary>
            Local grid point value. Throws a warning if <see cref="P:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.IsGlobal"/> is set.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELParameterValue.#ctor(System.Double,System.Boolean,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            basis consturctor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter">
            <summary>
            class for built-in parameter, i.e. some data provided by the HD engine
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID">
            <summary>
            built-in IDs corresponding to the ECOlab ProcessMatrixDB settings; 
            NEVER add/change without proper entry from ECOLab
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.UserDefined">
            <summary>
            dummy undefined value
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.Latitude">
            <summary>
            gloabl/center latitude
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.Longitude">
            <summary>
            global/center longitude
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.BedLevel">
            <summary>
            local bed level
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WaterLayerHeight">
            <summary>
            water layer heigt, in 1D equal to water depth
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.Salinity">
            <summary>
            salinity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.Temperature">
            <summary>
            temperature
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WindVelocity">
            <summary>
            wind velocity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WindDirection">
            <summary>
            wind direction
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WaterSurfaceLevel">
            <summary>
            water surface level
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WaterDepth">
            <summary>
            local, total water depth
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.HorisontalCurrentSpeed">
            <summary>
            horizontal current speed
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.HorisontalCurrentDirection">
            <summary>
            horizontal current direction, important for ABM
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.VerticalCurrentSpeed">
            <summary>
            vertical current speed, in 1D==0
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WaterSurfaceSlopeInFlowDirection">
            <summary>
            surface slope
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.BedAreaOfGridcell">
            <summary>
            bed area of local element
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.FloodedAreaOfGridcell">
            <summary>
            flooded area of local element
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.SurfaceAreaOfGridcell">
            <summary>
            surface area of local element
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.VolumeOfGridcell">
            <summary>
            volume of current element
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.ADdt">
            <summary>
            deprecated time step ID, AD time in sec (was fract. day in
            Mike11!), AD_DT_SEC should be used
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WQdt">
            <summary>
            deprecated time step ID, WQ/ECOLab time step in sec (was fract.
            of day in Mike11!); WQ_DT_SEC should be used
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.HorisontalGridcellFlux">
            <summary>
            horizontal grid cell flux [m3/s]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.VerticalGridcellFlux">
            <summary>
            vertical grid cell flux [m3/s]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WaterDensity">
            <summary>
            water density, 1 ton/m3
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MikeSHEBaseFlow">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_DRAIN_FLOW">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_OVERLAND_FLOW">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_BASE_CONC_1">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_DRAIN_CONC_1">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_OVERLAND_CONC_1">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_BASE_CONC_2">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_DRAIN_CONC_2">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_OVERLAND_CONC_2">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_BASE_CONC_3">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_DRAIN_CONC_3">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_OVERLAND_CONC_3">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_BASE_CONC_4">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_DRAIN_CONC_4">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_OVERLAND_CONC_4">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_BASE_CONC_5">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_DRAIN_CONC_5">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MIKE_SHE_OVERLAND_CONC_5">
            <summary>
            used for Mike SHE coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.Gridspacing">
            <summary>
            local grid spacing (mike21/mike3)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.Mike11NodeType">
            <summary>
            Mike11 node type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.ChezyNo">
            <summary>
            Chezy number
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WaterSurfaceWidth">
            <summary>
            surface with
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.HeatFluxWaterAtmosphere">
            <summary>
            heat flux from heat balance module
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.M11ICE_LOCAL_VELO_AT_BORDER_ICE_WIDTH">
            <summary>
            special Mike11-ICE module/ECOLab template
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.M11ICE_BORDER_ICE_WIDTH_VLIM_PROGR">
            <summary>
            special Mike11-ICE module/ECOLab template
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.M11ICE_BORDER_ICE_WIDTH_VLIM_RETREAT">
            <summary>
            special Mike11-ICE module/ECOLab template
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.M11ICE_WATER_LEVEL_AT_FREEZEUP">
            <summary>
            special Mike11-ICE module/ECOLab template
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.M11ICE_KAPPA_DYNAMIC_PROGRESSION">
            <summary>
            special Mike11-ICE module/ECOLab template
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.M11ICE_LEADING_EDGE_AT_NEXT_SECTION">
            <summary>
            special Mike11-ICE module/ECOLab template
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.HorisontalEddyViscosity">
            <summary>
            horizontal eddy viscosity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MikeSHESuppliedConstant">
            <summary>
            new MikeSHE/ECOLab coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.MikeSHESuppliedForcing">
            <summary>
            new MikeSHE/ECOLab coupling
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.VerticalDispersion">
            <summary>
            vertical dispersion coefficient
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.HorizontalDispersion">
            <summary>
            horizontal dispersion coefficient
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.TurbulentKineticEnergy">
            <summary>
            TKE, MikeFM
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.DissipationTurbulentKineticEnergy">
            <summary>
            MikeFM
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.BedShearStress">
            <summary>
            locla bed shear stress
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.ResidenceTime">
            <summary>
            MikeHydro/Basin specific
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WeirHeight">
            <summary>
            MikeHydro/Basin specific
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.ConvergenceAngle">
            <summary>
            convergence angle to true north, MikeFM
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.ADdtSec">
            <summary>
            AD time step in sec
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.WQdtSec">
            <summary>
            WQ/ECOLab time step in sec
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.CatchmentRunoff">
            <summary>
            MikeHydro/Basin specific
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.CatchmentArea">
            <summary>
            MikeHydro/Basin specific
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.DtPerDay">
            <summary>
            time steps per day, 86400[s/d]/WQ_DT[s]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.Latitude2D">
            <summary>
            local/element latidute
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.Longitude2D">
            <summary>
            local/element longitude
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.FlowArea">
            <summary>
            Flow Area
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID.RelativeDepth">
            <summary>
            RelativeDepth
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.ID">
            <summary>
            Assigned built-in ID
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.#ctor(DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.BuiltInID,System.Double,System.Boolean,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            default constructor specifying builtin-ID, default value, diagnostic and global value flag
            </summary>
            <param name="builtinID">Built-in ID read from the ECOLab template</param>
            <param name="defaultValue">Default value read from the ECOLab template.</param>
            <param name="diagnostics">Default diagnostincs object for warnings.</param>
            <param name="isGlobal">Flag indicating if the forcing is global or local.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInParameter.#ctor">
            <summary>
            empty constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory">
            <summary>
            Factory class for creating engine forcing classes, i.e. 
            providing forcings to ECO Lab from the HD/AD/? engine.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.Create(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.EcoLabDataAccess.IEcoLabConstantForcingBase,System.Boolean@,System.Boolean@,System.Double,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Create engine forcing class matching the type integer.
            Refer to ECO Lab documentation for a full list of type values
            </summary>
            <param name="engineNet">EngineNet</param>
            <param name="builtinID_int">Type of forcing</param>
            <param name="isGlobal">Output bool indicating if the forcing is global or local.</param>
            <param name="defaultValue">Default value read from the ECOLab template.</param>
            <param name="diagnostics">Default diagnostincs object for warnings.</param>
            <returns>Forcing class</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.ConstantValue">
            <summary>
            Class for temporal and spatial constant (global) values
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.SimulationTime">
            <summary>
            class for engine/simulation time value
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.TimestepsPerDay">
            <summary>
            providing the number of time steps per day
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.LonLatCenter">
            <summary>
            providing the center/charateristic longitude/latidute of the model domain
            To get local longitude/latitude use <see cref="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.LonLat"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.BedLevel">
            <summary>
            provide the local bed level
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.GridSpacing">
            <summary>
            provide local grid spacing
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.M11NodeType">
            <summary>
            provide M11 node type 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.LonLat">
            <summary>
            local longidute/latitude, <see cref="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.LonLatCenter"/> for global/center value
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.WaterLevel">
            <summary>
            provide local water level
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.WaterDepth">
            <summary>
            provide local water depth
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.RelativeWaterDepth">
            <summary>
            provide local relative water depth for closed network parts (nodes with cover and grid points with closed cross sections)
            If open, -1 is returned.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.HorizontalCurrentSpeed">
            <summary>
            provide local current speed
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.WaterSurfaceWidth">
            <summary>
            provide local surface width
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.FlowArea">
            <summary>
            provide local flow area
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.WaterSurfaceSlopeInFlowDirection">
            <summary>
            provide local slope (to the next/previous grid point)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.BedArea">
            <summary>
            provide bed area of grid element
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.Volume">
            <summary>
            provide local volume of grid/node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.DispersionFactor">
            <summary>
            provide dispersion factor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.HorizontalGridCellFlux">
            <summary>
            provide gridd flux
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.ELBedShearStress">
            <summary>
            provide bed shear stress 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.ELBuiltInValueFactory.ADValue">
            <summary>
            provide the value of a certain AD variable, used to couple e.g. temperature and salinity
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.#ctor">
            <summary>
            Private constructor to support singleton pattern
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.Instance">
            <summary>
            Get the singleton license checker instance
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseChecker">
            <summary>
            Provides access to the DHI license system through LicManCliWrapper2004.dll
            </summary>
            <remarks>
            This class is implemented as internal class in several modules that all require
            license checking functionality. Please update all LicenseChecker classes simultaneously.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseChecker.SelectLicense(System.String)">
            <summary>
            Add a DHI license identifier to the list of license that will be requested.
            </summary>
            <param name="licenseType"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseChecker.RequestLicense(System.Int32)">
            <summary>
            Request licenses. Calls DHI.Generic.MikeZero.License.LicenseWrapper.RequestLicenseWin()
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseChecker.GetMaxNodes">
            <summary>
            Get maximum number of nodes supported by the active license (returns MaxNode1).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseChecker.ConfirmLicense">
            <summary>
            Confirm that all license are still valid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseChecker.ReleaseLicense">
            <summary>
            Release all licenses.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseChecker.GetLicenseErrorDiagnosticsItem(System.Int32)">
            <summary>
            Convert a license error code to an error string
            </summary>
            <param name="rc"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple">
            <summary>
            A wrapper for making procedure calls in the DHI license managment DLL.
            This file is based on DHI.Generic.MIKEZero.LicenseWrapper.cs.
            Compared to that file, the following has been changed:
            1) Thread safety has been removed.
            2) Chaching of license checkout has been removed 
            3) Access to maximum node count information has been added
            
            The changes have been implemented in order to be able to check the same license 
            multiple times (DHI.Generic.MIKEZero.LicenseWrapper.cs has a 1 minute window)
            and point 3 above.
            
            TODO: Revert back to DHI.Generic.MIKEZero.LicenseWrapper.cs and move added functionality from
            here to that file, once it has been tested.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple._ReleaseAllLicensesApp">
            <summary>
            Releases all licenses checked out by the process.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple._ReleaseAllLicensesApp(System.String,System.String)">
            <summary>
            Releases specific licenses checked out by the process.
            </summary>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple._RequestLicenseApp(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.Int32)">
            <summary>
            Requests licenses for the specific module and submodule.
            </summary>
            <param name="rndNum">Random number used for scrambling of data.</param>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
            <param name="versionMajor">Major version number.</param>
            <param name="versionMinor">Minor version number.</param>
            <param name="maxNode1">Unspecified.</param>
            <param name="maxNode2">Unspecified.</param>
            <param name="maxNode3">Unspecified.</param>
            <param name="maxNode4">Unspecified.</param>
            <param name="startTimer">Non-zero, if wait-timer should be started.</param>
            <returns>0, if the function succeeded, otherwise number indicating error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple.ConfirmAllLicensesWin">
            <summary>
            Verifies, whether all requested licenses are still avialable.
            </summary>
            <returns>0, if all the licenses are still avialable, otherwise number indicating
            error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple.ReleaseAllLicensesWin">
            <summary>
            Releases all licenses checked out by the process.
            </summary>        
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple.ReleaseLicenseWin(System.String,System.String)">
            <summary>
            Releases specific licenses checked out by the process.
            </summary>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>   
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple.RequestLicenseWin(System.Int32,System.String,System.String,System.Int64,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int32)">
            <summary>
            Requests licenses for the specific module and submodule.
            </summary>
            <param name="rndNum">Random number used for scrambling of data.</param>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
            <param name="versionMajor">Major version number.</param>
            <param name="versionMinor">Minor version number.</param>
            <param name="maxNode1">Unspecified.</param>
            <param name="maxNode2">Unspecified.</param>
            <param name="maxNode3">Unspecified.</param>
            <param name="maxNode4">Unspecified.</param>
            <param name="startTimer">Non-zero, if wait-timer should be started.</param>
            <returns>0, if the function succeeded, otherwise number indicating error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.LicenseCheckerSingleton.LicenseWrapperSimple.GetMaxNodesByModuleName(System.String,System.Int64@,System.Int64@,System.String@,System.String@)">
            <summary>
             Get maximum number of nodes for a specified license.
            </summary>
            <param name="moduleName"></param>
            <param name="maxNode1"></param>
            <param name="maxNode2"></param>
            <param name="maxNode3"></param>
            <param name="maxNode4"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ProcessMatrixServer.Initialize(System.Int32)">
            <summary>
            Initialize ECOLab with <paramref name="noOfElements"/> elements, all having a vector size of 1
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ProcessMatrixServer.Initialize(System.Int32[])">
            <summary>
            Initialize ECOLab with elements having vector sizes matching the <paramref name="vectorSizes"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ProcessMatrixServer.SetWqDeltaT(System.Double)">
            <summary>
            </summary>
            <param name="dt">Fraction of a day</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ProcessMatrixServer.SetWqDeltaT(System.TimeSpan)">
            <summary>
            </summary>
            <param name="dt">Fraction of a day</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ProcessMatrixServer.SetConstant(System.Int32,System.Double)">
            <summary>
            Global constant
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleEcoLab.ProcessMatrixServer.SetConstant(System.Int32,System.Int32,System.Double)">
            <summary>
            Spatially varying constant
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.ProcessMatrixServer.Epoc">
            <summary>
            Epoc of ECO Lab
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabMessageSeverity">
            <summary>
            Severity of an ECO Lab message
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabMessageSeverity.Unknown">
            <summary> Unknown </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabMessageSeverity.Notice">
            <summary> Notice </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabMessageSeverity.Warning">
            <summary> Warning </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabMessageSeverity.Critical">
            <summary> Critical </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleEcoLab.EcoLabMessageSeverity.Fatal">
            <summary> Fatal </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDCouplingUtil">
            <summary>
            Utility classes for HD Couplings - only used by old coupling routines
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDCouplingUtil.StandardLinkHelper">
            <summary>
            Utility class for a standard link
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDCouplingUtil.StandardLinkHelper.#ctor(DHI.Mike1D.Engine.ModuleHD.IHDReachConnection,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDCouplingUtil.StandardLinkHelper.GetQ">
            <summary>
            Get Q (out of river)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDCouplingUtil.StandardLinkHelper.GetdQdt">
            <summary>
            Get dQdt (out of river), as calculated by the active HD scheme
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDDomain">
            <summary>
            A HD Domain is a subset of a network, used when domain decomposing the solution
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDDomain.Domain">
            <summary>
            Domain identifyer
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDDomain.HDReaches">
            <summary>
            List of all HD reaches in network. 
            <para>
            Need not include all Engine reaches, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetHDReach(DHI.Mike1D.Engine.EngineReach)"/> 
            to check if a given engine reach also has a corresponding HD reach.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDDomain.Reaches">
            <summary>
            List of all HD reaches in network. 
            <para>
            Need not include all Engine reaches, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetReach(DHI.Mike1D.Engine.EngineReach)"/> 
            to check if a given engine reach also has a corresponding HD reach.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDDomain.HDNodes">
            <summary>
            List of all HD nodes in network. 
            <para>
            Need not include all Engine nodes, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetHDNode(DHI.Mike1D.Engine.EngineNode)"/> 
            to check if a given engine node also has a corresponding HD node.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDDomain.Nodes">
            <summary>
            List of all HD nodes in network. 
            <para>
            Need not include all Engine nodes, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetHDNode(DHI.Mike1D.Engine.EngineNode)"/> 
            to check if a given engine node also has a corresponding HD node.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDDomain.IterationNumber">
            <summary>
            Iteration number. Access to the iteration number is needed in the control module (via a sensor)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDomain.#ctor(System.Int32,DHI.Mike1D.Engine.ModuleHD.HDModule)">
            <summary>
            Constructor creating a new HDModule and initializing it with the given EngineNet and
            HD parameters.
            </summary>
            <param name="domain"></param>
            <param name="hdModule"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDomain.PerformTimestep">
            <summary>
             Perform one time step. Return true if time step succeeded, or false if it failed.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDomain.PrepareForIteration(System.Int32)">
            <summary>
            Update state values and derived state values for time nph
            </summary>
            <param name="iterationNumber"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDomain.PrepareForIterationDependentValues(System.Int32)">
            <summary>
            Update derived state values for time Nph - depends on Nph state values.
            </summary>
            <param name="iterationNumber"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDomain.ApplyInternalCorrections">
            <summary>
            Apply corrections to keep solution internally consistent, eg. raise waterlevels above a given minimum.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit">
            <summary>
            A point where a source contribution can be added, containing an implicit term
            in the form of a derivative with respect to the state variable.
            <para>
            Used internally by <see cref="T:DHI.Mike1D.Engine.ModuleHD.HDImplicitSource"/> helper class
            </para>
            <para>
            Current usage is adding a source that depends on the water level, and including
            a water level derivative to take the change of water level into account, i.e. 
            <code>
            Q_s = Q_s^n + dQdh * (H^{n+1} - H^n)
            </code>
            </para>
            <para>
            The actual source added in <see cref="M:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit.AddSourceImplicit(System.Double,System.Double)"/>
            must be evaluated during finalization of time step, 
            using the <see cref="M:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit.EvaluateSourceImplicit(System.Double,System.Double)"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit.AddSourceImplicit(System.Double,System.Double)">
            <summary>
            Add a contribution to the source. Includes a 
            a water level derivative, to take changes of water
            level into account. Typically used by structure type sources
            <para>
            After the time step has completed (before FinalizeTimeStep), 
            the <see cref="M:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit.EvaluateSourceImplicit(System.Double,System.Double)"/>
            must be called with the same parameters. This is required to get 
            statistics on actual inflow and outflow correct.
            </para>
            </summary>
            <param name="val">Source value</param>
            <param name="dvaldh">Source value derivative with respect to water level</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit.EvaluateSourceImplicit(System.Double,System.Double)">
            <summary>
            To be called at finalize time step, to get the actual
            amount of source added correct. It will update
            the Sources Inflow/Outflow depending on the sign. 
            It must match exactly a previous call to 
            <see cref="M:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit.AddSourceImplicit(System.Double,System.Double)"/> 
            and must only be called once.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit.ValueN">
            <summary>
            Value of water level at time N
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit.ValueNp1">
            <summary>
            Value of water level at time N+1
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDImplicitSource">
            <summary>
            Helper class, wrapping an internal <see cref="T:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit"/>
            into the public <see cref="T:DHI.Mike1D.Engine.ISourcePointImplicit"/>. 
            <para>
            The internal <see cref="T:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit"/> is a calculation point 
            (a H grid point, a node). For each internal <see cref="T:DHI.Mike1D.Engine.ModuleHD.IHDSourcePointImplicit"/>
            there can be several of the public <see cref="T:DHI.Mike1D.Engine.ISourcePointImplicit"/> classes 
            connected to it. 
            </para>
            <para>
            It is required to separate individual implicit contributions into  
            individual instances of the public <see cref="T:DHI.Mike1D.Engine.ISourcePointImplicit"/>
            when components (AD) are evaluated, since each component can enter
            with a different concentration.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDImplicitSource.EvaluateSourceImplicit">
            <summary>
            Method to be called during FinalizeTimestep
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDOpenNodeEnumerator">
            <summary>
            Class that loops over all HD H-gridpoints with an open cross section.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQNonReturnStructure">
            <summary>
            HDQ grid point that implements non-return functionality, allowing
            only positive flow. When flow is positive, the underlying
            HDQ grid point is used for setting up the coefficients.
            <para>
            This is a special kind of Q point in the sense that it 
            may or may not have a structure beneath it:
            If Link Regulation is enabled, it will hold both an ordinary HDQ grid point
            and a structure grid point. While if Link Regulation is not 
            enabled, it will only hold an ordinary HDQ grid point.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQNonReturnStructure.NonReturnValveState">
            <summary>
            Information on state of non-return valve
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQNonReturnStructure.IsActiveStructure">
            <summary>
            Flag specyfing if special/structure action is active. If false, the
            underlying standard HDQ grid point scheme is active.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQSpecialPoint">
            <summary>
            A Q-special point is a Q point that overrides the default
            Q scheme with special functionality. 
            <para>
            Derived functionality is currently the <see cref="T:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint"/>
            and the <see cref="T:DHI.Mike1D.Engine.ModuleHD.HDQNonReturnStructure"/>.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQSpecialPoint._useHDQGridPointFlag">
            <summary>
            If _useHDQGridPointFlag is true, then an underlying HDQGridPoint is used to calculate
            _co1, _co2, _co3, and _co4 instead of the composite structure.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQSpecialPoint.IsActiveStructure">
            <summary>
            Flag specyfing if special/structure action is active. If false, the
            underlying standard HDQ grid point scheme is active.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQSpecialPoint.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Called during the prepare step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQSpecialPoint.CalculateNaturalFlow(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculate natural flow, for the underlying HDQ grid point, if present.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDStructureNode">
            <summary>
            A HD node including a <see cref="T:DHI.Mike1D.Engine.INodeStructure"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDStructureNode.#ctor(DHI.Mike1D.Engine.EngineNodeStructure,DHI.Mike1D.Engine.ModuleHD.HDModule)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDStructureNode.Initialize(DHI.Mike1D.Generic.IDiagnostics,DHI.Mike1D.Engine.EngineTime)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHeadLossCalculator">
            <summary>
            General interface for head loss calculations
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHeadLossCalculator.Initialize(DHI.Mike1D.Engine.ModuleHD.IHDNode)">
            <summary>
            Initialize calculator, providing the calculator with the 
            computational HD node.
            <para>
            The <see cref="T:DHI.Mike1D.Engine.ModuleHD.IHDNode"/> contains the state of the node, and 
            especially the water level in the node, 
            <see cref="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.WaterLevelN"/> and <see cref="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.WaterLevelNp1"/>.
            </para>
            </summary>
            <param name="hdNode">Computational HD node</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHeadLossCalculator.CalculateHeadloss(DHI.Mike1D.Engine.ModuleHD.IHDReachConnection)">
            <summary>
            Calculate head loss for the provided reach.
            <para>
            Head loss is the loss of "height" from the node to the
            reach inlet. Head loss is handled with sign, so a negative headloss
            will raise the water level boundary condition in the
            connected reach.
            </para>
            </summary>
            <param name="hdReachConnection">Connection to reach</param>
            <returns>Head loss for reach</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator">
            <summary>
            Standard head loss calculation class
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.#ctor(DHI.Mike1D.HDParameterDataAccess.HeadLossCalculationMethod,DHI.Mike1D.HDParameterDataAccess.LossCoefficientTypes,System.Double,DHI.Mike1D.HDParameterDataAccess.EffectiveFlowAreaEstimationTypes,System.Double)">
            <summary>
            Create head loss calculator
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.HeadLossCalculationMethod">
            <summary>
            Head loss method to use
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.HeadLossCoefficientType">
            <summary>
            Head loss coefficient type
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.HeadLossCoefficient">
            <summary>
            Head loss coefficient
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.EffectiveFlowAreaEstimationType">
            <summary>
            How to estimate effective flow area in node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.Initialize(DHI.Mike1D.Engine.ModuleHD.IHDNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.CalculateHeadloss(DHI.Mike1D.Engine.ModuleHD.IHDReachConnection)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.CalculateEffectiveFlowArea(DHI.Mike1D.Engine.EngineNodeVolume,System.Double)">
            <summary>
            Flow area is the area perpendicular to the flow
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.IsInlet(DHI.Mike1D.Engine.ModuleHD.IHDReachConnection)">
            <summary>
            True if water is running into node from this reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HeadLossCalculator.SetJetFactorAndJetArea(DHI.Mike1D.Engine.EngineNodeVolume,DHI.Mike1D.Engine.ModuleHD.IHDReachConnection,DHI.Mike1D.Engine.ModuleHD.IHDReachConnection)">
            <summary>
            Sets _jetArea and _jetFactor for head loss calculation. Both are geometric factors (water level independent).
            Only called only once. Needs to be called as part of the HD module since we need to know which
            reach is incoming and which is outgoing.
            todo: Should SetJetFactorAndJetArea be called if the water flow changes direction?
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IInfiltrationCalculator">
            <summary>
            Base interface for an infiltration calculator.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IInfiltrationCalculator.Initialize(DHI.Mike1D.Engine.ModuleHD.IHDNode)">
            <summary>
            Initialize calculator, giving access to HD node and HD state
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IInfiltrationCalculator.CalculateInfiltrationFlux(System.DateTime)">
            <summary>
            Calculate infiltration flux as [m^3/s].
            <para>
            Infiltration flux is positive when water enters
            the ground from the node; extracting
            water from the node.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IInfiltrationCalculator.InfiltrationFlux">
            <summary>
            Return the most recently calculated infiltration flux as [m^3/s].
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.InfiltrationCalculator">
            <summary>
            Standard infiltration calculator, implementing
            bottom and box infiltration
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.InfiltrationCalculator.InfiltrationFlux">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.InfiltrationCalculator.Initialize(DHI.Mike1D.Engine.ModuleHD.IHDNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.InfiltrationCalculator.CalculateInfiltrationFlux(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.InfiltrationCalculator.CalculateBoxInfiltration">
            <summary>
            Calculates infiltration as when basin is a box like shape, where
            bottom-area is area at bottom-level, and side 
            area is calculated by "projecting" the basin geometry out on 
            vertical planes.
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.ModuleHDExtensions">
            <summary>
            Class with extension methods for the HD module
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.ModuleHDExtensions.Slope(DHI.Mike1D.Engine.ModuleHD.IHDReachConnection)">
            <summary>
            Slope of reach, when looking into the reach from the node.
            <para>
            The slope is positive if the reach bottome level increases
            when looking from the node.
            </para>
            <para>
            Does not work for structure reaches
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.ModuleHDExtensions.MinimumOfNaturalAndCriticalDepth(DHI.Mike1D.Engine.ModuleHD.IHDReachConnection,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates minimum of natural and critical depth.
            </summary>
            <param name="reachConn">Connection of reach</param>
            <param name="hdParams">HD parameters</param>
            <returns>Minimum of natural and critical depth</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.ModuleHDExtensions.AddToOffers(DHI.Mike1D.Engine.ModuleHD.IHDNode,DHI.Mike1D.Generic.IQuantity,System.Func{System.Double})">
            <summary>
            Add to "offers", i.e. quantities that can be outputted to result file and
            requested through the result proxy system
            </summary>
            <param name="node">Node to add to.</param>
            <param name="quantity">Quantity of value to add</param>
            <param name="getter">Getter that returns the value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.ModuleHDExtensions.SetWaterLevelBoundaryCoefficients(DHI.Mike1D.Engine.ModuleHD.HDReachConnection,System.Double)">
            <summary>
            Set coefficients for start/end of reach being a water level boundary
            </summary>
            <param name="reachConn">Reach end connection to set water level boundary at</param>
            <param name="waterLevelNp1">Water level at time n+1</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.ModuleHDExtensions.SetCoupledWaterLevelBoundaryCoefficients(DHI.Mike1D.Engine.ModuleHD.HDReachConnection,System.Double,System.Double)">
            <summary>
            Set H=h coefficients for start of reach in a coupled context
            See <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetCoupledWaterLevelCoefficients(System.Double,System.Double)"/> for details.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.ModuleHDExtensions.SetStartCoupledWaterLevelQBoundaryCoefficients(DHI.Mike1D.Engine.ModuleHD.HDReachConnection,System.Double,System.Double,System.Double)">
            <summary>
            Set H=h coefficients for start of reach in a coupled context, taking change in discharge into account.
            See <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetStartCoupledWaterLevelCoefficients(System.Double,System.Double,System.Double,System.Double)"/> for details.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.ModuleHDExtensions.SetEndCoupledWaterLevelQBoundaryCoefficients(DHI.Mike1D.Engine.ModuleHD.HDReachConnection,System.Double,System.Double,System.Double)">
            <summary>
            Set H=h coefficients for start of reach in a coupled context, taking change in discharge into account.
            See <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetEndCoupledWaterLevelCoefficients(System.Double,System.Double,System.Double,System.Double)"/> for details.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDDataItems">
            <summary>
            Class that contains data items (HD add-ons) that can be reused.
            </summary>
            <remarks>
            This class is intended to avoid several versions
            of the same data item (HD add-ons) are created, 
            if e.g. you need to calculate the total volume 
            in more than one location, the same volume calculator is used.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.DischargeHPoints">
            <summary>
            Interpolate discharge on H points
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.Volume(System.Boolean)">
            <summary>
            Volume in network for the current time step
            </summary>
            <param name="detailed">True if detailed for the entire network, false for only total value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.FloodedAreaTotal">
            <summary>
            Total flooded area in network for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.VolumeInNodesAboveGround">
            <summary>
            Volume in network for the current time step in nodes above ground
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.WaterFlowRateAboveGround">
            <summary>
            Volume in network for the current time step in nodes above ground
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.VolumeChange">
            <summary>
            Change in volume for the current time step
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.WaterLevelMinMax">
            <summary>
            Min and max water level in gridpoints of reach
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.TotalInflow(System.Boolean)">
            <summary>
            Total inflow into the network from the start of the simulation
            </summary>
            <param name="detailed">True if detailed for the entire network, false for only total value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.TotalOutflow(System.Boolean)">
            <summary>
            Total outflow out of the network from the start of the simulation
            </summary>
            <param name="detailed">True if detailed for the entire network, false for only total value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.TimestepInflow(System.Boolean)">
            <summary>
            Inflow into the network for current time step
            </summary>
            <param name="detailed">True if detailed for the entire network, false for only total value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.TimestepOutflow(System.Boolean)">
            <summary>
            Outflow out of the network for current time step
            </summary>
            <param name="detailed">True if detailed for the entire network, false for only total value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.MassError">
            <summary>
            Mass error for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.Froude">
            <summary>
            Froude number for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.Froude(System.Boolean,System.Boolean)">
            <summary>
            Froude number for the current time step
            </summary>
            <param name="hGridPoints">Boolean defining whether the Froude Number should be calculated on H-gridpoints</param>
            <param name="qGridPoints">Boolean defining whether the Froude Number should be calculated on Q-gridpoints, including structure points</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.FroudeEnd(System.Boolean,System.Boolean)">
            <summary>
            Froude number for the current time step at the end of the reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.EnergyLevelSlope">
            <summary>
            Energy Level Slope for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.EnergyLevel">
            <summary>
            Energy Level for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.WaterLevelSlope">
            <summary>
            Water Level Slope for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.BedShearStress">
            <summary>
            BEd Shear Stress for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.Velocity">
            <summary>
            Velocity for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.Velocity(System.Boolean,System.Boolean)">
            <summary>
            Velocity for the current time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.VelocityEnd(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Velocity for the current time step in the end of the reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.MassErrorAccumulated">
            <summary>
            Mass error accumulated (with sign) since the start of the
            simulation, i.e. total generated water.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.MassErrorCheckSum">
            <summary>
            Mass error check sum, must equal zero (order of round of errors). Only total value, not detailed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDDataItems.MassErrorAccumulatedCheckSum">
            <summary>
            Mass error check sum since start of simulation, must equal zero (order of round of errors). Only total value, not detailed
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicM11">
            <summary>
            The Q grid point scheme corresponding to the 
            MU Fully Dynamic, explicit friction.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicM11.CalculateCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates the coefficients co1, co2, co3 and co4
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQGridPointKinematicWave">
            <summary>
            Contains equation for the diffusive wave method
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointKinematicWave.#ctor(DHI.Mike1D.Engine.QGridPoint)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointKinematicWave.CalculateCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates the coefficients co1, co2, co3 and co4
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQGridPointDiffusiveWave">
            <summary>
            Contains equation for the diffusive wave method
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointDiffusiveWave.#ctor(DHI.Mike1D.Engine.QGridPoint)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointDiffusiveWave.CalculateCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates the coefficients co1, co2, co3 and co4
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHDReachConnection">
            <summary>
            A HD reach connection is used by the nodes, when listing which
            reaches that is connected to a node. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReachConnection.HDReach">
            <summary> The reach that is connected to node. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReachConnection.ReachEnd">
            <summary> The end of the reach that is connected to node, start/end of reach, based on chainage. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReachConnection.ReachNodeFlowType">
            <summary> Type of flow between reach and node </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReachConnection.HDHGridPointAtEnd">
            <summary> Shortcut to first H grid point at the end of the reach </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReachConnection.HDQGridPointAtEnd">
            <summary> Shortcut to first Q grid point at the end of the reach </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReachConnection.DirectionVector">
            <summary>
            Vector pointing from near node to distant node.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReachConnection.ListIndex">
            <summary>
            The index of this connection in the list of HD connections of the node.
            <para>
            This need not equal the list of connections in the engine node (i.e. when Routing is enabled)
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDReachConnection">
            <summary>
            Structure containing HDReach and at which end the reach is 
            connected
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDReachConnection.AllowDecoupledWl">
            <summary>
            Flag to indicate whether the water level in the reach and
            in the node can be decoupled. If this is false, then
            always h=H coefficients are set.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDReachConnection.DirectionVector">
            <summary>
            Vector pointing from near node to distant node.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDGridPointWaterLevel">
            <summary>
            Experimental code for retrieving values from inside module.
            Alternative to the valuegetter delegates, where you need one
            delegate for every node, grid point etc. This is a class
            that extracts the value for a given node/grid point.
            <para>
            Benefits: 
            - No need for storing a lot of getters
            - It can do non-local calculations (water level slope)
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints">
            <summary>
            Apply constraints on time steps
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.AdaptiveTSBoundary">
            <summary>
            Structure containing boundaries and reference value. Used with adaptive time stepping
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.AdaptiveTSBoundary.#ctor(DHI.Mike1D.BoundaryModule.IBoundaryAdaptive,System.Double,System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.AdaptiveTSBoundary.Boundary">
            <summary>
            Boundary
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.AdaptiveTSBoundary.ReferenceValue">
            <summary>
            Reference Value 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.AdaptiveTSBoundary.InflowBoundary">
            <summary>
            Flag specifying whether it is an inflow boundary or a water level boundary.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints._timestepFactor">
            <summary>
            TimeStepFactor is calculated in <see cref="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.Check"/>, called as the final
            step in <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.PerformTimestep"/>, and available for next time step
            when asking for <see cref="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.PreferredTimeStep(System.TimeSpan,System.DateTime,System.Boolean,System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.TimeStepping">
            <summary>
            Returns timeStepping
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.AddBoundaryToAdaptiveTimeStepCheck(DHI.Mike1D.BoundaryModule.IBoundarySource,System.Double,System.Boolean)">
            <summary>
            Add a boundary source to the adaptive time series check
            </summary>
            <param name="bnd">Boundary to add</param>
            <param name="referenceValue">Reference value of boundary, used to calculate relative change from</param>
            <param name="inflowBoundary">True for inflow boundaries, false for water level boundaries</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.AddBoundaryToAdaptiveTimeStepCheck(DHI.Mike1D.BoundaryModule.IBoundaryAdaptive,System.Double,System.Boolean)">
            <summary>
            Add a boundary source to the adaptive time series check
            </summary>
            <param name="bnd">Boundary to add</param>
            <param name="referenceValue">Reference value of boundary, used to calculate relative change from</param>
            <param name="inflowBoundary">True for inflow boundaries, false for water level boundaries</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleHD.HDModule,DHI.Mike1D.HDParameterDataAccess.TimeStepping,System.DateTime)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.HDHGridPointChecks(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double@,System.Double@,System.Double@,System.Double@,System.Int32,System.Int32)">
            <summary>
            Check hdh-grid points
            </summary>
            <param name="hdhGridPoint"></param>
            <param name="factorRelativeDepthCheck"></param>
            <param name="factorCrossSectionChecks"></param>
            <param name="dhmax"></param>
            <param name="dhHmax"></param>
            <param name="i">Reach index in local XS structure</param>
            <param name="j">Grid point index in local XS structure</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.Check">
            <summary>
            Checking Solution Constraints for adaptive Time Step
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.TimeStepOk">
            <summary>
            Flag indicating if last time step was OK.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.RelativeDepthCheck(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double@)">
            <summary>
            Relative depth (MIKE URBAN version), only for closed cross sections
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.CrossSectionChecks(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double@,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="hdhGridPoint"></param>
            <param name="factorCrossSectionChecks"></param>
            <param name="i">Reach index in local XS structure</param>
            <param name="j">Grid point index in local XS structure</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.PreferredTimeStep(System.TimeSpan,System.DateTime,System.Boolean,System.TimeSpan)">
            <summary>
            Calculate preferred time step
            </summary>
            <param name="previousDt"></param>
            <param name="timeN"></param>
            <param name="onFailure"></param>
            <param name="maxDt"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.CheckStructures(System.TimeSpan,System.DateTime)">
            <summary>
            Checking Boundary Time series and retrieving preferred dt  
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.Prepare">
            <summary>
            Set up internal data structures
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.AdaptiveTSCheckSolutionConstraints.GetBoundaryPreferredTimeStep(System.DateTime,System.TimeSpan,System.TimeSpan,System.Double,System.Double)">
            <summary>
            Get preferred time step, such that changes in boundary time series is within some limits
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDHPointEnumerator">
            <summary>
            Class that loops over all HD H-gridpoints with an open cross section.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicImplicit">
            <summary>
            The Q grid point scheme corresponding to the 
            MU Fully Dynamic, implicit friction.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicImplicit.CalculateCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates the coefficients co1, co2, co3 and co4
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDOpenHPointEnumerator">
            <summary>
            Class that loops over all HD H-gridpoints with an open cross section.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDOpenQPointEnumerator">
            <summary>
            Class that loops over all HD Q-gridpoints where both its neighbours has an open cross section.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.CheckHDSolution">
            <summary>
            Check the water depth on cross sections. If water depth exceeds _maxWaterDepthFactor 
            (default 4.0) times cross section height, a runtime diagnostics error is thrown.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.CheckHDSolution.#ctor(DHI.Mike1D.Engine.ModuleHD.HDModule)">
            <summary>
            Constructor.
            </summary>
            <param name="hdModule"></param>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.CheckHDSolution._maxWaterDepthFactor">
            <summary>
            The maximum water depth on h points with open cross sections
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.CheckHDSolution.MaxWaterDepthFactor">
            <summary>
            The maximum water depth on h points with open cross sections
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.CheckHDSolution.MaxWaterDepthAboveGroundInNodes">
            <summary>
            Set the maximum wwater depth above ground level allowed in nodes. If relevant, then 
            the water level in nodes is checked during the CheckSolution event
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.CheckHDSolution.CheckWaterDepthInOpenXSBelowFactorTimesHeight">
            <summary>
            The water depth check is performed here. If water level checking is active, this
            method subscribes to CheckSolutionEvent in HDModule.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.CheckHDSolution.CheckWaterDepthInOpenXSBelowBanks">
            <summary>
            Check that water level in open cross sections is below bank level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.CheckHDSolution.CheckWaterDepthInNodesBelowGroundLevelPlusH">
            <summary>
            Check that water level in nodes is below ground level plus H (default 10m)
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPointCentered">
            <summary>
            A Q grid point containing a composit structure.
            The structure discharge is centered around the calculated discharge at time N
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPointCentered.CenteringFactor">
            <summary>
            Centering factor used when centering the discharge in time
            The centering factor is the weight of the previous discharge on the new discharge:
            q = (1 - _centeringFactor) * q_structure + _centeringFactor * prevDischarge;
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions">
            <summary>
            Setting of HD initial conditions, wrapping the 
            different options for statestart, hostart, parameter 
            conditions.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.IcOrigin">
            <summary>
            Priorities of the different types of initial conditions.
            The larger value the "stronger" condition, the strongest
            one wins.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.FillUpPressurizedToTop">
            <summary>
            Flag indicating that pressurized section depressions should
            be filled up to the top of the pressurized system and not the 
            bottom level.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.FillUpPressurized">
            <summary>
            Flag indicating that pressurized section depressions should
            be filled up. They are filled up as default, but can also be 
            filled up to the top of the cross section, depending on the 
            <see cref="F:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.FillUpPressurizedToTop"/> flag.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.SetupPumpFlushPoints">
            <summary>
            Make flush-points for all pumps, both on structure reaches and on regular reaches.
            A flush point is the (smallest) stop level upstream of the pump. 
            On structure reaches that is the upstream node.
            On regular reaches that is the upstream gridpoint.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.MinPumpStopLevel(DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint,System.Boolean@)">
            <summary>
            Helper method to find the minimum pump stop level of a structure grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.InitializeEmptySystem">
            <summary>
            Initializes the system as Empty, sets the water level to the minimum water depth
            in all reaches and nodes. Also sets discharge to 0.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.ApplyHotstartParameterStart">
            <summary>
            Applies hotstart, parameter start and global values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.NetworkFlushOut(System.Boolean)">
            <summary>
            Perform a network flush-out. A flush-out will add water to
            all depressions in the system. If there are no open boundaries
            and no internal flush-in-nodes defined in the network, the flush-out 
            has no effect.
            </summary>
            <remarks>
            <para>
            In case a water level boundary is found, the level of the boundary at
            the beginning of the simulation is used as flush-level
            </para>
            <para>
            The flush-out will behave independantly whether any stronger initial 
            conditions have been set on parts/all of the network, however, it 
            will not overwrite stronger initial conditions.
            </para>
            <para>
            The flush-out will only overwrite weaker initial conditions (as a global value),
            if the flush-out level is higher than the weaker condition.
            It will mark all nodes and hgridpoints such that a weaker condition
            can not be set at a later stage, i.e., a global condition must be set
            before calling this routine.
            </para>
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.FlushOut(DHI.Mike1D.Engine.ModuleHD.HDReach,System.Boolean,System.Int32,System.Double,System.Double[],DHI.Mike1D.Generic.PriorityQueue{System.Double,DHI.Mike1D.Engine.ModuleHD.HDNode},DHI.Mike1D.Generic.PriorityQueue{System.Double,DHI.Mike1D.Engine.ModuleHD.HDNode}.Node[])">
            <summary>
            Flush out reach. If "flushing through" the reach, adds other node to the <paramref name="flushQueue"/>.
            </summary>
            <param name="hdReach">Reach to flush out</param>
            <param name="startFromEnd">Direction to start flush from</param>
            <param name="startGpIndex">Index of grid point to start flush from, starting depending on the <paramref name="startFromEnd"/> flag. 
              To start from the end of the reach, set to zero</param>
            <param name="flushwl">Current flush water</param>
            <param name="nodeFlushLevels"></param>
            <param name="flushQueue"></param>
            <param name="flushQueueNodes"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.CanFlush(DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint,System.Boolean,System.Double@)">
            <summary>
            Returns true if the structure can flush through in the specified direction, and 
            outputs the <paramref name="minFlushInvert"/> being the smallest invert of all structures
            that can flush.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.FlushInFromBoundaries">
            <summary>
            Flush in from specified water level boundaries.
            </summary>
            <remarks>
            <para>
            Compared to flush-out: 
            Flush-in only processes water level boundaries that are explicitly marked for flush-in.
            In flush-in, the largest water level wins. In flush-out, the smallest water level wins.
            </para>
            <para>
            The flush-in is stopped if it meets a stronger initial condition.
            </para>
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.Flush(DHI.Mike1D.Engine.ModuleHD.HDNode,System.Double,DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.IcOrigin)">
            <summary>
            Flush water into node at waterLevel. Returns true if node was flushed, ie if water can run into the node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.FlushIn(System.Double,DHI.Mike1D.Engine.ModuleHD.HDReach,DHI.Mike1D.Engine.EngineReachEnd,System.Int32)">
            <summary>
            Flush water into reach in inflowReachEnd at waterLevel. 
            Returns true if water flushed through the reach to the other end.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.EnforceMinimumNodeWaterLevelFromReaches(System.Boolean)">
            <summary>
            If water level in node is smaller than the minimum level of 
            all connecting reaches, the level is set to the minimum 
            water level of the connecting reaches.
            </summary>
            <remarks>
            It is assumed that the reach bottom level can not be smaller 
            than the node bottom level, hence this will not set a waterlevel smaller
            than the bottom level of the node. (That would be an invalid setup, and should
            be caught as an error in validate.)
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.InitialMinWaterDepth(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint)">
            <summary>
            Returns the minimum water depth for a given h-gridpoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.SetNodeWaterLevel(DHI.Mike1D.Engine.ModuleHD.HDNode,System.Double,DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.IcOrigin)">
            <summary>
            Sets the node water level, though not below the minimum water depth.
            Also the origin of the value is updated.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.SetHGridpointWaterLevel(DHI.Mike1D.Engine.ModuleHD.HDReach,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double,DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.IcOrigin)">
            <summary>
            Sets the H grid point water level, though not below the minimum water depth.
            Also the origin of the value is updated.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.ApplyQPointNaturalFlow">
            <summary>
             Apply natural flow given current water levels.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.SolveToSteadySolution">
            <summary>
            Solve to steady state solution
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.StructureHotstartValues">
            <summary>
            Helper class for handling structures in hotstart files.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDInitialConditions.StructureHotstartValues.StructureIdDataItems">
            <summary>
            Data items for all structures in result file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDNetworkDataHotstartParameterValues`1">
            <summary>
            Combining hot start and parameter start values, returning a hot start value if it
            is available, and otherwise a parameter start value.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNetworkDataHotstartParameterValues`1.CreateHotstartValue(System.Double)">
            <summary> Create a value of type T based on a hostart value from file </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNetworkDataHotstartParameterValues`1.CreateDefaultValue">
            <summary> Create a default value, used when no other values are found </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDNetworkDataDoubleHotstartParameterValues">
            <summary>
            Network value for a double parameter, where the hotstart files 
            and the parameters are all doubles.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDNetworkDataWaterLevelDepth">
            <summary>
            Network value for water level/depth, where the hotstart files are
            water level based, and the parameters are <see cref="T:DHI.Mike1D.HDParameterDataAccess.HDWaterLevelDepth"/>
            based.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDNetworkDataInitDischarge">
            <summary>
            Network value for discharges, where the hotstart files are
            discharge based, and the parameters are <see cref="T:DHI.Mike1D.HDParameterDataAccess.HDInitDischarge"/>
            based.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.EngineInitialConditions`1">
            <summary>
            Class that handles initial conditions for the engine, by
            prioritizing different conditions:
            - State condition (not implemented)
            - Hotstart condition, handling several hot start files
            - Parameter condition.
            
            A global value <see cref="M:DHI.Mike1D.Engine.ModuleHD.EngineInitialConditions`1.GetGlobalValue(`0@)"/> is always retrieved 
            from the parameter condition.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDGridPoint">
            <summary>
            HDGridpoint contains the basic information for a gridpoint
            in the HDModule
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.Delta">
            <summary>
            Time centering. Delta = 1 is fully implicit.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDGridPoint._delta">
            <summary>
            Time centering. Delta = 1 is fully implicit.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Called during the prepare step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.PrepareForTimeStep(System.Int32)">
            <summary>
            Transfer the N+1 state to the N state, preparing for next timestep
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.UpdateForNphDependentValues">
            <summary>
            Update gridpoint variables for timestep N+. 
            State variables are linearly interpolated between N and N+1 and
            derived variables are updated using the interpolated state variables.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.CalculateCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates the coefficients co1, co2, co3 and co4
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.Statistics">
            <summary>
             Get statistics object. Contains total inflow and total outflow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.CreateStatistics">
            <summary>
            Create statistics class.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.ValueGetter(System.Int32)">
            <summary>
            Get value setter for the specified data quantity
            </summary>
            <param name="quantityIndex">Requested Quantity, index in <see cref="M:DHI.Mike1D.Generic.IQuantityProxy.Offers"/></param>
            <returns>A value getter delegate that can set the value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.ValueSetter(System.Int32)">
            <summary>
            Get value setter for the specified data type
            </summary>
            <param name="quantityIndex">Requested Quantity, index in <see cref="M:DHI.Mike1D.Generic.IQuantityProxy.Accepts"/></param>
            <returns>A value setter delegate that can set the value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDGridPoint.ToString">
            <summary>
            Overriding ToString method, providing better info in GUI when debugging
            Only in debug, do not enable in release
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint">
            <summary>
            HD Storage point. Represents the volume between the Q-points before and after.
            <para>
            The HD H grid point contains water level (state) and volume.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.GridPoint">
            <summary>
            Engine grid point matching this gridpoint
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.WaterLevelN">
            <summary> Water level for time n. Unit: [m]  </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.WaterLevelNp1">
            <summary> Water level for time n+1. Unit: [m] </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.WaterLevelNpd">
            <summary> Water level for time n+delta </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.WaterVolumeN">
            <summary> Volume in grid point at time n </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.WaterVolumeNp1">
            <summary> Volume in grid point at time n+1 </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.GetVolume(System.Double)">
            <summary>
            Volume in grid point for given water level. 
            Includes volume from additional storage/surface area.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.AddSourceContribution(System.Double)">
            <summary> Add a source contribution to the HD H grid point. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.SourcesInflow">
            <summary> Accumulated inflow sources (lateral inflow) at current time step. Always positive. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.SourcesOutflow">
            <summary>
            Accumulated outflow sources (lateral outflow) at current time step. Always negative. It does not include <see cref="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.SourcesOutflowSurface"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.SourcesOutflowSurface">
            <summary>
            Accumulated surface outflow sources at current time step. Always negative.
            This is water removed without component mass, typically evapotranspiration
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.SourcesInflowAll">
            <summary>
            Accumulated inflow sources (lateral inflow) at current time step. Always positive.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.SourcesOutflowAll">
            <summary>
            Accumulated outflow sources (lateral inflow) at current time step. Always negative.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.DischargeNph">
            <summary>
            Discharge for time n+
            Unit: [m^3/s]
            <para>
            For internal grid points it is the average discharge between the upstream and 
            downstream q grid point. For reach end grid points this is the time step average
            inflow/outflow to/from the reach (into/out off the grid point), used for mass
            balance. 
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.FlowAreaNph">
            <summary>
            Flow Area at time n+ (crossSectional flow area)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.StorageWidthNph">
            <summary>
            Storage width at time n+
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.SurfaceAreaNph">
            <summary>
            Surface Area at time n+ (storage area)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.VolumeError">
            <summary>
            Volume error in time step
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.CourantNumber">
            <summary>
            The Courant Number reflects the fraction between the amount of volume flowing 
            through the cell in one time step and the amount of volume of water in the cell. 
            <para>
            If the value is larger than one, all the water in the cell is "replaced" during
            a single time step.
            </para>
            </summary>
            <remarks>
            The Courant number is calculated based on the amount of water flowing out of the 
            cell, including sinks.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHDHGridPoint.CrossSectionUpdated">
            <summary>
            Method that must be called when a cross section has an updated geometry
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint">
            <summary>
            HD Storage point. Represents the volume between Q-point before and after. Used
            for solving the continuity equation.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.EngineCrossSection">
            <summary>
            Cross section. ICrossSection wrapped with slot functionality
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._waterLevelN">
            <summary>
            Water level for time step n
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._waterLevelNp1">
            <summary>
            Water level for time step n+1
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._waterLevelNm1">
            <summary>
            Water level for time step n-1
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._waterVolumeN">
            <summary>
            Water volume for time step n
            Unit: [m^3]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._waterVolumeNp1">
            <summary>
            Water volume for time step n+1
            Unit: [m^3]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._sourcesInflow">
            <summary>
            Accumulated inflow sources (lateral inflow) at current time step. Always positive
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._sourcesOutflow">
            <summary>
            Accumulated outflow sources (lateral outflow) at current time step. Always negative. It does not include <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesOutflowSurface"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._sourcesOutflowSurface">
            <summary>
            Accumulated surface outflow sources at current time step. Always negative
            This is water removed without component mass, typically evapotranspiration
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._sourcesInflowImplicit">
            <summary>
            Accumulated inflow implicit sources (lateral inflow) at current time step. Always positive
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._sourcesOutflowImplicit">
            <summary>
            Accumulated outflow implicit sources (lateral outflow) at current time step. Always negative
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._dsourcesImplicitdh">
            <summary>
            Accumulated implicit sources (lateral inflow) derivative at current time step. Positive into grid point
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._sourcesOutflowReduction">
            <summary>
            Outflow excess: if outflow is larger than available volume, outflow is decreased and the excess is stored here. Always positive
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._waterLevelNph">
            <summary>
            Water level for time step n+
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint._RNph">
            <summary>
            Hydraulic radius for time step n+
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.VolumeError">
            <summary>
            Volume error in time step.
            Unit: [m3]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.BottomLevel">
            <summary>
            Bottom level (smallest z)
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GridPoint">
            <summary>
            Returns the underlying gridpoint as an HGridPoints
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.WaterLevelN">
            <summary>
            Water level for time step n
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.WaterLevelNph">
            <summary>
            Water level for time step n+
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.WaterLevelNp1">
            <summary>
            State variable holding the water level for time step n+1
            Unit: [m]
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.WaterLevel(System.Double)">
            <summary>
            Return water level interpolated between N and Np1 using the specified <paramref name="fraction"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.WaterLevelNm1">
            <summary>
            State variable holding the water level for time step n-1
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.DischargeNph">
            <summary>
            Discharge for time step n+
            Unit: [m^3/s]
            <para>
            For internal grid points it is the average discharge between the upstream and 
            downstream q grid point. For reach end grid points this is the at the reach end 
            (into/out off the grid point).
            </para>
            </summary>
            <remarks>
            The value is calculated in <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.PrepareForIterationDependentValues(DHI.Mike1D.Engine.EngineTime,System.Int32)"/>
            and in some cases updated in <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDNode.EnforceZeroNetInflowToVolumeFreeNode"/>
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.FlowAreaNp1">
            <summary>
            Flow Area at time n+1 (crossSectional area)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.FlowAreaN">
            <summary>
            Flow Area at time n (crossSectional area)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.FlowAreaNph">
            <summary>
            Flow Area at time n+ (crossSectional area)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesNph">
            <summary>
            Accumulated sources (lateral inflow/outflow) at time n+
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesImplicitNph">
            <summary>
            Accumulated implicit sources (lateral inflow/outflow) at time n+
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesAllNph">
            <summary>
            Accumulated ordinary and implicit sources (lateral inflow/outflow) at time n+
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesNphTotal">
            <summary>
            Accumulated sources (lateral inflow/outflow) at time n+, including implicit sources evaluating the derivative (to be used after a time step/iteration has been completed)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesInflow">
            <summary>
            Accumulated inflow sources (lateral inflow) at current time step. Always positive
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesOutflow">
            <summary>
            Accumulated outflow sources (lateral outflow) at current time step. Always negative. It does not include <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesOutflowSurface"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesOutflowSurface">
            <summary>
            Accumulated surface outflow sources at current time step. Always negative
            This is water removed without component mass, typically evapotranspiration
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesInflowImplicit">
            <summary>
            Accumulated implicit inflow sources (lateral inflow) at current time step. Always positive
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesOutflowImplicit">
            <summary>
            Accumulated implicit outflow sources (lateral outflow) at current time step. Always negative
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesInflowAll">
            <summary>
            Accumulated inflow sources (lateral inflow) at current time step. Always positive.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesOutflowAll">
            <summary>
            Accumulated outflow sources (lateral inflow) at current time step. Always negative.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.DSourcesImplicitDh">
            <summary>
            Accumulated implicit sources (lateral inflow) derivative at current time step. Positive into grid point
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.StorageWidthNph">
            <summary>
            Storage width at time n+
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SurfaceAreaNph">
            <summary>
            Storage area (surface area) at time n+
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.StorageAreaNp1">
            <summary>
            Storage area (surface area) at time n+1
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.StorageAreaN">
            <summary>
            Storage area (surface area) at time n
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.FroudeNph">
            <summary>
            Froude number at time N+. It corresponds to u*sqrt(g*d) 
            though it need not be calculated that way.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.RNph">
            <summary>
            Hydraulic radius for time step n+
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.ResistanceNumberNph">
            <summary>
            Resistance number for time step n+
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.ResistanceNumberNp1">
            <summary>
            Resistance number for water level WaterLevelNp1
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.fN">
            <summary>
            Friction factor for time step n
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.FricN(DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Friction factor for time step n
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.dfdhN">
            <summary>
            Friction factor derivative for time step n
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.#ctor(DHI.Mike1D.Engine.HGridPoint)">
            <summary>
            Constructor. All geometrical properties are derived from the HGridPoint
            </summary>
            <param name="gridPoint">The NetworkEngine gridpoint that this gridpoint corresponds to</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.CrossSectionUpdated">
            <summary>
            Method that must be called when a cross section has an updated geometry
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.VolumeAvailableForPumping(System.Double)">
            <summary>
            Volume of water above depth
            </summary>
            <param name="depth"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetHydraulicRadiusNp1">
            <summary>
            Hydraulic radius at water depth WaterLevelNp1
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetHydraulicRadiusNph">
            <summary>
            Hydraulic radius at water depth WaterLevelNph
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetHydraulicRadiusN">
            <summary>
            Hydraulic radius at water depth WaterLevelN
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetConveyanceNph">
            <summary>
            Conveyance
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Called during the prepare step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.PrepareForTimeStep(System.Int32)">
            <summary>
            Transfer the N+1 state to the N state, preparing for next timestep
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.UpdateWaterLevelForNph">
            <summary>
            Used for MU structure reaches where area and storage widths are not relevant
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.UpdateForNphIndependentValues">
            <summary>
            Update state variables that do not depend on state variables in other (neighboring) grid points for timestep N+. 
            Water level is linearly interpolated between N and N+1 and
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.UpdateForNphDependentValues">
            <summary>
            Update state variables that DEPEND on state variables in other (neighboring) grid points for timestep N+.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.Evaluate(System.Double,System.Double)">
            <summary>
            Based on firstValue (value on start node) and lastValue
            (value on end node), calculate solution on each gridpoint
            in reach using on:
               val = e0*firstValue + e1*lastValue + f
            </summary>
            <param name="firstValue">Value at start node</param>
            <param name="lastValue">Value at end node</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.UpdateCourantNumber(System.Double,System.Double,DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Calculate the current <see cref="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.CourantNumber"/>.
            </summary>
            <param name="prevDischarge">Discharge into this point from upstream </param>
            <param name="nextDischarge">Discharge out of this point to downstream </param>
            <param name="time">Time object</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetMomentumSuppressionTerm(System.Double,DHI.Mike1D.HDParameterDataAccess.SolverSettings)">
            <summary>
            Returns the suppression of the momentum equation for
            situations where the local water depth is tending towards
            zero. Returns a number between 0 and 1,
            1 is full suppression and 0 is no suppression.
            </summary>
            <returns>Suppresion value between 0 and 1. 1 is full suppression and 0 is no suppression</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetMomentumSuppressionTermWaterLevelNp1(DHI.Mike1D.HDParameterDataAccess.SolverSettings)">
            <summary>
            Returns the suppression of the momentum equation for
            situations where the local water depth is tending towards
            zero. Returns a number between 0 and 1,
            1 is full suppression and 0 is no suppression.
            Uses the water level at TimeNp1. Only used in neighboring pumps.
            </summary>
            <returns>Suppresion value between 0 and 1. 1 is full suppression and 0 is no suppression</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetMomentumSuppressionTerm(System.Double,System.Double)">
            <summary>
            Returns the suppression of the momentum equation for
            situations where the local water depth is tending towards
            zero. Returns a number between 0 and 1,
            1 is full suppression and 0 is no suppression.
            Uses the water level at TimeN.
            </summary>
            <returns>Suppresion value between 0 and 1. 1 is full suppression and 0 is no suppression</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetSquareQOverANph">
            <summary>
            Q^2/A at time step n+
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetSquareQOverANph(System.Boolean,System.Double)">
            <summary>
            Q^2/A at time step n+, corrected for lateral/source inflow.
            </summary>
            <param name="downstream">Bool indicating if this grid point is downstream of the quering point</param>
            <param name="sinkMomentumCorrection">Sink momentum correction term</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.dhdt(DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Estimate and return dhdt based on h_n and h_{n+1}
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetVolume(System.Double)">
            <summary>
            Volume of grid point for given water level, including volume from additional 
            surface area.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetVolumeByIntegratingWidths(System.Double)">
            <summary>
            Volume calculated by integrating widths, for testing M11 way of calculating volume for a grid point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.CalculateCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Default coefficients for an internal HDHGridPoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetStartNodeCoefficients(System.Double)">
            <summary>
            Set coefficients for this gridpoint connected to StartNode
            and supply head loss (water level decrease due to 
            energy loss in node).
            </summary>
            <param name="deltaWaterLevel">Head loss</param>
            <remarks>Source contribution is handled by the node, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDNode.SetupCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.HDParameterDataAccess.HDParameterData)"/></remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetEndNodeCoefficients(System.Double)">
            <summary>
            Set coefficients for this gridpoint connected to EndNode
            and supply head loss (water level decrease due to 
            energy loss in node)
            </summary>
            <param name="deltaWaterLevel">Head loss</param>
            <remarks>
            Source contribution is handled by the node, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDNode.SetupCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.HDParameterDataAccess.HDParameterData)"/>.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetWaterLevelCoefficients(System.Double)">
            <summary>
            Setup coefficients such that the given water level 
            will be the solution to this gridpoint waterlevel.
            </summary>
            <param name="waterLevelNp1">Water level to use at time N+1</param>
            <remarks>Source contribution is handled by reach, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateStartBoundaryDischargeNph"/>, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateEndBoundaryDischargeNph"/></remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetCoupledWaterLevelCoefficients(System.Double,System.Double)">
            <summary>
            Setup coefficients approximating an H=h condition in a coupled context, where
            the area of the coupled model affected by a change in inflow/outflow is available.
            <para>
            In a coupled context, a sudden water level change in the network water level boundary value
            must be matched by an opposite water level change in the coupled water level,
            enforced by a change in inflow/outflow between the two, the inflow/outflow change matching
            the volume transfer between the two (mass conservation).
            </para>
            <para>
            The approach in this method will try/approximate a H=h condition,
            i.e. try make the external water level equal the internal water level.
            This is achieved by setting a water level boundary value on the network,
            that will imply an inflow/outflow from the network, which should make the
            coupled water level equal the network water level boundary value.
            </para>
            <para>
            In order to calculate the water level boundary value for the network,
            the affected area on the coupled side is required, i.e. the
            area which are directly affected by a change in the inflow/outflow.
            </para>
            </summary>
            <param name="externalWaterLevelN">Water level at coupled side</param>
            <param name="externalCoupledArea">Area affected by change in inflow/outflow</param>
            <remarks>Source contribution is handled by reach, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateStartBoundaryDischargeNph"/>, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateEndBoundaryDischargeNph"/></remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetStartCoupledWaterLevelCoefficients(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Setup coefficients approximating an H=h condition in a coupled context, where
            the area of the coupled model affected by a change in inflow/outflow is available.
            <para>
            In a coupled context, a sudden water level change in the network water level boundary value
            must be matched by an opposite water level change in the coupled water level,
            enforced by a change in inflow/outflow between the two, the inflow/outflow change matching
            the volume transfer between the two (mass conservation).
            </para>
            <para>
            The approach in this method will try/approximate a H=h condition,
            i.e. try make the external water level equal the internal water level.
            This is achieved by setting a water level boundary value on the network,
            that will imply an inflow/outflow from the network, which should make the
            coupled water level equal the network water level boundary value.
            </para>
            <para>
            In order to calculate the water level boundary value for the network,
            the affected area on the coupled side is required, i.e. the
            area which are directly affected by a change in the inflow/outflow.
            </para>
            <para>
            Compared to the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetCoupledWaterLevelCoefficients(System.Double,System.Double)"/> method, this also takes into account
            a change in discharge of the first Q-grid point in the branch.
            </para>
            </summary>
            <param name="externalWaterLevelN">Water level at coupled side</param>
            <param name="nextOutflowDischargeN">Discharge outflow at time N at the first q-grid point in the branch</param>
            <param name="externalCoupledArea">Area affected by change in inflow/outflow</param>
            <param name="dt">Time step in seconds</param>
            <remarks>Source contribution is handled by reach, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateStartBoundaryDischargeNph"/>, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateEndBoundaryDischargeNph"/></remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetEndCoupledWaterLevelCoefficients(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Setup coefficients approximating an H=h condition in a coupled context, where
            the area of the coupled model affected by a change in inflow/outflow is available.
            <para>
            In a coupled context, a sudden water level change in the network water level boundary value
            must be matched by an opposite water level change in the coupled water level,
            enforced by a change in inflow/outflow between the two, the inflow/outflow change matching
            the volume transfer between the two (mass conservation).
            </para>
            <para>
            The approach in this method will try/approximate a H=h condition,
            i.e. try make the external water level equal the internal water level.
            This is achieved by setting a water level boundary value on the network,
            that will imply an inflow/outflow from the network, which should make the
            coupled water level equal the network water level boundary value.
            </para>
            <para>
            In order to calculate the water level boundary value for the network,
            the affected area on the coupled side is required, i.e. the
            area which are directly affected by a change in the inflow/outflow.
            </para>
            <para>
            Compared to the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetCoupledWaterLevelCoefficients(System.Double,System.Double)"/> method, this also takes into account
            a change in discharge of the first Q-grid point in the branch.
            </para>
            </summary>
            <param name="externalWaterLevelN">Water level at coupled side</param>
            <param name="prevInflowDischargeN">Discharge inflow at time N at the last q-grid point in the branch</param>
            <param name="externalCoupledArea">Area affected by change in inflow/outflow</param>
            <param name="dt">Time step in seconds</param>
            <remarks>Source contribution is handled by reach, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateStartBoundaryDischargeNph"/>, <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateEndBoundaryDischargeNph"/></remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetStartNodeInflowCoefficients(System.Double,System.Double,DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDQGridPoint)">
            <summary>
            Setup coefficients where the inflow (Q) from start node is known. Q is positive into
            this gridpoint area.
            </summary>
            <param name="qinN">Inflow (Q) at time N</param>
            <param name="qinNp1">Inflow (Q) at time N+1</param>
            <param name="time">EngineTime</param>
            <param name="next">Next Q grid point</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetStartNodeQHCoefficients(System.Double,System.Double,System.Double,DHI.Mike1D.Engine.EngineTime,System.Double)">
            <summary>
            Setup coefficients where the QH relation at the start node is known. Q is positive into
            this gridpoint area.
            </summary>
            <param name="qTable">Q in table at first level above waterlevel N</param>
            <param name="hTable">H in table at first level above waterlevel N</param>
            <param name="dqdh">Derivative of discharge (dQ/dh) for h = _waterLevelN</param>
            <param name="time">EngineTime</param>
            <param name="qOut">Outflow discharge (qNph from next/prev q-grid point</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetEndNodeQHCoefficients(System.Double,System.Double,System.Double,DHI.Mike1D.Engine.EngineTime,System.Double)">
            <summary>
            Setup coefficients where the QH relation at the end node is known. Q is positive into
            this gridpoint area.
            </summary>
            <param name="qTable">Q in table at first level above waterlevel N</param>
            <param name="hTable">H in table at first level above waterlevel N</param>
            <param name="dqdh">Derivative of discharge (dQ/dh) for h = _waterLevelN</param>
            <param name="time">EngineTime</param>
            <param name="qIn">Inflow discharge (qNph from prev/next q-grid point</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetEndNodeInflowCoefficients(System.Double,System.Double,DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDQGridPoint)">
            <summary>
            Setup coefficients where the inflow (Q) from the end node is known. Q is positive into
            this gridpoint area.
            </summary>
            <param name="qinN">Inflow (Q) at time N</param>
            <param name="qinNp1">Inflow (Q) at time N+1</param>
            <param name="time">EngineTime</param>
            <param name="prev">Previous grid point</param>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_WaterLevel">
            <summary>
            quantityIndex of offered WaterLevel quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_WaterDepth">
            <summary>
            quantityIndex of offered WaterDepth quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_WaterLevelChange">
            <summary>
            quantityIndex of offered WaterLevel change quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_Volume">
            <summary>
            quantityIndex of offered water volume quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_Source">
            <summary>
            quantityIndex of offered source quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_SourceIn">
            <summary>
            quantityIndex of offered source quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_SourceOut">
            <summary>
            quantityIndex of offered source quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_SourceOutExcess">
            <summary>
            quantityIndex of offered source quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_CourantNumber">
            <summary>
            quantityIndex of offered
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_FlowArea">
            <summary>
            quantityIndex of offered CrossSectionArea quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_FlowWidth">
            <summary>
            quantityIndex of offered Flow width quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_HydraulicRadius">
            <summary>
            quantityIndex of offered Hydraulic radius quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_ResistanceManning">
            <summary>
            quantityIndex of offered Manning Resistance quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_ResistanceChezy">
            <summary>
            quantityIndex of offered Chezy Resistance quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_Conveyance">
            <summary>
            quantityIndex of offered Froude Number quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_FlowAreaTsMean">
            <summary>
            quantityIndex of offered 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_FlowWidthTsMean">
            <summary>
            quantityIndex of offered
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.OFFERS_FloodedArea">
            <summary>
            quantityIndex of offered
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.ACCEPTS_WaterLevel">
            <summary>
            quantityIndex of accepted WaterLevel quantity
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.Offers">
            <summary>
            List of data types that is offered and can be used in GetValue
            </summary>
            <returns>List of data types offered</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.Accepts">
            <summary>
            List of data types that is accepted and can be used in SetValue
            </summary>
            <returns>List of data types accepted</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.GetState">
            <summary>
            Returns the current state of the component
            </summary>
            <returns>Current state</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SetState(System.Collections.Generic.IList{DHI.Mike1D.Engine.NetworkStateItem})">
            <summary>
            Sets the current state of the component
            </summary>
            <param name="stateItems">State to set</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.AddSourceContribution(System.Double)">
            <summary>
             Add a contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.AddSourceImplicit(System.Double,System.Double)">
            <summary>
            Add a contribution to the source. Includes a 
            a water level derivative, to take changes of water
            level into account. Typically used by structure type sources
            <para>
            After the time step has completed (before FinalizeTimeStep), 
            the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.EvaluateSourceImplicit(System.Double,System.Double)"/>
            must be called with the same parameters. This is required to get 
            statistics on actual inflow and outflow correct.
            </para>
            </summary>
            <param name="val">Source value</param>
            <param name="dvaldh">Source value derivative with respect to water level</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.EvaluateSourceImplicit(System.Double,System.Double)">
            <summary>
            To be called at finalize time step, to get the actual
            amount of source added correct. It will update
            the <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesInflow"/> or <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.SourcesOutflow"/>
            depending on the sign. It must match exactly a previous call
            to <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.AddSourceImplicit(System.Double,System.Double)"/> and must only be called once.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.AddSourcePerLengthContribution(System.Double)">
            <summary>
             Add a contribution per length to the source.
            </summary>
            <param name="val">Value per length to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.AddSourcePerAreaContribution(System.Double)">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.AddSurfaceSourceContribution(System.Double)">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.ValueFractionGetter(System.Int32,DHI.Mike1D.Engine.ModuleHD.HDReach)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.CalculateFrictionFactor(DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator,System.Double,System.Double@)">
            <summary>
            Friction factor is a generalization for all resistance formulation, returning
            a factor to be used in the friction term on the form:
               g*Q*|Q| * frictionFactor 
            
            For Manning type resistance, 
               frictionFactor = 1 / (M*A*R^(4/3))^2
            For Chezy type resistance
               frictionFactor = 1 / (C*A)^2*R
            
            It also returns the derivative of the frictionfactor wrt water level, which
            is used in the implicit resitance formulation (implicit manning / higher order)
            
            If water level is below slot top level, the friction factor is calculated at the slot top level.
            </summary>
            <param name="xsslot">Cross section to calculate friction factor for</param>
            <param name="waterLevel">Water level to obtain friction factor for</param>
            <param name="frictionFactorDerivative">Return value, the derivate of the frictionfactor wrt water level</param>
            <returns>Friction factor</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.CalculateFrictionFactor(DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator,System.Double,System.Double@,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Friction factor is a generalization for all resistance formulation, returning
            a factor to be used in the friction term on the form:
               g*Q*|Q| * frictionFactor 
            
            For Manning type resistance, 
               frictionFactor = 1 / (M*A*R^(4/3))^2
            For Chezy type resistance
               frictionFactor = 1 / (C*A)^2*R
            
            It also returns the derivative of the frictionfactor wrt water level, which
            is used in the implicit resitance formulation (implicit manning / higher order)
            
            If water level is below slot top level, the friction factor is calculated at the slot top level.
            </summary>
            <param name="xsslot">Cross section to calculate friction factor for</param>
            <param name="waterLevel">Water level to obtain friction factor for</param>
            <param name="frictionFactorDerivative">Return value, the derivate of the frictionfactor wrt water level</param>
            <returns>Friction factor</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDModule">
            <summary>
            HDModule solves the HD equations on a EngineNet, and keeps track
            of state for the HDModule.
            <para>
            The HDModule also implements the <see cref="T:DHI.Mike1D.Generic.Graph.IGraph"/> interface,
            defining only the part of the HD network in the graph.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.Id">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.Order">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.RuntimeDiagnostics">
            <summary>
            Diagnostics instance for the HD module. Used during runtime.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.HDParameters">
            <summary>
            HDParameters
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.CrossSections">
            <summary>
             Access to the cross section data
             Used during prepare.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.HDReaches">
            <summary>
            List of all HD reaches in network. 
            <para>
            Need not include all Engine reaches, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetHDReach(DHI.Mike1D.Engine.EngineReach)"/> 
            to check if a given engine reach also has a corresponding HD reach.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.Reaches">
            <summary>
            List of all HD reaches in network. 
            <para>
            Need not include all Engine reaches, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetReach(DHI.Mike1D.Engine.EngineReach)"/> 
            to check if a given engine reach also has a corresponding HD reach.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetHDReach(DHI.Mike1D.Engine.EngineReach)">
            <summary> Maps an <see cref="T:DHI.Mike1D.Engine.EngineReach"/> to the corresponding HDReach </summary>
            <remarks> Internal version, works only insde Engine project </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetReach(DHI.Mike1D.Engine.EngineReach)">
            <summary> Maps an <see cref="T:DHI.Mike1D.Engine.EngineReach"/> to the corresponding HD Reach </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.HDNodes">
            <summary>
            List of all HD nodes in network. 
            <para>
            Need not include all Engine nodes, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetHDNode(DHI.Mike1D.Engine.EngineNode)"/> 
            to check if a given engine node also has a corresponding HD node.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.Nodes">
            <summary>
            List of all HD nodes in network. 
            <para>
            Need not include all Engine nodes, use the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetNode(DHI.Mike1D.Engine.EngineNode)"/> 
            to check if a given engine node also has a corresponding HD node.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetHDNode(DHI.Mike1D.Engine.EngineNode)">
            <summary> Maps an <see cref="T:DHI.Mike1D.Engine.EngineReach"/> to the corresponding HDReach </summary>
            <remarks> Internal version, works only insde Engine project </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Maps an <see cref="T:DHI.Mike1D.Engine.EngineNode"/> to the corresponding HD Node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.DataItems">
            <summary>
            Data items for the HD module that can be reused.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.NumericalWater">
            <summary>
            Added numerical water = Added numerical water in nodes + Added numerical water in grid points
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.IsInitialized">
            <summary>
            Returns true if the moduel is initialized (the constructor does so currently)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.IsPrepared">
            <summary>
            Returns true if the moduel is prepared (<see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> has been called)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.IterationNumber">
            <summary>
            Iteration number. Access to the iteration number is needed in the control module (via a sensor)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDModule.RemovableStructureLocations">
            <summary>
            List of location of structures that can be removed - from <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDModule.EngineNet"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDModule.IterationDelegate">
            <summary>
             Delegate that is used when triggering a PreIterationEvent event.
            </summary>
            <param name="timeN"></param>
            <param name="timeNp1"></param>
            <param name="iterationNumber">Number of iteration, the first being 1</param>
        </member>
        <member name="E:DHI.Mike1D.Engine.ModuleHD.HDModule.PreIterationEvent">
            <summary>
            An event that is called everytime a timestep was successfully performed.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.TriggerPreIterationEvent(System.DateTime,System.DateTime,System.Int32)">
            <summary>
            Function that triggers the PreIterationEvent event.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDModule.ApplyExternalSources">
            <summary>
             Event for applying external sources. Called once for each time step.
            </summary>
            <param name="time"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDModule.ApplyExternalIntervalSource">
            <summary>
             Event for applying external sources. Called once for each time step.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="E:DHI.Mike1D.Engine.ModuleHD.HDModule.ExternalSources">
            <summary>
            Event for applying external sources. Called once for each time step.
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.ModuleHD.HDModule.ExternalIntervalSources">
            <summary>
            Event for applying external sources in interval. Called once for each time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.TriggerApplyExternalSources(DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Apply all external forcings, lateral inflow, wind stress etc.
            External sources are applied after the <see cref="M:DHI.Mike1D.Engine.ModuleHD.HDModule.PrepareForTimeStep(System.Int32)"/>, since
            source variables on nodes/gridpoints etc. must be reset and areas must be  
            updated to the most recent value.
            Note: TriggerApplyExternalSources() is only called once per time step. 
            This means that areaN is used and not areaNph, for per-area sources.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDModule.CheckSolutionDelegate">
            <summary>
             Event for applying external sources. Called once for each time step.
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.ModuleHD.HDModule.CheckSolutionEvent">
            <summary>
            Event for checking solution. Called once for each time step after Np1 values have been set.
            In case the check fails and it may be resolved by decreasing the time step, false is returned
            In case the check fails and the simulation must be stopped, an exception must be thrown,
            preferably by using <see cref="M:DHI.Mike1D.Generic.IDiagnostics.RuntimeError(DHI.Mike1D.Generic.IDiagnosticItem)"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.HDParameterDataAccess.TimeStepping,System.DateTime,DHI.Mike1D.Generic.StopwatchCollection)">
            <summary>
            Constructor creating a new HDModule and initializing it with the given EngineNet and
            HD parameters.
            </summary>
            <param name="engineNet"></param>
            <param name="hdParameters"></param>
            <param name="timeStepping"></param>
            <param name="simulationEnd"> </param>
            <param name="stopWatch"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.SetupModule(DHI.Mike1D.HDParameterDataAccess.TimeStepping,System.DateTime)">
            <summary>
            Sets up the module, making a state copy of nodes and reaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.Initialize(System.DateTime,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Initialize HDModule. Calls initialize on all reaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.DecompositionNodeAndReachList">
            <summary>
            Domain decomposition using METIS 
            
            </summary>
            <returns>
            A list representing which nodes/reaches is associated with which domain
            </returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.InitializeStatistics">
            <summary>
             Initialize additional output
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Prepare HDModule for first time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.AddBoundaryToAdaptiveTimeStepCheck(DHI.Mike1D.BoundaryModule.IBoundarySource,System.Double,System.Boolean)">
            <summary>
            Add a boundary source to the adaptive time series check
            </summary>
            <param name="bnd">Boundary to add</param>
            <param name="referenceValue">Reference value of boundary, used to calculate relative change from</param>
            <param name="inflowBoundary">True for inflow boundaries, false for water level boundaries</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.AddToAdaptiveTimeStepCheck(DHI.Mike1D.BoundaryModule.IBoundaryAdaptive,System.Double,System.Boolean)">
            <summary>
            Add a boundary source to the adaptive time series check
            </summary>
            <param name="bnd">Boundary to add</param>
            <param name="referenceValue">Reference value of boundary, used to calculate relative change from</param>
            <param name="inflowBoundary">True for inflow boundaries, false for water level boundaries</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.SetInitialValues">
            <summary>
            Set initial conditions, the water levels and discharges in all grid points and nodes to prepare for the first iteration.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.SetInitialUpdateDependent">
            <summary>
            When Initial values has been set, this will update dependent variables
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.PrepareStructureReaches">
            <summary>
            Set water level and discharge in grid points of structure reaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.PrepareForTimeStep(System.Int32)">
            <summary>
             Prepare nodes and reaches for next time step.
             - first time: Updates states, n to n+1 and nph. Derived variables depending
               on only local state at n, n+1 and nph may also be updated
             - Subsequent times: Resets the external source contributions.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.PerformTimestep">
            <summary>
             Perform one time step. Return true if time step succeeded, or false if it failed.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.FinalizeTimestep">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.PrepareForIteration(System.Int32)">
            <summary>
            Update state values and derived state values for time nph
            </summary>
            <param name="iterationNumber"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.PrepareForIterationDependentValues(System.Int32)">
            <summary>
            Update derived state values for time Nph - depends on Nph state values.
            </summary>
            <param name="iterationNumber"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.ApplyInternalCorrections">
            <summary>
            Apply corrections to keep solution internally consistent, eg. raise waterlevels above a given minimum.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.EnforceMinimumWaterDepth(DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.List{DHI.Mike1D.Engine.ModuleHD.HDNode},System.Collections.Generic.List{DHI.Mike1D.Engine.ModuleHD.HDReach},System.Double@,System.Double@,System.Double@)">
            <summary>
            Raise water level if it falls below a given minimum. For nodes the minimum depth is
            given in hdNode.MinWaterDepth (calculated in CalculateMinNodeWaterDepth()).
            For gridpoints without a slot, the min water depth is _hdParameters.SolverSettings.MinWaterDepth 
            (defaults to 5mm) or 0.005 * cross-section diameter, whatever is lower.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.CalculateMinNodeWaterDepth">
            <summary>
             Calculate HDNode.MinWaterDepth. Set to zero for M11 scheme. Set to min( max(0.005 * connecting pipe diameters),
             _hdParameters.SolverSettings.MinWaterDepth) for the MU scheme.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.CheckSolution">
            <summary>
            Evaluates whether the calculated solution is acceptable. In case of addaptive time stepping 
            the solution constraints are tried.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetProxy">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetProxy(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a proxy for the node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a proxy for the gridpoint in the reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetProxy(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, covering a number of gridpoints
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetProxyReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, generic data (not gridpoint associated)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetSourcePointProxy(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetSourcePointProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetImplicitSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get an implicit source point proxy for the gridpoint in the reach.
            <para>
            This can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </para>
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="gridpointIndex">Index to gridpoint to get source point for</param>
            <returns>An implicit source point proxy, null if no implicit sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetImplicitSourcePoint(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get an implicit source point proxy for the node.
            <para>
            This can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </para>
            </summary>
            <param name="node">Node to get source point proxy for</param>
            <returns>null if no implicit sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.AddNodeMaxInflowReservoir(DHI.Mike1D.Engine.NodeMaxInflowReservoir)">
            <summary>
            Should only be called once for each node, even if the same
            NodeMaxInflowReservoir is used in many places
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetSourcePointNodeInfiltration(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a source point for the specified node. The SourcePointNodeInfiltrationDecorator class collects all inflow
            added through the decorator and multiplies the inflow by the maximum area below the waterlevel (constant for manholes)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a source point for the gridpoint in the reach.
            
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="gridPointIndex">Index to gridpoint to get source point for</param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Type)">
            <summary>
            Get a source point covering all gridpoints in the reach of the specified type
            
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="TGridPoint">Type of gridpoint.</param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Type,DHI.Mike1D.Generic.ILocationSpan)">
            <summary>
            Get a source point covering all gridpoints in the span of the specified type
            
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="TGridPoint">Type of gridpoint.</param>
            <param name="reachPartSpan"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.AddSource(DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary"/> to the <see cref="T:DHI.Mike1D.Engine.ModuleHD.HDModule"/>. 
            Only those <see cref="T:DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary"/>
            that are actually supported by the HDModule, is added.
            
            This must be called after Prepare
            </summary>
            <param name="bnd">Boundary to add</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.PreferredTimeStep(System.Boolean,System.TimeSpan)">
            Return a timestep larger than _engineNet.engineTime.DtSpan. 
            This method is called at each timestep.
            If this module does not want to increase time, then return _engineNet.engineTime.DtSpan
            Note: It is not safe to increase timestep to something unrealistic. Only if you are sure that
            another module correctly limits the maximum timestep can you return an abitrarily large TimeSpan.
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.Finish">
            <summary>
             Release any license and clean up
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.SetupReachCoeffDebugger(DHI.Mike1D.Engine.CoefficientDebugInfo,DHI.Mike1D.Engine.EngineNet,System.String)">
            <summary>
            Set the debug level of the HDModule. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.WriteState(DHI.Mike1D.ModelState.ModelStateWriter)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDModule.ReadState(DHI.Mike1D.ModelState.ModelStateReader)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDModule.GridPointProxy">
            <summary>
            The grid point proxy is required in order to
            add the reach argument to the valuegetter method.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHDNode">
            <summary>
            HD node contains HD state for a node.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.Reaches">
            <summary>
            List of Reach connections, each specifying a connection between
            the node and a reach.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.WaterLevelN">
            <summary> Water level at time n</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.WaterLevelNp1">
            <summary> Water level at time n+1</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.SourcesInflow">
            <summary>Accumulated inflow sources (lateral inflow) at current time step. Always positive </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.SourcesOutflow">
            <summary>Accumulated outflow sources (lateral outflow) at current time step. Always negative. It does not include <see cref="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.SourcesOutflowSurface"/> </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.SourcesOutflowSurface">
            <summary>
            Accumulated surface outflow sources at current time step. Always negative
            This is water removed without component mass, typically evapotranspiration
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.SourcesOutflowAll">
            <summary>
            Accumulated surface outflow sources at current time step. Always negative.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHDNode.AddSourceContribution(System.Double)">
            <summary>
             Lateral inflow, average value over time step or value at time N+. 
            <para>
            Be aware that you can not add lateral inflow
            to a node which is an active open boundary (has no effect).
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHDNode.InOutflowAnnul(System.Double)">
            <summary>
            After a HD time step (and before AD time step), it is possible to
            add or withdraw discharge from both source input and output.
            <para>
            The amount must be smaller than both <see cref="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.SourcesInflow"/> and <see cref="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.SourcesOutflow"/>,
            or, it will be limited to the largest of the two (because they cannot change sign)
            </para>
            </summary>
            <param name="dischargeToAnnul">Amount to annul (when positive) or increase (when negative)</param>
            <returns>Actual amount annulled</returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.VolumeError">
            <summary>
            Calculate the volume/mass error for node. In volume unit ([m3]).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDNode.CourantNumber">
            <summary>
            The Courant Number reflects the fraction between the amount of volume flowing 
            through the cell in one time step and the amount of volume of water in the cell. 
            <para>
            If the value is larger than one, all the water in the cell is "replaced" during
            a single time step.
            </para>
            </summary>
            <remarks>
            The Courant number is calculated based on the amount of water flowing out of the 
            cell, including spilling and sinks.
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHDStructureNode">
            <summary>
            HD structure node contains an <see cref="T:DHI.Mike1D.Engine.EngineNodeStructure"/> with a <see cref="T:DHI.Mike1D.Engine.INodeStructure"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDStructureNode.OutletReach">
            <summary>
            Outlet reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.ReachNodeFlowTypes">
            <summary>
            Enumeration defining the flow between a node and a reach.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.ReachNodeFlowTypes.Default">
            <summary>
            Default flow, either inflow or outflow from reach to node. 
            Water level is coupled between node and reach, i.e. the water level
            in the node and in the first water level will equal or differ only
            due to head loss.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.ReachNodeFlowTypes.ZeroFlow">
            <summary>
            The node and the reach is decoupled and there is no flow between them.
            <para>
            The reach (the first hdh-grid point) were set up using a zero-flow "boundary condition". 
            </para>
            <para>
            This happens e.g. when the water level in the node falls below the reach bottom level,
            and there is not free outflow from the reach (typically reach slope is away from the node).
            </para>
            <para>
            When ZeroFlow type is in use, then the contribution from the first grid point in the reach 
            is ignored when calculating the node mass balance equation; 
            the grid point calculates its own mass balance equation.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.ReachNodeFlowTypes.FreeOutflow">
            <summary>
            There is free outflow from reach into node.
            <para>
            The reach (the first hdh-grid point) were set using a free outflow 
            "boundary condition", i.e. water is flowing freely from reach into node, and node
            state has no influence on the flow.
            </para>
            <para>
            In rare occasions, in the transition between free outflow and default flow, the
            actual flow may be from node to reach, even though the FreeOutflow type is set.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode._sourcesInflow">
            <summary>Accumulated inflow sources (lateral inflow) at current time step. Always positive </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode._sourcesOutflow">
            <summary>Accumulated outflow sources (lateral outflow) at current time step. Always negative. It does not include <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDNode.SourcesOutflowSurface"/> </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode._sourcesOutflowSurface">
            <summary>
            Accumulated surface outflow sources at current time step. Always negative
            This is water removed without component mass, typically evapotranspiration
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode._sourcesImplicit">
            <summary> Accumulated implicit sources (lateral inflow) at current time step. Positive into grid point </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode._dsourcesImplicitdh">
            <summary> Accumulated implicit sources (lateral inflow) derivative at current time step. Positive into grid point </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDNode.VolumeError">
            <summary>
            Volume error in time step.
            Unit: [m3]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDNode.EngineNode">
            <summary>
            The EngineNode that this solvernode is based on
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDNode.Statistics">
            <summary>
             Get statistics object. Contains total inflow and total outflow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.Initialize(DHI.Mike1D.Generic.IDiagnostics,DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Initialize takes place during initialization of dynamic components
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.CalculateSources(DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Calculate and add sources that are "internal" to the node.
            <para>
            Cannot be part of SetupCoefficients, because SetupCoefficients
            may be called more than once (number of time-step iterations),
            and contributions should only be added once.
            </para>
            </summary>
            <param name="time"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.CalculateInfiltrationFlux(DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Calculate infiltratin flux, using the <see cref="P:DHI.Mike1D.Engine.EngineNode.InfiltrationCalculator"/>.
            Also apply slot-like functionality for low water levels.
            </summary>
            <param name="time"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.EvaluateImplicitSpillingDischarge">
            <summary>
            Transfers implicit spilling discharge to actual discharge
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.PrepareForIteration">
            <summary>
            Prepare for iteration
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.AddSourceContribution(System.Double)">
            <summary>
            Lateral inflow at time N+. Be aware that you can not add lateral inflow
            to a node which is an active open boundary (has no effect (TODO: catch in validate step)).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.InOutflowAnnul(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.CreateStatistics">
            <summary>
            Create statistics class.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.SetupCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Set up coefficients for node, and populate the node matrix
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.EliminateGridpointCoefficient(DHI.Mike1D.Engine.ModuleHD.HDReachConnection,DHI.Mike1D.Engine.Solver.SolverGridPointSrhs,System.Double)">
            <summary>
            Eliminate the node equation depedency on the grid point in the connecting reach.
            </summary>
            <param name="reachConnection">Connecting reach</param>
            <param name="gridpoint">Grid point where the coefficient belongs to</param>
            <param name="gridpointCoefficient">Coefficient for the grid point in the node equation</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.SetupReachCoefficients(DHI.Mike1D.Engine.ModuleHD.HDReachConnection,DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Set up coefficients for last gridpoint of specified reach that
            is connected to this node.
            </summary>
            <param name="hdReachConn">hd reach connection to setup</param>
            <param name="time">Time at which to setup parameters</param>
            <param name="hdParameterData">HD parameters required</param>
            <remarks>
            The general case for internal nodes sets h=H for each reach. 
            For reaches with outflow, it checks for free outflow conditions
            For reaches with inflow, head loss calculations gives h = H + headloss
            Nodes with open boundaries are handled independantly.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.FlowIntoNodeReachStart(DHI.Mike1D.Engine.ModuleHD.HDQGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint)">
            <summary>
            Decide whether flow is into node, for a reach connected at the start end
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.FlowIntoNodeReachEnd(DHI.Mike1D.Engine.ModuleHD.HDQGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint)">
            <summary>
            Decide whether flow is into node, for a reach connected at the end end
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.SpillingDischarge">
            <summary>
            Discharge from spilling cover in last time step
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.EnforceZeroNetInflowToVolumeFreeNode">
            <summary>
            Correct dischargeNph on connecting reaches so that 
            the amount of water running into the node is equal to zero.
            
            Only done for internal nodes with volume (i.e. NOT EngineNodeSewer)
            
            Structure reaches (no volume on first grid point) and decoupled reaches
            should not be corrected
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode._localOffers">
            <summary> Local offers. Null if no local offers defined. Will contain the default/static offers as the first in the list</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode._localOfferGetters">
            <summary> Local offer getters. Null if no local offers defined. Will not contain the default/static offers, i.e. list is smaller than <see cref="F:DHI.Mike1D.Engine.ModuleHD.HDNode._localOffers"/></summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode.OFFERS_WaterLevel">
            <summary>
            quantityIndex of offered WaterLevel quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode.OFFERS_WaterLevelChange">
            <summary>
            quantityIndex of offered WaterLevel quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDNode.ACCEPTS_WaterLevel">
            <summary>
            quantityIndex of accepted WaterLevel quantity
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.ValueGetter(System.Int32)">
            <summary>
            Get value setter for the specified data quantity
            </summary>
            <param name="quantityIndex">Requested Quantity</param>
            <returns>A value getter delegate that can get the value, null if quantity is not offered</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.ValueSetter(System.Int32)">
            <summary>
            Get value setter for the specified data type
            </summary>
            <param name="quantityIndex">Requested Quantity</param>
            <returns>A value setter delegate that can set the value, or null if quantity is not accepted.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.CalculateMassBalanceCorrection(System.Double)">
            <summary>
            Calculate the mass balance error as the difference in added water volume minus the 
            difference in _actual_ water volume from N to Np1
            The correction is important when the node diameter changes quick as it does in the top slot and
            possibly in basins.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.CalcVolumeError(System.Double)">
            <summary>
            Calculate the volume/mass error for node. In volume unit ([m3]).
            </summary>
            <remarks> Matching exactly the mass equation set up for the node.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.UpdateCourantNumber(DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Update the Courant Number for the node, based on the total 
            node outflow discharge. Also updates Courant numbers
            for first grid points in reach.
            <para>
            Implementation is put in the AD module, since the Courant Number
            calculations are dependent on the AD implementation.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.GetCourantEquationVolume">
            <summary>
            Returns the total volume that is used when setting up the equations, i.e.
            for junction nodes it includes the volume of nearest grid points
            <para>
            For volume/sewer nodes, this is just the volume of the node. For
            junction nodes, this is the volume including first grid point
            in connecting reaches.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.EnforceMinimumWaterDepth">
            <summary>
            Make sure water level is above min allowed water level in the node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.EnforceMinimumWaterDepth(System.Double,System.Double@)">
            <summary>
            Return the amount of water added to enforce minium water depth. 
            </summary>
            <param name="dt"></param>
            <param name="waterActuallyExtracted">The amount of water actually extracted if there is an outflow, ie 
            lateralInflow less than 0.0. The water actally extracted will potentially be less than lateralInflow since the node is dry.
            </param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDNode.CorrectReachInflowToBoundaryAndVolumeFreeNode(System.Double)">
            <summary>
            Recalculate DischargeNph for first/last grid point of 
            reach, based on latest solution, such that the DischargeNph
            value exactly provides the inflow to first/outflow from last
            grid point in the reach.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDNode.SourcesInflow">
            <summary>Accumulated inflow sources (lateral inflow) at current time step. Always positive </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDNode.SourcesOutflow">
            <summary>Accumulated outflow sources (lateral outflow) at current time step. Always negative. It does not include <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDNode.SourcesOutflowSurface"/> </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDNode.SourcesOutflowSurface">
            <summary>
            Accumulated surface outflow sources at current time step. Always negative.
            This is water removed without component mass, typically evapotranspiration
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDNode.SourcesOutflowAll">
            <summary>
            Accumulated outflow sources (lateral inflow) at current time step. Always negative.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDNode.SourcesNphTotal">
            <summary>
            Accumulated sources (lateral inflow/outflow) at time n+, including implicit sources evaluating the derivative (correct after a time step/iteration has been completed)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.NodeDischargeAvailable">
            <summary>
            Helper class calculating discharge available in 
            node.
            <para>
            this is not intended for parallel pumps - if there are more
            than one pump connected to a node, this will not do as intended,
            reporting total available volume to both/all pumps.
            </para>
            <para>
            This is used in the parallel part of the code, in the loop over reaches,
            and this may access data in other reaches (which other threads can be working on), 
            so it is important that this class only accesses properties of the reach that
            does not change - especially calling hdh-gridpoint cross section functionality
            is not allowed (race condition on the cross section buffer values / hdReachConnection.ReachNodeFlowType)
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.NodeDischargeAvailable.#ctor(DHI.Mike1D.Engine.ModuleHD.IHDNode,DHI.Mike1D.Engine.EngineReach,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="hdNode">Node to investigate</param>
            <param name="engineReachWithPump">Reach for which available discharge is sought, usually a pump. Can be null</param>
            <param name="minWaterDepth">Minimum depth of water to leave in node</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.NodeDischargeAvailable.DischargeAvailableForPumping(System.Double)">
            <summary>
            Return the maximum discharge that can be pumped out of this node before it runs dry.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamic">
            <summary>
            The Q grid point scheme corresponding to the 
            MU Fully Dynamic, explicit friction.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamic.CalculateCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates the coefficients co1, co2, co3 and co4
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHDQGridPoint">
            <summary>
            HD flow/discharge point. Represents the discharge between two H points.
            <para>
            The HD Q grid point contains discharge.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDQGridPoint.GridPoint">
            <summary>
            Engine grid point matching this gridpoint
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDQGridPoint.IsActiveStructure">
            <summary>
            Flag specyfing if special/structure action is active. If false, the
            underlying standard HDQ grid point scheme is active.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDQGridPoint.DischargeN">
            <summary>
            Discharge at time n
            Unit: [m3/s]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDQGridPoint.DischargeNp1">
            <summary>
            Discharge at time step n+1
            Unit: [m3/s]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDQGridPoint.DischargeNpd">
            <summary>
            Discharge at time step n+delta
            Unit: [m3/s]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDQGridPoint.DischargeNph">
            <summary>
            Discharge at time step n+
            Unit: [m3/s]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint">
            <summary>
            Abstract Q gridpoint class in HD module, containing the
            common state and code for a Q gridpoint.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.#ctor(DHI.Mike1D.Engine.QGridPoint)">
            <summary>
            Constructor that should be called by overriding classes.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.CalculateSteadyInit(DHI.Mike1D.Engine.EngineTime,System.Double,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculate initial guess for steady iteration. Needed for steady state computations.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.CalculateSteadyResidual(DHI.Mike1D.Engine.EngineTime,System.Double,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculate residual from Q point equation. Needed for steady state computations.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint._sourcesNph">
            <summary>
            Accumulated sources at time n+
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.SourcesNph">
            <summary>
            Accumulated sources at time n+
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint._dischargeNm1">
            <summary>
            State variable holding the discharge at time step n
            Unit: [m3/s]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.DischargeNm1">
            <summary>
            State variable holding the discharge at time step n
            Unit: [m3/s]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint._dischargeN">
            <summary>
            State variable holding the discharge at time step n
            Unit: [m3/s]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.DischargeN">
            <summary>
            State variable holding the discharge at time step n
            Unit: [m3/s]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint._dischargeNph">
            <summary>
            State variable holding the discharge at time step n+
            Unit: [m3/s]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.DischargeNph">
            <summary>
            State variable holding the discharge at time step n+ (actually n+delta).
            <para>
            This is the average discharge over the last performed time step,
            and the discharge use in the mass balance equation in the H grid points.    
            </para>
            <para>
            Unit: [m3/s]
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.DischargeNpd">
            <summary>
            Calculates discharge at N + Delta. 
            <para>
            Unit: [m3/s]
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.DischargeNp1">
            <summary>
            State variable holding the discharge at time step n+1
            Unit: [m3/s]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.WaterLevelNph">
            <summary>
            Water level at time step n+
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.IsMUTypeQPoint">
            <summary>
            flag indicating if Q point is a MU type with a Q-crossSection and using H-slope
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.BottomLevel">
            <summary>
            Bottom level (smallest z)
            Unit: [m]
            </summary>
            <remarks>
            Used only in classical MU setups, only available when <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.QCrossSection"/> is available
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.QCrossSection">
            <summary>
            Cross section at this point. MU setups need a cross section on q-grid points.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint._hslope">
            <summary>
            HSlope is the negative dHdx at time Nph
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.Hslope">
            <summary>
            HSlope is the negative dHdx at time Nph
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.PrepareForTimeStep(System.Int32)">
            <summary>
            Transfer the N+1 state to the N state, preparing for next timestep
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.Evaluate(System.Double,System.Double)">
            <summary>
            Based on firstValue (value on start node) and lastValue
            (value on end node), calculate solution on each gridpoint
            in reach based on:
               val = e0*firstValue + e1*lastValue + f
            </summary>
            <param name="firstValue">Value at start node</param>
            <param name="lastValue">Value at end node</param>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.OFFERS_Discharge">
            <summary>
            quantityIndex of offered Discharge quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.OFFERS_DischargeChange">
            <summary>
            quantityIndex of offered Discharge quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.OFFERS_CO1">
            <summary>
            quantityIndex of offered co1 coefficient
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.OFFERS_CO2">
            <summary>
            quantityIndex of offered co1 coefficient
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.OFFERS_CO3">
            <summary>
            quantityIndex of offered co1 coefficient
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.OFFERS_CO4">
            <summary>
            quantityIndex of offered co1 coefficient
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.ACCEPTS_Discharge">
            <summary>
            quantityIndex of accepted Discharge quantity
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.Offers">
            <summary>
            List of data types that is offered and can be used in GetValue
            </summary>
            <returns>List of data types offered</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.Accepts">
            <summary>
            List of data types that is accepted and can be used in SetValue
            </summary>
            <returns>List of data types accepted</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.SubConvTerm(System.Double,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Suppression of convective term, based on froudeNumber
            </summary>
            <param name="froudeNumber">froudeNumber</param>
            <param name="hdParameters">HD parameters</param>
            <returns>Supression factor between 0-1</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.CalculateUpstreamWeightingFactorFriction(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate an upstream weighting factor for the friction formulation
            </summary>
            <param name="usHPointRn">The upstream h point hydraulic radius</param>
            <param name="dsHPointRn">The downstream h point hydraulic radius</param>
            <param name="froude">Froude number</param>
            <param name="deltahN">Delta water level (next-prev)</param>
            <returns>An upstream weighing factor</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.CalculateUpstreamWeightingFactorFrictionNp1(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double,System.Double)">
            <summary>
            Calculate an upstream weighting factor for the friction formulation
            </summary>
            <param name="usHPoint">The upstream h point</param>
            <param name="dsHPoint">The downstream h point</param>
            <param name="froudeNp1">Froude number at time Np1</param>
            <param name="deltahN">Delta water level (next-prev)</param>
            <returns>An upstream weighing factor</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.CoeffFrictionHighOrder(System.Double,System.Double,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double,System.Double)">
            <summary>
            Setup coefficents for the friction term, using the high
            order/implicit friction formulation
            </summary>
            <param name="flowdir">Direction of flow, 1.0 for positive flow, -1.0 for negative flow</param>
            <param name="usWeight">Weighting factor. 1 = use full us value, 0 = full ds value</param>
            <param name="usHPoint">previous H point</param>
            <param name="dsHPoint">next H point</param>
            <param name="qNfac">Usually System.Math.Abs(_dischargeN), but can be a variant of that</param>
            <param name="coefScaleFactor">The factor with which to scale before setting coefficients _co1-4</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.SetCoeffFrictionHighOrder(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Setup coefficents for the friction term, using the high
            order/implicit friction formulation
            </summary>
            <param name="flowdir">Direction of flow, 1.0 for positive flow, -1.0 for negative flow</param>
            <param name="fricN">Friction factor at time N</param>
            <param name="dfricdhN">Friction factor derivative at time N</param>
            <param name="usWaterlevelN">Water level upstream at time N</param>
            <param name="qNfac">Usually System.Math.Abs(_dischargeN), but can be a variant of that</param>
            <param name="coefScaleFactor">The factor with which to scale before setting coefficients _co1-4</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.SetCoeffFrictionHighOrderWithMinAux1(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Setup coefficents for the friction term, using the high
            order/implicit friction formulation
            </summary>
            <param name="flowdir">Direction of flow, 1.0 for positive flow, -1.0 for negative flow</param>
            <param name="fricN">Friction factor at time N</param>
            <param name="dfricdhN">Friction factor derivative at time N</param>
            <param name="usWaterlevelN">Water level upstream at time N</param>
            <param name="qNfac">Usually System.Math.Abs(_dischargeN), but can be a variant of that</param>
            <param name="coefScaleFactor">The factor with which to scale before setting coefficients _co1-4</param>
            <param name="minAux1">Miniumum value of aux1</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.CalculateFrictionHighOrderWithMinAux1(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Setup coefficents for the friction term, using the high
            order/implicit friction formulation
            </summary>
            <param name="fric">Friction factor</param>
            <param name="discharge">Discharge </param>
            <param name="qfac">Usually System.Math.Abs(discharge), but can be a variant of that</param>
            <param name="coefScaleFactor">The factor with which to scale</param>
            <param name="minAux1">Miniumum value of aux1</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPoint.CalculateNaturalFlow(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculate the natural flow from water levels on neighboring h-points
            </summary>
            <param name="prevHPoint"></param>
            <param name="nextHPoint"></param>
            <param name="hdParameters"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicHigherOrder">
            <summary>
            Contains equation for the fully dynamic method with implicit handling 
            of the friction term also called higher order (M11) or implicit manning (MikeUrban)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicHigherOrder.#ctor(DHI.Mike1D.Engine.QGridPoint)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicHigherOrder.CalculateCoefficients(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates the coefficients co1, co2, co3 and co4
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicHigherOrder.CalculateSteadyInit(DHI.Mike1D.Engine.ModuleHD.HDQGridPoint,DHI.Mike1D.Engine.EngineTime,System.Double,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculate a steady state initial condition for the upstream grid point based
            on the downstream grid point values and the discharge.
            <para>
            In most cases it corresponds to solving the Manning equation (or similar for 
            other resistance formulations)
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDQGridPointFullyDynamicHigherOrder.CalculateSteadyResidual(DHI.Mike1D.Engine.ModuleHD.HDQGridPoint,DHI.Mike1D.Engine.EngineTime,System.Double,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculates the steady state residual. Steady state is when the equation
            below balances (dq/dt term removed):
            <code>momentum + dh/dx + friction = forcings</code>
            and the residual is the equation mismatch:
            <code>residual = momentum + dh/dx + friction - forcings</code>
            Compared to the reference manual, the equation here is divided by g*A_fl
            <para>
            Both <paramref name="prev"/> and <paramref name="next"/> must have water level
            set using the <see cref="P:DHI.Mike1D.Engine.ModuleHD.HDHGridPoint.WaterLevelNp1"/>.
            </para>
            <para>
            This residual is used to iterate the equation in a Newton-Raphson procedure.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHDReach">
            <summary>
            HD reach contains HD state for a reach. The actual state is present
            in a series of grid points.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReach.StartEngineNode">
            <summary>
            Get EngineReach.StartNode
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReach.EndEngineNode">
            <summary>
            Get EngineReach.EndNode
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.IHDReach.GridPoints">
            <summary>
            List of gridpoints in this reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.IHDReach.VolumeError(System.Int32)">
            <summary>
            Calculate the volume/mass error for grid point i (which must be an H grid point). In volume unit ([m3]).
            </summary>
            <param name="i">Grid point index, must be an H grid point</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.#ctor(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Engine.ModuleHD.HDModule,DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Constructor
            </summary>
            <param name="engineReach"></param>
            <param name="hdModule"></param>
            <param name="time"></param>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDReach.OFFERS_WaterLevel">
            <summary>
            quantityIndex of offered WaterLevel quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDReach.OFFERS_Discharge">
            <summary>
            quantityIndex of offered Discharge quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDReach.OFFERS_WaterDepth">
            <summary>
            quantityIndex of offered WaterLevel quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDReach.OFFERS_WaterVolume">
            <summary>
            quantityIndex of offered WaterVolume quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDReach.OFFERS_CourantNumber">
            <summary>
            quantityIndex of offered WaterVolume quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDReach.ACCEPTS_WaterLevel">
            <summary>
            quantityIndex of accepted WaterLevel quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleHD.HDReach.ACCEPTS_Discharge">
            <summary>
            quantityIndex of accepted Discharge quantity
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDReach.StartEngineNode">
            <summary>
            Get EngineReach.StartNode
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDReach.EndEngineNode">
            <summary>
            Get EngineReach.EndNode
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDReach.IndexListFace">
            <summary>
            Face index list, including first and last face between node and first/last grid point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.Initialize(DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.HDParameterDataAccess.HDParameterData,System.DateTime)">
            <summary>
            Initialises reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SetPumpsDischargeLimitingDelegates">
            <summary>
            Set pump discharge limiting delegates for reaches which are not structure reaches.
            We do this after creating the h-points since we need the prev and next h-points
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Prepare creates state for the reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.PrepareForTimeStep(System.Int32,DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Updates q and h point states.
            <para>
            For redoCount = 0: n+1 to n, and update of n+
            </para>
            <para>
            For redoCount > 0: Reset to n, and update of n+
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.PrepareForIterationIndependentValues">
            <summary>
            Calculates the state at at time nph. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.PrepareForIterationDependentValues(DHI.Mike1D.Engine.EngineTime,System.Int32)">
            <summary>
            Calculates values that uses up and down stream info
            A large part of this method is wave approximation specific. 
            Calculate DischargeNph on H points based on Q point values
            Note that DischargeNph may be corrected in HDNode.EnforceZeroNetNodeInflow
            Note that HDQGridPoint must be updated to Nph before this
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateStartBoundaryDischargeNph">
            <summary>
            Update the DischargeNph value for the first hdh-grid point, 
            such that DischargeNph is exactly the inflow from the node
            into the first gridpoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateEndBoundaryDischargeNph">
            <summary>
            Update the DischargeNph value for the last hdh-grid point, 
            such that DischargeNph is exactly the outflow from the last
            grid point into the node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateStartDischargeNph(System.Boolean)">
            <summary>
            Update end reach dischargeNph based on mass equation. In 
            first iteration the h_n = h_{n+1} so the mass equation can 
            not give correct results. Hence another approach is used in 
            the first iteration 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateEndDischargeNph(System.Boolean)">
            <summary>
            Update end reach dischargeNph based on mass equation. In 
            first iteration the h_n = h_{n+1} so the mass equation can 
            not give correct results. Hence another approach is used in 
            the first iteration 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.CalculateCoefficients">
            <summary>
            Calculates the coefficients co1, co2, co3 and co4 for all internal grid points, 
            i.e., not the first and last gridpoint.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SetStartDefaultCoefficients(System.Double)">
            <summary>
            Set coefficients for start of reach (low chainage)
            </summary>
            <param name="deltaWaterLevel">Head loss</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SetEndDefaultCoefficients(System.Double)">
            <summary>
            Set coefficients for end of reach (high chainage)
            </summary>
            <param name="deltaWaterLevel">Head loss</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SetStartWaterLevelBoundaryCoefficients(System.Double)">
            <summary>
            Set coefficients for start of reach being a water level boundary
            </summary>
            <param name="waterLevelNp1">Water level at time n+1</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SetEndWaterLevelBoundaryCoefficients(System.Double)">
            <summary>
            Set coefficients for end of reach being a water level boundary
            </summary>
            <param name="waterLevelNp1">Water level at time n+1</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.GetQHTableValues(DHI.Mike1D.Generic.IXYTable,System.Double,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double@,System.Double@)">
            <summary>
            Get values from QH table. We loop through the table here since we need
            the values of Q and H from the table at the values after H = _waterLevelN
            </summary>
            <param name="qhTable">QH table</param>
            <param name="waterLevel">Water level to look up</param>
            <param name="hPoint">h point to calculate Q and H values from</param>
            <param name="qTableValue">Q in table at first level above waterlevel N</param>
            <param name="hTableValue">H in table at first level above waterlevel N</param>
            <returns>Derivative of discharge (dQ/dh) for h = _waterLevelN</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.VolumeError(System.Int32)">
            <summary>
            Calculate the volume/mass error for grid point i (which must be an H grid point). In volume unit ([m3]).
            </summary>
            <remarks> Matching exactly the mass equation set up for the H grid point.</remarks>
            <param name="i">Grid point index, must be an H grid point</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.VolumeError(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double,System.Double,System.Double)">
            <summary>
            Calculate volume/mass error for a grid point for the current time step. In volume unit ([m3]).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.UpdateVolumeErrorCourantNumber(DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Update courant number on the reaches in HD module
            <para>
            Implementation is put in the AD module, since the Courant Number
            calculations are dependent on the AD implementation.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.GetHReachSource">
            <summary>
            Get a source point where you can add a source contribution
            to all H points on the entire reach
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.GetHReachSource(DHI.Mike1D.Generic.ILocationSpan)">
            <summary>
            Get a source point where you can add a source contribution
            to all H points inside the given span of the reach
            </summary>
            <param name="span">Must be entirely included in reach.LocationSpan</param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceOnAllTPoints`1">
            <summary>
            Class that adds the given source on all gridpoints of type THDGridPoint in reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceOnAllTPoints`1.AddSourceContribution(System.Double)">
            <summary>
             Add a total contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceOnAllTPoints`1.AddSourceRunoffContribution(System.Double,System.Double)">
            <summary>
             Add a total contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
            <param name="catchmentArea">Area of source catchment</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceOnAllTPoints`1.AddSourcePerLengthContribution(System.Double)">
            <summary>
             Add a contribution per length to the source.
            </summary>
            <param name="val">Value per length to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceOnAllTPoints`1.AddSourcePerAreaContribution(System.Double)">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceOnAllTPoints`1.AddSourceRunoffPerLengthContribution(System.Double,System.Double,System.Double)">
            <summary>
             Add a rainfall runoff contribution per length to the source. The surface area of the river is subtracted
             from the area available for runoff. 
            </summary>
            <param name="val">Contribution in m^3/sec</param>
            <param name="catchmentArea">Area of the catchment</param>
            <param name="sourceSpanLength">Length of the span where runoff enters the network</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceInSpanTPoints`1">
            <summary>
            Class that adds the given source on gridpoints of type THDGridPoint inside a 
            given span.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceInSpanTPoints`1.#ctor(DHI.Mike1D.Engine.ModuleHD.HDReach,DHI.Mike1D.Generic.ILocationSpan,DHI.Mike1D.BoundaryModule.TypeOfDistribution)">
            <summary>
            Default constructor
            </summary>
            <param name="hdReach"></param>
            <param name="reachPartSpan">Must be entirely included in reach.LocationSpan</param>
            <param name="distributionType"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceInSpanTPoints`1.AddSourceContribution(System.Double)">
            <summary>
             Add a total contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceInSpanTPoints`1.AddSourceRunoffContribution(System.Double,System.Double)">
            <summary>
             Add a total contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
            <param name="catchmentArea">Area of coruce catchment</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceInSpanTPoints`1.AddSourcePerLengthContribution(System.Double)">
            <summary>
             Add a contribution per length to the source.
            </summary>
            <param name="val">Value per length to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceInSpanTPoints`1.AddSourceRunoffPerLengthContribution(System.Double,System.Double,System.Double)">
            <summary>
             Add a rainfall runoff contribution per length to the source. The surface area of the river is subtracted
             from the area available for runoff. 
            </summary>
            <param name="val">Contribution in m^3/sec</param>
            <param name="catchmentArea">Area of the catchment</param>
            <param name="sourceSpanLength">Length of the span where the runoff enters the network</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDReach.SourceInSpanTPoints`1.AddSourcePerAreaContribution(System.Double)">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDReach.ReachHVectorGetter.ElementCount">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDReach.ReachQVectorGetter.ElementCount">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.IHDStructureGridPoint">
            <summary>
            A Q grid point containing a structure.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint">
            <summary>
            A Q grid point containing a composit structure.
            
            TODO: Figure out which of HDQGridPoint properties that should be overridden
            and which that are not valid for a HDStructureGridPoint
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint.GridPoint">
            <summary>
            Gridpoint of structure
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint.GetState">
            <summary>
            Returns the current state of the component
            </summary>
            <returns>Current state</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Called during the prepare step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint.PrepareForTimeStep(System.Int32)">
            <summary>
            Transfer the N+1 state to the N state, preparing for next timestep
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleHD.HDStructureGridPoint.CalculateSteadyInit(DHI.Mike1D.Engine.EngineTime,System.Double,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculate initial guess for steady iteration. Needed for steady state computations.
            <para>
            For structures, it is difficult to do anything but look at the invert levels. 
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNetMPIFactory">
            <summary>
            Factory Class for creating engine classes.
            <para>
            NOTE: This should be the only component depending on the dataaccess components,
            especially the NetworkDataAccess classes.
            </para>
            <para>
            If desired, this can be moved to another project, to remove dependencies 
            from EngineNetwork to DataAccess components.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNetMPIFactory.EngineGlobalNet">
            <summary>
            The created EngineNet
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetMPIFactory.CreateEngineMPINetwork(System.String,DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics,DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Create a new EngineNet stored in <see cref="T:DHI.Mike1D.Engine.EngineNet"/> and
             initialise it using the Network, HD parameters and CrossSections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetMPIFactory.DecompositionNodeAndReachList">
            <summary>
            Domain decomposition using METIS 
            
            </summary>
            <returns>
            A list representing which nodes/reaches is associated with which domain
            </returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxy">
            <summary>
            Implementation of LTSCalculator, which uses ProxyUtil to obtain quantity getters used by LTSEvents.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxy.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxy.PerformActionForNode(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxy.PerformActionForGridPoint(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Engine.GridPoint)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD">
            <summary>
            Defines LTSCalculators for AD components.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.ExtraForQuantity">
            <summary> Extra string added to the end of the quantity id and description </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.InitializeComponentCalculators">
            <summary> Initializes the calculators for AD components. </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.GetProxyQuantityForComponent(DHI.Mike1D.ADDataAccess.ADComponent,DHI.Mike1D.Generic.PredefinedQuantityAD)">
            <summary>
            Creates a quantity for proxy system from template quantity and AD component.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.CreateComponentCalculator(DHI.Mike1D.ResultDataAccess.LTSResultQuantity,System.Int32)">
            <summary>
            Creates component calculator from engine proxy system.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.PopulateCalculator(DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.GetLargestNumberOfEvents">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.InitializeSimulation(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.UpdateValues(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.FinalizeJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyAD.FinalizeSimulation">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyTotal">
            <summary>
            Creates LTSCalculator, which sums up output from parts of the network given by resultQuantity.Filter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyTotal.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyTotal.CreateGetterForNode(DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyTotal.PerformActionForNode(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyTotal.PerformActionForGridPoint(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Engine.GridPoint)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyTotalAD">
            <summary>
            Creates LTSCalculators for all AD components, which sums up output from parts of the network given by resultQuantity.Filter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyTotalAD.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorFromProxyTotalAD.CreateComponentCalculator(DHI.Mike1D.ResultDataAccess.LTSResultQuantity,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission">
            <summary>
            Defines LTSCalculators for outflow and emission out of the system.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.InitializeHD">
            <summary> Initializes HD calculators </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.InitializeAD">
            <summary> Initializes AD calculators </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.CreateCalculators(DHI.Mike1D.ADDataAccess.ADComponent)">
            <summary>
            Creates total outflow LTS calculators for HD simulation or a given AD component.
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.PopulateCalculator(DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.GetLargestNumberOfEvents">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.InitializeSimulation(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.UpdateValues(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.FinalizeJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflowAndEmission.FinalizeSimulation">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflow">
            <summary>
            Defines LTSCalculators for outflow of the system.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflow.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalOutflow.PopulateCalculator(DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalEmission">
            <summary>
            Defines LTSCalculators for total emission out of the system.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalEmission.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalEmission.InitializeComponentCalculators">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculatorTotalEmission.PopulateCalculator(DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.NetworkIterator">
            <summary>
            Base class for iterating over the network, i.e., nodes, reaches, and gridpoints.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.NetworkIterator.#ctor(DHI.Mike1D.Engine.EngineNet)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator">
            <summary>
            A base class for LTS result calculations.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.NetworkData">
            <summary>
            LTSEvents data stored on the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.PopulateCalculator(DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <summary>
            Populates calculator with LTSEvents.
            The relevant event specifications (filter, event limit, etc.) are taken from resultQuantity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.InitializeSimulation(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.UpdateValues(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.FinalizeJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.FinalizeSimulation">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.RegisterUpdater(DHI.Mike1D.Engine.ModuleLTS.IUpdatableLTS)">
            <summary>
            Register an item as a pull data item
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSCalculator.GetLargestNumberOfEvents">
            <summary>
            Determines the largest number of events among all LTSEvents.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSEvent">
            <summary>
            An LTS event start time and value
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleLTS.LTSEvent.Time">
            <summary> Time </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleLTS.LTSEvent.Value">
            <summary> Value </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSEventPeriodic">
            <summary>
            An LTS period event start time and (integrated) value and also duration and numberof events.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleLTS.LTSEventPeriodic.NumberOfEvents">
            <summary> Number of events in period </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleLTS.LTSEventPeriodic.Duration">
            <summary> Duration of events in period </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSEvents">
            <summary>
            List of LTS events. An event is a set of values with a time stamp. This class is abstract, and
            the calculation of the values in the events is performed in the purely abstract function UpdateValues().
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.Events">
            <summary> List of LTS events. </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.#ctor(System.Int32,System.TimeSpan,System.Double)">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.Getters">
            <summary>
            Getters which define the current value when calculating an event.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.EventLimit">
            <summary>
            The maximum number of events that will be written to the result file.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.IntereventTime">
            <summary>
            Two successive events are independent if the time between the two events
            is larger than Interevent Time.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.IntereventLevelCriterion">
            <summary>
            Two successive events are independent if the level between the events becomes smaller
            than IntereventLevelCriterion times the lower value of the two events.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.ZeroLevel">
            <summary> Reference level for application of IntereventLevelCriterion. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.ZeroFlow">
            <summary> Zero flow tolerance. </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.InitializeSimulation(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.UpdateValues(System.DateTime)">
            <summary>
            Calculates the values in the events.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.FinalizeJob">
            <summary>
            Commits the last value in the LTS job.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.FinalizeSimulation">
            <summary>
            Commits the last value in the LTS simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.Add(System.DateTime,System.Double)">
            <summary>
            Add an event with a single value to the list.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.Add(System.DateTime,System.Double,System.Int32,System.Double)">
            <summary>
            Add an event with three values to the list.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.Sort(DHI.Mike1D.ResultDataAccess.EventSortType)">
            <summary>
            Sort the event list based on given EventSortType.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.SortOnTime">
            <summary>
            Sort the event list on time stamps.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.SortOnValue">
            <summary>
            Sort the event list on the first value of each event
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEvents.CompareValue(DHI.Mike1D.Engine.ModuleLTS.LTSEvent,DHI.Mike1D.Engine.ModuleLTS.LTSEvent)">
            <summary>
            Sort on first value, and if the same, then on time.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSEventsMax">
            <summary>
            LTS event calculator for maximum value.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsMax.#ctor(System.Int32,System.TimeSpan,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsMax.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsMax.UpdateValues(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsMax.FinalizeJob">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegrated">
            <summary>
            LTS event calculator for total integrated value over the whole event.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegrated.#ctor(System.Int32,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegrated.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegrated.UpdateValues(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegrated.FinalizeJob">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSEventsDuration">
            <summary>
            LTS event calculator for event duration.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsDuration.#ctor(System.Int32,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedAnnual">
            <summary>
            LTS event calculator for total integrated value over one year.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedAnnual.#ctor(System.Int32,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedAnnual.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedAnnual.UpdateValues(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedAnnual.FinalizeJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedAnnual.FinalizeSimulation">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedAnnual.FillInMissingPeriods">
            <summary>
            Fills in events with zero values for skipped years in LTS simulation.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedMonthly">
            <summary>
            LTS event calculator for total integrated value over one month.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedMonthly.#ctor(System.Int32,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedMonthly.IsDifferentPeriod(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedMonthly.GetPeriodValue(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSEventsIntegratedMonthly.FillInMissingPeriods">
            <summary>
            Fills in events with zero values for skipped months in LTS simulation.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.Res1dWriter">
            <summary>
            Writer of LTS results to binary res1d file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.Res1dWriter.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.ResultData,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.Res1dWriter.WriteResultFile(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Writes a res1d file. Information about file is contained in ResultData.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.Res1dResultDataWriter">
            <summary>
            Writer of LTS results to ResultData for particular LTSCalculator.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.Res1dResultDataWriter.#ctor(DHI.Mike1D.Engine.ModuleLTS.LTSCalculator,DHI.Mike1D.Engine.EngineNet)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.IUpdatableLTS">
            <summary>
            Interface for updatable object during LTS simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.IUpdatableLTS.InitializeSimulation(System.DateTime,System.DateTime)">
            <summary>
            Initializes LTS simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.IUpdatableLTS.Prepare">
            <summary>
            Prepares for LTS job simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.IUpdatableLTS.UpdateValues(System.DateTime)">
            <summary>
            Updates values after a time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.IUpdatableLTS.FinalizeJob">
            <summary>
            Finalizes LTS job.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.IUpdatableLTS.FinalizeSimulation">
            <summary>
            Finalizes LTS simulation.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.LTSModule">
            <summary>
            Module for performing Long Term Statistics (LTS) simulations.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSModule.Id">
            <summary> Id of module </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSModule.Order">
            <summary>
            Order of module. Modules are processed in order.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.LTSModule.DischargeThreshold">
            <summary>
            Discharge threshold for accumulated event values
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.#ctor(DHI.Mike1D.Engine.EngineNet)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.Inititalize(DHI.Mike1D.Generic.StopwatchCollection)">
            <summary> Initialize module. </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.AddCalculator(DHI.Mike1D.Engine.ModuleLTS.LTSCalculator)">
            <summary>
            Add a calculator to the LTSModule.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.RemoveCalculator(DHI.Mike1D.Engine.ModuleLTS.LTSCalculator)">
            <summary>
            Remove a calculator from the LTSModule.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.GetCalculator(DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Get a calculator present in the LTSModule.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.InitializeSimulation(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.UpdateValues(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.FinalizeJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.FinalizeSimulation">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.LTSModule.CreateCalculators(DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Create calculators from given result specification.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.ERFWriter">
            <summary>
            Writer of LTS results to an ERF file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.ERFWriter.#ctor(DHI.Mike1D.Engine.EngineNet,System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.ERFWriter.WriteResultFile(DHI.Mike1D.Generic.IFilePath)">
            <summary> Write ERF result file. </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleLTS.ERFSectionWriter">
            <summary>
            Writer of single section of LTS results. Used by ERFWriter.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.ERFSectionWriter.Label">
            <summary> Label for event in ERF section. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.ERFSectionWriter.SectionName">
            <summary> ERF section name. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.ERFSectionWriter.Order">
            <summary> ERF sections are printed in this given order. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleLTS.ERFSectionWriter.SortType">
            <summary> Event sorting type: by Value or by Time. </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.ERFSectionWriter.#ctor(DHI.Mike1D.Engine.ModuleLTS.LTSCalculator,DHI.Mike1D.Engine.EngineNet,System.String,System.String,System.Int32,DHI.Mike1D.ResultDataAccess.EventSortType)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleLTS.ERFSectionWriter.WriteEvents(DHI.Mike1D.Engine.ModuleLTS.LTSEvents)">
            <summary>
            Write this event list to a PFS file (MU ERF format)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleRR.RRModule">
            <summary>
            RR module, handling synchronization between RR and HD when running in parallel.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRR.RRModule.Id">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRR.RRModule.Order">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRR.RRModule.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRR.RRModule.PrepareForTimeStep(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRR.RRModule.PerformTimestep">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRR.RRModule.FinalizeTimestep">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRR.RRModule.PreferredTimeStep(System.Boolean,System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRR.RRModule.Finish">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.#ctor">
            <summary>
            Private constructor to support singleton pattern
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.Instance">
            <summary>
            Get the singleton license checker instance
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseChecker">
            <summary>
            Provides access to the DHI license system through LicManCliWrapper2004.dll
            </summary>
            <remarks>
            This class is implemented as internal class in several modules that all require
            license checking functionality. Please update all LicenseChecker classes simultaneously.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseChecker.SelectLicense(System.String)">
            <summary>
            Add a DHI license identifier to the list of license that will be requested.
            </summary>
            <param name="licenseType"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseChecker.RequestLicense(System.Int32)">
            <summary>
            Request licenses. Calls DHI.Generic.MikeZero.License.LicenseWrapper.RequestLicenseWin()
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseChecker.GetMaxNodes">
            <summary>
            Get maximum number of nodes supported by the active license (returns MaxNode1).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseChecker.ConfirmLicense">
            <summary>
            Confirm that all license are still valid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseChecker.ReleaseLicense">
            <summary>
            Release all licenses.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseChecker.GetLicenseErrorDiagnosticsItem(System.Int32)">
            <summary>
            Convert a license error code to an error string
            </summary>
            <param name="rc"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple">
            <summary>
            A wrapper for making procedure calls in the DHI license managment DLL.
            This file is based on DHI.Generic.MIKEZero.LicenseWrapper.cs.
            Compared to that file, the following has been changed:
            1) Thread safety has been removed.
            2) Chaching of license checkout has been removed 
            3) Access to maximum node count information has been added
            
            The changes have been implemented in order to be able to check the same license 
            multiple times (DHI.Generic.MIKEZero.LicenseWrapper.cs has a 1 minute window)
            and point 3 above.
            
            TODO: Revert back to DHI.Generic.MIKEZero.LicenseWrapper.cs and move added functionality from
            here to that file, once it has been tested.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple._ReleaseAllLicensesApp">
            <summary>
            Releases all licenses checked out by the process.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple._ReleaseAllLicensesApp(System.String,System.String)">
            <summary>
            Releases specific licenses checked out by the process.
            </summary>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple._RequestLicenseApp(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.Int32)">
            <summary>
            Requests licenses for the specific module and submodule.
            </summary>
            <param name="rndNum">Random number used for scrambling of data.</param>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
            <param name="versionMajor">Major version number.</param>
            <param name="versionMinor">Minor version number.</param>
            <param name="maxNode1">Unspecified.</param>
            <param name="maxNode2">Unspecified.</param>
            <param name="maxNode3">Unspecified.</param>
            <param name="maxNode4">Unspecified.</param>
            <param name="startTimer">Non-zero, if wait-timer should be started.</param>
            <returns>0, if the function succeeded, otherwise number indicating error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple.ConfirmAllLicensesWin">
            <summary>
            Verifies, whether all requested licenses are still avialable.
            </summary>
            <returns>0, if all the licenses are still avialable, otherwise number indicating
            error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple.ReleaseAllLicensesWin">
            <summary>
            Releases all licenses checked out by the process.
            </summary>        
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple.ReleaseLicenseWin(System.String,System.String)">
            <summary>
            Releases specific licenses checked out by the process.
            </summary>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>   
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple.RequestLicenseWin(System.Int32,System.String,System.String,System.Int64,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int32)">
            <summary>
            Requests licenses for the specific module and submodule.
            </summary>
            <param name="rndNum">Random number used for scrambling of data.</param>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
            <param name="versionMajor">Major version number.</param>
            <param name="versionMinor">Minor version number.</param>
            <param name="maxNode1">Unspecified.</param>
            <param name="maxNode2">Unspecified.</param>
            <param name="maxNode3">Unspecified.</param>
            <param name="maxNode4">Unspecified.</param>
            <param name="startTimer">Non-zero, if wait-timer should be started.</param>
            <returns>0, if the function succeeded, otherwise number indicating error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LicenseCheckerSingleton.LicenseWrapperSimple.GetMaxNodesByModuleName(System.String,System.Int64@,System.Int64@,System.String@,System.String@)">
            <summary>
             Get maximum number of nodes for a specified license.
            </summary>
            <param name="moduleName"></param>
            <param name="maxNode1"></param>
            <param name="maxNode2"></param>
            <param name="maxNode3"></param>
            <param name="maxNode4"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.IBedLoadCalculator">
            <summary>
            Bed load calculator interface, can calculate bed load
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.IBedLoadCalculator.CalculateBedLoad">
            <summary>
            Returns bed load in [m^2/s], multiply by storageWidth to get [m^3/s].
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.ISuspendedLoadCalculator">
            <summary>
            Suspended load calculator interface, can calculate equilibrium concentration
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.ISuspendedLoadCalculator.CalculateEquilibriumConcentration">
            <summary>
            Returns equilibrium concentration for suspended load
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LoadCalculatorEngelundFredsoe.CalculateEquilibriumConcentration">
            <summary>
            Calculate equilibrium concentration
            </summary>
            <returns>Equilibrium concentration for suspended load</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LoadCalculatorEngelundHansen.CalculateBedLoad">
            <summary>
            Bed load returned in [m^2/s]
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LoadCalculatorMeyerPeterMuller.CalculateBedLoad">
            <summary>
            Calculate bed load
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LoadCalculatorMeyerPeterMuller.CalculateLoad">
            <summary>
            Calculate load
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.LoadCalculatorVanRijn.CalculateEquilibriumConcentration">
            <summary>
            Calculate equilibrium concentration
            </summary>
            <returns>Equilibrium concentration for suspended load</returns>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.BedLoadCalculators">
            <summary>
            Bed load calculators
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.SuspendedLoadCalculators">
            <summary>
            Suspended load calculators
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STElement.TotalVolumeChange">
            <summary>  Volume change since start of simulation. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.ActiveLayerFraction">
            <summary>
            Percentages of components in active layer, first non-cohesive then cohesive components
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.PassiveLayerFraction">
            <summary>
            Percentages of components in passive layer, first non-cohesive then cohesive components
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STElement.ActiveLayerXsAreaNC">
            <summary>
            Cross section area of non-cohesive sediment in active layer
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STElement.ActiveLayerXsAreaC">
            <summary>
            Cross section area of cohesive sediment in active layer
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STElement.PassiveLayerXsAreaNC">
            <summary>
            Cross section area of non-cohesive sediment in passive layer
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STElement.PassiveLayerXsAreaC">
            <summary>
            Cross section area of cohesive sediment in passive layer
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:DHI.Mike1D.Engine.ModuleST.STElement.BedLayerLayout" -->
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.NonScouringBedLevel">
            <summary>
            Non scouring bed level, ie lowest possible bottom level, cannot erode below this.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.ActiveLayerHeight">
            <summary>
            Current height of active layer
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement._activeLayerHeightEquilibrium">
            <summary>
            Initial/Equilibrium height of active layer
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.SandFraction">
            <summary>
            Percentage of sediment in active layer that is non-cohesive sand (d \leq 1mm)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.MaxConcDueToErosion">
            <summary>
            Maximum concentration due to erosion, default: 50000 g/m^3
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STElement.DeltaZ">
            <summary>
            Approximate change in bottomlevel since beginning of simulation,
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STElement.STActiveSurfaceArea">
            <summary>
            Cross section area
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.d50">
            <summary>
            50th grain size percentile
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STElement.d90">
            <summary>
            90th grain size percentile
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.Initialize(DHI.Mike1D.STDataAccess.STData,DHI.Mike1D.STDataAccess.STCohesiveData,DHI.Mike1D.STDataAccess.STNonCohesiveData,System.Boolean@,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize ST Element. Initialising layers and grain lists.
            </summary>
            <param name="stData"></param>
            <param name="stCohesiveData"></param>
            <param name="stNonCohesiveData"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.BedShearStress">
            <summary>
            BedShearStress calculator
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.AvailableVolumeForComponent(System.Int32)">
            <summary>
            Compute available volume for ST Non-cohesive component based on activelayer height and fraction value
            </summary>
            <param name="componentIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.AvailableVolumeForComponent(System.Boolean,System.Int32)">
            <summary>
            Compute available volume for ST Cohesive or Non-cohesive component
            </summary>
            <param name="isNonCohesive"></param>
            <param name="componentIndex"></param>
            <returns>Available volume for ST component, if -1 unlimited</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.AreaToVolume(System.Double)">
            <summary>
            Convert area to volume
            </summary>
            <param name="area"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.VolumeToArea(System.Double)">
            <summary>
            Convert volume to area
            </summary>
            <param name="vol"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.UpdateActiveLayerArea(System.Boolean,System.Int32,System.Double)">
            <summary>
            Update _activeLayerXsArea for cohesive and non-cohesive components, volume must not be modified from porosity
            </summary>
            <param name="isNonCohesive"></param>
            <param name="ic"></param>
            <param name="bedVolumechange"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.InitializePassiveLayerArea(System.Boolean,System.Int32,System.Double)">
            <summary>
            Initialize _passiveLayerXsArea for cohesive and non-cohesive components
            </summary>
            <param name="isNonCohesive"></param>
            <param name="ic"></param>
            <param name="bedVolumechange"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.UpdateLayers">
            <summary>
            Updates active and passive layers for component when given total volume change. Moves sediment between passive and active layer and updates ative layer height
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.GetWeight(System.Int32)">
            <summary>
            Get active layer fraction and active layer height weight for fraction icST. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.RecomputeFractions">
            <summary>
            Compute distribution of sediment in active and passive layers
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.RecomputeActiveFraction">
            <summary>
            Compute fractions in active layer
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.GetGrainPercentile(System.Double)">
            <summary>
            Get grain percentile from distribution of grains in active layer
            </summary>
            <param name="percentage"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.GetSkinFriction(DHI.Mike1D.STDataAccess.STSkinFrictionType)">
            <summary>
            Get skin friction in point from solving Law of the wall (Parker 2004)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STElement.UpdateGrainSizes">
            <summary>
            Update d_50 and d_90 grain sizes
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.ISTGridPoint">
            <summary>
            ISTGridpoint with bed shear stress calculator, availableVolumeForComponent and IHdhgridpoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.ISTGridPoint.BedShearStress">
            <summary>
            BedShearStress calculator
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.ISTGridPoint.HdhGridPoint">
            <summary>
            Hdh gridpoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.ISTGridPoint.AvailableVolumeForComponent(System.Int32)">
            <summary>
            Available volume for non-cohesive component to erode in one timestep
            </summary>
            <param name="componentIndex"></param>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STGridPoint.HdhGridPoint">
            <inheritdoc/>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STGridPoint.Slope">
            <summary>
            Bed slope used for ST calculations in some models
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STGridPoint.MassN">
            <summary>
            Stored mass in gridpoint in last timestep
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STGridPoint.MassError">
            <summary>
            Mass error for each non-cohesive component
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STGridPoint.StorageWidthNph">
            <summary>
            Current storage width, updated each time step
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STGridPoint._sourceInflowVolPerSecForNCComponent">
            <summary> Source inflow in mass-per-sec for bed load components </summary> // Cohesive and suspended load is handled by AD components. 
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STGridPoint._sourceInflowVolPerSec">
            <summary>
            Source inflow in Vol-per-sec for non-cohesive components
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STGridPoint.SedimentResistance">
            <summary>
            Sediment resistance factor used in MU. Returns computed or specified. Only used for type 1 morphological updating
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.Initialize(DHI.Mike1D.STDataAccess.STData,DHI.Mike1D.STDataAccess.STCohesiveData,DHI.Mike1D.STDataAccess.STNonCohesiveData,System.Boolean@,DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.CalculateBedLoad(System.Int32)">
            <summary>
            Calculate bedload in [m^3/s]
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.AvailableVolumeForComponent(System.Int32)">
            <summary>
            Compute available volume for ST Non-cohesive component based on activelayer height and fraction value or sediment area depending on morph. update method.
            </summary>
            <param name="componentIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.UpdateSurfaceArea">
            <summary>
            Update surface area of grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.UpdateActiveLayerHeight">
            <summary>
            Updates active layer height according to equilibrium layer thickness
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.BedShearStress">
            <summary>
            Compute bed shear stress on st grid point
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.AreaToVolume(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.VolumeToArea(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.CalculateEquilibriumConcentration(System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Calculate equilibrium concentration limited to max. concentration and availability
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.GetRouse(System.Int32)">
            <summary>
            Get Rouse number for fraction
            </summary>
            <param name="icST"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.GetSkinFriction(DHI.Mike1D.STDataAccess.STSkinFrictionType)">
            <summary>
            Get skin friction contribution tau'.
            </summary>
            <param name="vanRijn">Use Van Rijn method for calculating skin friction. </param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.Egiazaroff(System.Double,System.Double)">
            <summary>
            Calculate Egiazaroff modification of critical Shields' parameter
            </summary>
            <param name="diameter"></param>
            <param name="criticalShield"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.GetLaneKalinskeIntegral(System.Double,System.Double)">
            <summary>
            Get value for Lane Kalinske P-function
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.GetEngelundFredsoeIntegral(System.Double,System.Double)">
            <summary>
            Engelund Fredse q_s function
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.GetMass(System.Int32,System.Boolean)">
            <summary>
            Returns non-cohesive stored mass in kg
            </summary>
            <param name="componentIndex"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.AddSourceContribution(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.AddSourceContribution(System.Int32,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.OutflowConcentration(System.Int32)">
            <summary>
            Not supported for ST grid points
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.HandlePointSource(System.Double)">
            <summary>
            Add point source. Input sediment is handled according to capacities. Total sediment amount is distributed between grain sizes and bed/suspended load depending on the carrying capacity.
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STGridPoint.PrepareForTimestep">
            <summary>
            Resets point source contributions
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.IMorphologicalUpdater.UpdateCrossSection(System.Double,DHI.Mike1D.Engine.ModuleST.STReach,DHI.Mike1D.Engine.ModuleST.STGridPoint)">
            <summary>
            Update cross section with total volume change, stReach and stGridPoint
            </summary>
            <param name="totalVolumeChange">Volume change since start of simulation</param>
            <param name="stReach"></param>
            <param name="stGridPoint"></param>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.IMorphologicalUpdater.Type">
            <summary>
            Update type: 
            1: Sewer/pipe
            4: Uniform across cross section, ie. entire cross section is moved up/down
            5: Non-uniform deposit, processed data are updated
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateType4Simple">
            <summary>
            Simple updating of cross section
            Processed data is not updated, instead the datum is updated
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateType4Simple.Type">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateType4Simple.UpdateCrossSection(System.Double,DHI.Mike1D.Engine.ModuleST.STReach,DHI.Mike1D.Engine.ModuleST.STGridPoint)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateSewer">
            <summary>
            Flat sediment surface updating used for pipes/sewers
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateSewer.Type">
            <inheritdoc/>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateSewer._maxFillPercentage">
            <summary>
            Maximum height of sediment in pipe
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateSewer.UpdateCrossSection(System.Double,DHI.Mike1D.Engine.ModuleST.STReach,DHI.Mike1D.Engine.ModuleST.STGridPoint)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateType5">
            <summary>
            Updating with non-uniform deposition of sediment.
            Processed data is updated for each time step based on the original data. The formulas used are inspired by the MIKE11 formulas but
            are otherwise completely based on gut-feeling. Typically used when level of divide is present. Use on own risk!
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateType5.Type">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.MorphologicalUpdateType5.UpdateCrossSection(System.Double,DHI.Mike1D.Engine.ModuleST.STReach,DHI.Mike1D.Engine.ModuleST.STGridPoint)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STModule">
            <summary>
            ST module handles sediment transport
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STModule.NumberOfCohesiveComponents">
            <summary>
            Number of sediment components that are cohesive
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STModule.NumberOfNonCohesiveComponents">
            <summary>
            Number of sediment components that are non-cohesive
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STModule.BedLayerLayout">
            <summary>
            Number of layers in bottom layer model
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STModule.STCohesiveADIndex">
            <summary>
            Index of corresponding AD component for each ST component.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STModule.STNonCohesiveADIndex">
            <summary>
            AD index of non-cohesive sediment components
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STModule.RuntimeDiagnostics">
            <summary>
            Diagnostics instance for the AD module. Used during runtime.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STModule.HDModule">
            <summary>
            HD module instance used in the AD module. Used during runtime.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STModule.BedShearStress">
            <summary>
            Bed shear stress calculator
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetSTNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get ST node from <see cref="T:DHI.Mike1D.Engine.EngineNode"/>, or null if
            ST node is not part of ST model
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STModule.Id">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STModule.Order">
            <summary>
            Order of module. Modules are processed in order. 
            The ST module must run after the AD module. The AD module has order 300.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.PerformTimestep">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.FinalizeTimestep">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.PreferredTimeStep(System.Boolean,System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.Finish">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetProxy(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetProxy(DHI.Mike1D.Engine.EngineReach)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetProxyReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetProxy">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.CalculateGamma0">
            <summary>
            Calculate and tabulate gamma0 for later use.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.CalculateGamma0GarciaParker">
            <summary>
            Calculate and tabulate gamma for garcia parker for later use.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetGamma0(System.Double,System.Boolean)">
            <summary>
            Get gamma_0 for suspended load calculations
            </summary>
            <param name="Z">Rouse number</param>
            <param name="useGarciaParker">Use gamma0 modified for Garcia Parker</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.CalculateLaneKalinskeIntegral">
            <summary>
            Tabulate values for Lane-Kalinske
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetLaneKalinskeIntegral(System.Double,System.Double)">
            <summary>
            x = w_s / u_f
            y = V / u_f
            Returns P(x,y) interpolated from tabulated values.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.CalculateEngelundFredsoeIntegral">
            <summary>
            Tabulate values for Engelund Fredse integral
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.GetEngelundFredsoeIntegral(System.Double,System.Double)">
            <summary>
            x = ln(h/k0)
            y = w_s / u_f
            Returns f(x,y) interpolated from tabulated values.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.WriteState(DHI.Mike1D.ModelState.ModelStateWriter)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STModule.ReadState(DHI.Mike1D.ModelState.ModelStateReader)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.ISTNode">
            <summary>
            Interface for ST Node
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STNode._sourceInflowVolPerSecForNCComponent">
            <summary> Source inflow in mass-per-sec for bed load components </summary> // Cohesive and suspended load is handled by AD components. 
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STNode.SetupReachCoefficients(DHI.Mike1D.Engine.ModuleST.STReachConnection,System.Double,System.DateTime)">
            <summary>
            Set up boundary conditions for this node
            </summary>
            <param name="connection"></param>
            <param name="dt"></param>
            <param name="timeNph"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STNode.AddSourceContribution(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STNode.AddSourceContribution(System.Int32,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STNode.OutflowConcentration(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.CohesiveParameters">
            <summary>
            Helper class with local parameters for each grid point and for each cohesive component.
            <para>
            If no local parameters exist for a given grid point and component,
            a single class of this type with global parameters are reused for all those grid points.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.CohesiveParameters.ErosionCoefficient">
            <summary>
            Erosion coefficient
            Unit: [g/m2/s]
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.CohesiveParameters.#ctor(DHI.Mike1D.STDataAccess.STCohesiveComponent,System.Double)">
            <summary>
            Constructor for setting up global values for component
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.NonCohesiveParameters.BedLoadSmartJaeggiCoefficients">
            <summary>
            Coefficients for Smart-Jaeggi transport formula for bed load:
            a_1 - a_8, ratio d90/d30, angle of repose, use skin friction, use bed slope
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.NonCohesiveParameters.SuspendedLoadSmartJaeggiCoefficients">
            <summary>
            Coefficients for Smart-Jaeggi transport formula for suspended load:
            a_1 - a_8, ratio d90/d30, angle of repose, use skin friction, use bed slope
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.ISTReach">
            <summary>
            ISTReach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.ISTReach.Reach">
            <summary>
            The HD reach which this STReach "covers"
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.ISTReach.ISTGridPoints">
            <summary>
            List of ST grid points
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach">
            <summary>
            Sediment transport reach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STReach.ISTGridPoints">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleST.STReach.Reach">
            <inheritdoc/>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleST.STReach.FaceBedLoad">
            <summary>
            Bed load on each face for all fractions, in [m3/s]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach.OfferCreator">
            <summary>
            Helper class for storing a creator for an offer, including IndexList
            <para>
            If <see cref="F:DHI.Mike1D.Engine.ModuleST.STReach.OfferCreator.IndexList"/> is null, the IndexListH is used.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.#ctor(DHI.Mike1D.Engine.ModuleST.STModule,DHI.Mike1D.Engine.ModuleHD.IHDReach,DHI.Mike1D.Engine.ModuleAD.ADReach,DHI.Mike1D.Engine.ModuleST.STNode,DHI.Mike1D.Engine.ModuleST.STNode)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.GetHDFromSTIndex(System.Int32)">
            <summary>
            From an ad grid point index number, return the index of the HD grid point belonging
            to the ST grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.Initialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize this STReach
            </summary>
            <param name="runtimeDiagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.PrepareLayers">
            <summary>
            Prepare sediment initially available in layers
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.SetConnection(DHI.Mike1D.Engine.ModuleST.STReachConnection)">
            <summary>
            Set a start or end connection
            </summary>
            <param name="connection"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.PrePerformTimestep">
            <summary>
            Reset VolumeChangeTimestep on all STGridpoints on STReach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.PerformMudTimestep(System.Int32)">
            <summary>
            Perform cohesive sediment transport time step
            </summary>
            <param name="ic">Cohesive component index</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.UpdateSlope">
            <summary>
            Calculate and save bed level slope. Used for some formulas (e.g. Smart-Jaeggi)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.SetupReachEndCoefficients(System.Double,System.DateTime)">
            <summary>
            SetupReachEndCoefficients() calls the up- and downstream nodes in order to setup the coefficients
            at both reach ends. The nodes then ask the reach to setup the correct coefficients.
            The reason for this round-about construction is that SetupReachEndCoefficients() is called
            from ADModule before SolveFirstPart() and those two can be run in parallel for all reaches.
            If ADModule was to call ADNode.SetupReachCoefficients() directly to setup all coefficients
            on the reaches around that node, then SetupReachEndCoefficients() and SolveFirstPart() could not
            be run in the same parallel block.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.SetStartBedLoad(System.Double,System.Int32)">
            <summary>
            Set bed load at reach start. 
            </summary>
            <param name="bedLoad"></param>
            <param name="componentIndex"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.SetEndBedLoad(System.Double,System.Int32)">
            <summary>
            Set bed load at reach end
            </summary>
            <param name="bedLoad"></param>
            <param name="componentIndex"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.SetStartBedLoadFreeOutflow(System.Int32)">
            <summary>
            Set bed load for free outflow at reach start
            </summary>
            <param name="componentIndex"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.SetEndBedLoadFreeOutflow(System.Int32)">
            <summary>
            Set bed load for free outflow at reach end
            </summary>
            <param name="componentIndex"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.ValueGetter(System.Int32,System.Int32[]@)">
            <inreritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.ValueSetter(System.Int32,System.Int32[]@)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.Offers">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.Accepts">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach.BedLoadGetter">
            <summary>
            Bed load in [m^3/s]
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.BedLoadGetter.#ctor(DHI.Mike1D.Engine.ModuleST.STReach,System.Int32)">
            <summary>
            Bed load in [m^3/s]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach.SuspLoadGetter">
            <summary>
            Suspended load in [m^3/s]
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.SuspLoadGetter.#ctor(DHI.Mike1D.Engine.ModuleST.STReach,System.Int32,System.Boolean)">
            <summary>
            Suspended load in [m^3/s]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach.TotalLoadGetter">
            <summary>
            Total load in [m3/sec]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach.FractionalConcentrationGetter">
            <summary>
            Suspended concentration in [g/m3] for one fraction
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.FractionalConcentrationGetter.#ctor(DHI.Mike1D.Engine.ModuleST.STReach,System.Int32,System.Boolean)">
            <summary>
            Suspended concentration in [g/m3]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach.SuspLoadIOFGetter">
            <summary>
            Total suspended load of all fractions, in [m3/s] (Integrated Over Fractions)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach.TotalLoadIOFGetter">
            <summary>
            Total load of all fractions, in [m3/s] (Integrated Over Fractions)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReach.ConcentrationIOFGetter">
            <summary>
            Total Suspended concentration in [g/m3], (Integrated Over Fractions)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.CalculateBedLoad(System.Int32,System.Double,DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Calculate bed load capacities.
            </summary>
            <param name="icST">Non-cohesive index</param>
            <param name="dt">Time step length</param>
            <param name="engineTime"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.PerformBedLoadTimestep(System.Int32,System.Double,DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Make bed load timestep
            </summary>
            <param name="icST"></param>
            <param name="dt"></param>
            <param name="engineTime"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.SetupCoefficientsAD(System.Int32,DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Setup coefficients for using the AD module to solve ST transport. Either cohesive or suspended non-cohesive
            </summary>
            <param name="adComponent"></param>
            <param name="time"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.ProcessSuspendedLoadTimestep(System.Int32,System.Double)">
            <summary>
            Post process suspended load time step by calculating erosion and deposition 
            </summary>
            <param name="icST"></param>
            <param name="dt"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.CalculateStartTransportJunctionNode(System.Int32,System.Double,System.Double)">
            <summary>
            Set up mass balance equation and find the transport from node to reach
            that matches this. This will be corrected in <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateZeroNetInflowToVolumeFreeNode"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.CalculateEndTransportJunctionNode(System.Int32,System.Double,System.Double)">
            <summary>
            Set up mass balance equation and find the transport from node to reach
            that matches this. This will be corrected in <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADNode.CalculateZeroNetInflowToVolumeFreeNode"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.UpdateMorphology">
            <summary>
            Update cross section, sediment distribution in bed, and calculate mass error
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.DisplayWarnings(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Display warnings from sediment transport
            </summary>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.CalculateMassError(DHI.Mike1D.Engine.ModuleST.STGridPoint,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Calculate mass error for component. 
            <para>
            Implementation is matching the <see cref="M:DHI.Mike1D.Engine.ModuleAD.ADGridPoint.SetupCoefficientsInside(System.Int32[],System.Double,System.Double)"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.MassBalance(DHI.Mike1D.Engine.ModuleST.STGridPoint,System.Int32,System.Int32,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Returns parts of the mass balance equation for the component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STReach.MassError(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Get mass error
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STStructureParameters">
            <summary>
            Parameters for structures from MIKE Urban
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STStructureReach">
            <summary>
            ST structure reach for transporting sediment through structures
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleST.STStructureReach.SetConnection(DHI.Mike1D.Engine.ModuleST.STStrucConnection)">
            <summary>
            Set a start or end connection
            </summary>
            <param name="connection"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleST.STReachConnection">
            <summary>
            Structure containing STReach and at which end the reach is connected
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ReachCoeffDebugger">
            <summary>
             Debug this module
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ReachCoeffDebugger.sw">
            <summary>
            Output pipe for debugging
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.LeapingWeir">
            <summary>
            A leaping weir is a junction node which connects three reaches.
            The third reach is connected through a bottom opening, named
            a Leaping Weir. If the water runs fast, the water may leap
            over the weir, i.e. the speed of the water will effect
            the flow through the weir.
            <para>
            The weir is characterised by a length (WeirLength) and a width (WeirWidth).
            </para>
            <para>
            Based on the article of Oliveto, Giuseppe. (1998). "Sewerage overflows: new researches on bottom openings and side weirs". Excerpta. 12. 251-281.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.LeapingWeir._sqrtDg">
            <summary> Sqrt of D (maximum width) and g </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.LeapingWeir._phi">
            <summary> Sqrt(WeirWidth) / WeirLength </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.LeapingWeir.WeirLength">
            <summary>
            Length of a leaping weir.
            Unit: [m]
            Default: 0
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.LeapingWeir.WeirWidth">
            <summary>
            Width of a leaping weir.
            Unit: [m]
            Default: 0
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.LeapingWeir.CdaAlpha">
            <summary>
            Alpha in the cda = alpha - beta * psiBeta
            <para>
            Default value is 0.61
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.LeapingWeir.CdaBeta">
            <summary>
            Beta in the cda = alpha - beta * psiBeta
            <para>
            Default value is 0.1
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LeapingWeir.Initialize(DHI.Mike1D.Engine.ModuleHD.IHDStructureNode,DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.LeapingWeir.CalculateDischarge(System.DateTime)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.LeapingWeir.FinalizeTimestep(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis">
            <summary>
            Class performing an initial analysis for a steady state solver.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.MakeInitialAnalysis">
            <summary>
            Initial analysis will analyse the network, find loops etc.
            In case of a simple non-looped network, this will solve
            the steady problem. In case of complex or looped networks
            the initial analysis will make an initial guess for the
            steady solver.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.MakeInitialFlowEstimate(System.Boolean)">
            <summary>
            From inflows, find discharges for reaches
            In case of splits (loops), average the contribution on
            each connection, providing an initial estimate on the discharge.
            From water level boundaries, calculate water levels on each reach 
            using a backwater evaluation based on the discharge estimates.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.MakeInitialFlowGuess">
            <summary>
            Make initial guess on water levels and
            discharges assuming half-full reaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.MakeInitialFlowSmoothing">
            <summary>
            On reaches where end-waterlevel does not match node waterlevel,
            scale the reach water levels down along the reach to match the 
            node water levels
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.ProcessDischargeSplitNodes(System.Collections.Generic.Stack{DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode},DHI.Mike1D.Generic.PriorityQueue{System.Double,DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode})">
            <summary>
            
            </summary>
            <param name="qNodes">Empty stack of nodes, for reuse</param>
            <param name="splitNodesQueue">Split nodes queue</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.ProcessDischargeNodes(System.Collections.Generic.Stack{DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode},DHI.Mike1D.Generic.PriorityQueue{System.Double,DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode})">
            <summary>
            Process all nodes where discharge is known, continuing along reaches, 
            until a node with more than two reaches with unknown discharge (split-nodes) are met.
            This procedure will stop at split-nodes.
            </summary>
            <param name="qNodes">Nodes which are ready for processing</param>
            <param name="splitNodesQueue">Split-nodes for later processing</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.ProcessReachDischarge(System.Collections.Generic.Stack{DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode},DHI.Mike1D.Generic.PriorityQueue{System.Double,DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode},DHI.Mike1D.Engine.ModuleSteady.HDSteadyReachConnection,System.Double,DHI.Mike1D.Engine.ModuleSteady.SteadyStatus)">
            <summary>
            Discharge into reach is known, process discharges to end of reach,
            add the other node to list of qNodes if it is ready for processing after this reach
            was processed.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.CalculateReachDischarge(DHI.Mike1D.Engine.ModuleSteady.HDSteadyReachConnection,System.Double)">
            <summary>
            Calculate discharge in reach. Updates <see cref="T:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach"/> discharges and <see cref="T:DHI.Mike1D.Engine.ModuleHD.HDReach"/>
            discharges from start of reach to end of reach, adding any sources found along the way. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.CalculateReachDischarge(DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach)">
            <summary>
            Calculate discharge from start of reach to end of <see cref="T:DHI.Mike1D.Engine.ModuleHD.HDReach"/>, adding
            any sources found along the way.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyInitialAnalysis.ProcessWaterLevels(DHI.Mike1D.Generic.PriorityQueue{System.Double,DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode},DHI.Mike1D.Generic.PriorityQueue{System.Double,DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode}.Node[])">
            <summary>
            Calculate water levels iteratively from downstream to upstream. 
            <para>
            The nodes in <paramref name="wlNodes"/> are nodes where water levels
            are known (or estimated), and reaches where discharge is known (or estimated) 
            that are connected to those node can be processed.
            </para>
            <para>
            Part of MakeInitialFlowGuess
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode.Discharge">
            <summary> Discharge through node </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode.MaxDeltaWl">
            <summary>
            Maximum water level change in one iteration
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode.WaterLevel">
            <summary> Water level in node </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode.GetReachUnknownQCount">
            <summary>
            Return number of reaches which does not yet have the <see cref="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.HasQ"/> flag
            i.e. reaches where discharge is unknown.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode.GetReachUnknownHCount(System.Int32@,System.Int32@)">
            <summary>
            Return number of reaches which does not yet have the <see cref="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.HasH"/> flag
            i.e. reaches where water level is unknown.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver">
            <summary>
            Class for solving steady state: Given a downstream water level
            and a discharge, calculate the upstream water level.
            <para>
            It uses a Newton-Raphson for the iteration, evaluating the
            derivative numerically.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.DeltaWaterLevel">
            <summary>
            Delta water level, used when numerically calculating
            Q equation residual.
            <para>
            Default value is 0.01 (1 cm)
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.#ctor(DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Create new Q solver
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.Initialize(DHI.Mike1D.Engine.ModuleHD.HDQGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,DHI.Mike1D.Engine.ModuleHD.HDHGridPoint)">
            <summary>
            Prepare solver for a new set of grid points
            </summary>
            <param name="gp">Q grid point</param>
            <param name="hdhPrev">Previous H grid point (lower chainage)</param>
            <param name="hdhNext">Next H grid point (higher chainage)</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.CalculateInitialValue">
            <summary>
            Calculate an initial upstream water level, based on a Manning-like formula 
            when possible (for ordinary grid points) and a "reasonable" value for structure
            grid points.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.Solve">
            <summary>
            Solve for upstream water level for the current set of grid points
            </summary>
            <returns>True if a solution was found (Newton-Raphson converged)</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.Evaluate(System.Double)">
            <summary>
            Evaluate the Q equation residual
            <code>
            res = momentum-term + friction-term + gravity-term - forcing
            </code>
            For structures it will be 
            <code>
            res = Q_calc - Q_in
            </code>
            </summary>
            <param name="usWl">Current value of upstream water level</param>
            <returns>Equation residual</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.EvaluateDerivative(System.Double)">
            <summary>
            Evaluate the Q equation residual derivative, i.e. 
            <code>
            dres/dusWl
            </code>
            For structures it will use the derivative from the structure.
            For ordinary grid points a numerical derivative will be calculated
            (an exact derivative is too complicated to calculate directly)
            </summary>
            <param name="usWl">Current value of upstream water level</param>
            <returns>Equation residual derivative</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.NewValueAction(System.Double,System.Double)">
            <summary>
            Method that is called everytime the NewtonRaphson procedure
            calculates a new water level. Must assure that water never 
            goes below bottom level, and can also be used to stabilize
            </summary>
            <returns>New or corrected new value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver.NewValueStructureAction(System.Double,System.Double)">
            <summary>
            Method that is called everytime the NewtonRaphson procedure
            calculates a new water level. Must assure that water never 
            goes below bottom level, and can also be used to stabilize
            </summary>
            <returns>New or corrected new value</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule">
            <summary>
            Steady state module.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.#ctor(DHI.Mike1D.Engine.ModuleHD.HDModule)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.Id">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.Order">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.Time">
            <summary>
            Simulation time
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.EngineNet">
            <summary>
            Engine net
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.Setup">
            <summary>
            Setup module
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.PrepareForTimeStep(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.PerformTimestep">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.FinalizeTimestep">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.PreferredTimeStep(System.Boolean,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.Finish">
            <summary>
             Release any license and clean up
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.FindInflowNodes">
            <summary>
            Find all boundary nodes that has inflow (inflow and closed)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadyModule.CalculateSteadyWl(System.Boolean,DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach,DHI.Mike1D.Engine.ModuleSteady.HDSteadyQSolver,DHI.Mike1D.Engine.EngineTime,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Calculate water level in reach from downstream to upstream 
            (end to start of reach, unless <paramref name="reverse"/> flag is set)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.HasStructures">
            <summary> Bool indicating if reach has structures </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.IsStructureReach">
            <summary> Bool indicating if reach is a structure reach with just one Q grid point </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.HasQ">
            <summary> Bool indicating if Q has been determined for this reach </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.HasH">
            <summary> Bool indicating if H has been determined for this reach </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.StartDischarge">
            <summary> Discharge into start of reach </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.EndDischarge">
            <summary> Discharge out of end of reach </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach.CalcReverseDirection">
            <summary> 
            Flag indicating if discharge calculation is in reverse direction (from start to end, low to high chainage).
            Default direction is from end to start (high to low chainage).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.PrepareSolve">
            <summary>
            Store current state (Np1) to old state (N)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.EvaluateReachSolution(System.Double[])">
            <summary>
            From solution on node, put back solution on 
            reach grid points
            </summary>
            <param name="sol">Array with solution on nodes</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.LimitDeltaWl(DHI.Mike1D.Engine.ModuleSteady.HDSteadyNode,System.Double@)">
            <summary>
            Limit the change in water levels for a single grid point, to minimize effect of instabilities.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.LimitDeltaWlGp(DHI.Mike1D.Engine.ModuleHD.HDHGridPoint,System.Double@,DHI.Mike1D.HDParameterDataAccess.SolverSettings)">
            <summary>
            Limit the change in water levels for a single grid point, to minimize effect of instabilities.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.SetupReachCoefficients(DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach)">
            <summary>
            Sets up coefficients for a reach, i.e. equations for
            every Q grid point.
            </summary>
            <param name="reach"></param>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.ChainType.alpha">
            <summary> 
            An alpha chain is eliminated from end to start
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.ChainType.gamma">
            <summary> 
            A gamma chain is eliminated from start to end
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.ChainType.zero">
            <summary> 
            A zero chain can not be processed further
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.ChainType.free">
            <summary> 
            A free chain has one degree of freedom
            i.e. 2 h points and 1 q-equation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleSteady.HDSteadySystemSetup.IdentifyChains(DHI.Mike1D.Engine.ModuleSteady.HDSteadyReach)">
            <summary>
            Identify chains of Q-equations within a branch that 
            depends on each other. 
            <para>
            Chains only occur in case of structures that decouple
            the upstream and downstream water level (critical flow or fixed flow (pumps))
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.NodeMaxInflowReservoir">
            <summary>
            A functionality to node to limit total inflow from surface. 
            Total inflow in m3/s, from multiple sources.
            <para>
            The class handles two types of inflow, surface inflow and catchment runoff inflow.
            The procedure models that the catchment runoff inflow "runs through" the surface model
            before entering the node.
            </para>
            <para>
            Excess catchment runoff (larger than the <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.MaxInflowFromSurface"/>)
            is retained in the <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.WaterVolumeInReservoir"/> ([m3]).
            
            When a surface model is present, the coupling procedure must transfer the reservoir volume to 2D model
            and empty this reservoir by calling <see cref="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.EmptyReservoir"/>.
            </para>
            <para>
            The net inflow to the combined system is CatchmentQ. On top of that there may be an exchange
            of water between 1D and 2D. The CatchmentQ is split into three parts
            <code>
            CatchmentQ = <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ActualCatchmentInflow"/> + <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.CatcmentQRoutedToSurface"/> + <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.WaterVolumeInReservoir"/>/dt
            </code>
            where 1) goes into the network, 2) is routed to the surface (when surface model is present), and 3) is what is left due to max inflow limit.
            </para>
            <para>
            Inflow to MIKE 1D:
            <code>
            q_in_1D = <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ActualSurfaceInflow"/> + <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ActualCatchmentInflow"/>
            </code>
            
            Inflow to 2D:
            <code>
            q_in_2D = -<see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ActualSurfaceInflow"/> + <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.CatcmentQRoutedToSurface"/> + <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.WaterVolumeInReservoir"/>/dt
            </code>
            
            </para>
            </summary>
            <remarks>
            The following rules apply:
            <list type="bullet">
            <item>
               Water from surface has "higher" priority than water from catchment
               i.e. water from surface enters the node first, and then water from catchment
               if there is room within the max-inflow limit
            </item>
            <item>
               Only one surface connection is supported, i.e. the surface methods 
               <see cref="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.AddSurfaceContribution(System.Double)"/> and the AD counterparts 
               can only be called once per timestep.
            </item>
            <item>
               Water from surface, when limited, is not added to reservoir, assuming
               surface model has its own reservoir. So the user must keep track of
               what was actually added, by quering <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ActualSurfaceInflow"/>
            </item>
            <item> When inflow is limited, catchment inflow is retained in a reservoir. </item>
            <item> Water from catchment and reservoir are mixing immediately </item>
            <item>
               When coupled to a surface model, you can query the properties of the
               reservoir and empty it, <see cref="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.EmptyReservoir"/>, in order to transfer 
               reservoir content to an external surface model.
            </item>
            <item>
               If surface inflow is negative (outflow from node): inflow is first rerouted from CatchmentInflow (if any), and secondly from node.
            </item>
            <item> AD contributions from surface must be concentrations. </item>
            </list>
              
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._time">
            AD is the reason to only support one surface connection: 
            For an implicit source we do not know up front how much water enters 
            the system, and we would need to store the concentrations from each 
            surface connection in order to get mass balance right.
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._maxInflow">
            <summary> Max inflow limit </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._inflowLimitActive">
            <summary> Flag indicating if max inflow limit is in effect for current time step </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._maxOutflow">
            <summary> Max outflow limit </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._surfaceQ">
            <summary> Inflow from surface </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._surfacedQdh">
            <summary> Inflow from surface, derivative </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._surfaceComponentConcentration">
            <summary> Concentration of components for surface inflow </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._catchmentQRoutedToSurface">
            <summary> Catchment inflow routed to source (outflow) </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._actualSurfaceQ">
            <summary> Actual surface inflow for current time step, different from <see cref="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._surfaceQ"/> 1) if catchment flow is rerouted and 2) when max inflow limit is in effect</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._actualCatchmentQ">
            <summary> Actual catchment inflow for current time step. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._catchmentQ">
            <summary> Amount of discharge entering in this time step </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._componentMassPerSec">
            <summary> Amount of component (mass per sec) in this time step</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._waterVolumeInReservoir">
            <summary> Amount of water retained in reservoir </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._waterVolumeInReservoirNp1">
            <summary> Amount of water retained in reservoir from previous time step </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeMaxInflowReservoir._componentMassInReservoir">
            <summary> Amount of component (mass) retained in reservoir </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.MaxInflowFromSurface">
            <summary> Max inflow limit, handled from <see cref="P:DHI.Mike1D.Engine.EngineNode.MaxInflowFromSurface"/>, modify there to update here </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.MaxOutflowToSurface">
            <summary> Max outflow limit, only applicable when coupled to a surface model. Default value is unlimited outflow (double.MaxValue) </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ActualSurfaceInflow">
            <summary> Actual surface inflow to network for current time step, different from what was set in AddSurfaceContribution when max inflow limit is in effect</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ActualCatchmentInflow">
            <summary> Actual catchment inflow to network for current time step. Limited by <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.MaxInflowFromSurface"/> and may also change due to <see cref="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.CatcmentQRoutedToSurface"/></summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.CatcmentQRoutedToSurface">
            <summary> Catchment inflow routed to source (outflow). Is only positive when also Surface flow is negative (outflow from node),
                      then some (or all) of the catchment flow is routed directly to surface. </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ActualInflow">
            <summary> Actual total inflow to node for current time step</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.WaterVolumeInReservoir">
            <summary> Amount of water retained in reservoir [m3] </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeMaxInflowReservoir.ComponentMassInReservoir">
            <summary> Amount of component (mass) retained in reservoir </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.#ctor(DHI.Mike1D.Engine.ModuleHD.HDNode,System.Double,DHI.Mike1D.Engine.EngineTime)">
            <summary>
            Constructor. 
            </summary>
            <param name="hdNode">Node</param>
            <param name="maxInflow">Maximum inflow in [m^3/s]</param>
            <param name="engineTime"> </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.OutflowConcentration(System.Int32)">
            <summary>
            The outflow concentration, i.e. concentration of flow out of the node.
            </summary>
            <param name="componentIndex">Index of component</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.EmptyReservoir">
            <summary> Empty reservoir </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.AddSourceContribution(System.Double)">
            <summary>
             Add a contribution to the source.
            </summary>
            <param name="q">Value to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.AddSourcePerLengthContribution(System.Double)">
            <summary>
             Add a contribution per length to the source.
            </summary>
            <param name="val">Value per length to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.AddSourcePerAreaContribution(System.Double)">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.AddSourceContribution(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.AddSourceContribution(System.Int32,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.AddSurfaceContribution(System.Double)">
            <summary>
            Add a surface inflow contribution
            <para>
            Note that only one surface connection is supported, so this
            should not be called twice (the second call will override the first)
            </para>
            </summary>
            <param name="q">Discharge</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.AddSurfaceContribution(System.Double,System.Double)">
            <summary>
            Add a surface inflow contribution as an implicit source
            <para>
            Note that only one surface connection is supported, so this
            should not be called twice (the second call will override the first)
            </para>
            </summary>
            <param name="q">Discharge</param>
            <param name="dqdh">Derivative of discharge with respect to water leve in node</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.SetSurfaceConcentration(System.Int32,System.Double)">
            <summary>
            Set concentration of component for surface inflow.
            <para>
            Only used if surface inflow is positive. When negative, water
            flows out with concentration in node.
            </para>
            </summary>
            <param name="componentIndex">Index of component</param>
            <param name="concentration">Concentration of component</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.PrepareForTimeStep(System.Int32)">
            <summary>
            Prepare for time step, resetting time step values
            </summary>
            <param name="redoCount">number of times this time step is redone</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.Update(System.Double)">
            <summary>
            Update, calculate limited inflow to node, and apply HD inflow to node as source
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.EvaluateAndUpdateAD">
            <summary>
            Evaluate actual HD inflow to node, 
            and use actual HD inflow when applying AD inflow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.FinalizeTimestep">
            <summary>
            Finalize time step will update HD and AD reservoirs
            <para>
            This is in a special step. The <see cref="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.Update(System.Double)"/> and <see cref="M:DHI.Mike1D.Engine.NodeMaxInflowReservoir.EvaluateAndUpdateAD"/>
            cannot do so, in case a time step is re-evaluated, storages must remain for re-evaluation.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.SourcePointStoreInflowDecorator">
            <summary>
            Decorate a ISourcePoint with mechanism to store the total inflow
            <para>
            Only works for <see cref="M:DHI.Mike1D.Engine.SourcePointStoreInflowDecorator.AddSourceContribution(System.Double)"/> (total inflow).
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointStoreInflowDecorator.#ctor(DHI.Mike1D.Engine.ModuleHD.HDNode)">
            <summary>
            Constructor. sourcePoint is the decoratoed 
            </summary>
            <param name="hdNode">Point to decorate</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.SourcePointStoreInflowDecorator.Inflow">
            <summary>
            Get inflow to this node that has passed through this decorator
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointStoreInflowDecorator.Reset">
            <summary>
            Reset inflow. Must be called before each timestep
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointStoreInflowDecorator.AddSourceContribution(System.Double)">
            <summary>
             Add a contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointStoreInflowDecorator.AddSourcePerLengthContribution(System.Double)">
            <summary>
             Add a contribution per length to the source.
            </summary>
            <param name="val">Value per length to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointStoreInflowDecorator.AddSourcePerAreaContribution(System.Double)">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.DistanceCalculator">
            <summary>
            Class to calculate distances from a location to any point in the network.
            <para>
            Use <see cref="M:DHI.Mike1D.Engine.DistanceCalculator.CalculateDistances(DHI.Mike1D.Generic.ILocation)"/> to start a calculation, and extract
            data from <see cref="P:DHI.Mike1D.Engine.DistanceCalculator.Distances"/>.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.DistanceCalculator.MaxDistance">
            <summary> Maximum distance from search location to calculate distance.
            Outside this distance, the results in the <see cref="P:DHI.Mike1D.Engine.DistanceCalculator.Distances"/>
            may be double.MaxValue.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.DistanceCalculator.UseSignedDistance">
            <summary>
            Flag specifying whether to calculate signed distances, i.e.
            distance is positive in down-stream direction and negative
            in up-stream direction from location 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.DistanceCalculator.Distances">
            <summary>
            Distances from location to any other node and grid point in the network
            <para>
            The value double.MaxValue is used when the node/grid point is more than
            <see cref="P:DHI.Mike1D.Engine.DistanceCalculator.MaxDistance"/> from the location, or if the node/grid-point
            is not reachable from the location
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.DistanceCalculator.#ctor(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Create object working on provided <paramref name="engineNet"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.DistanceCalculator.CalculateDistances(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Calculate distances from location to any other grid point and node
            within the network
            </summary>
            <param name="location">Source location</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.DistanceCalculator.CalculateDistances(DHI.Mike1D.Generic.INetworkLocation)">
            <summary>
            Calculate distances from location to any other grid point and node
            within the network
            </summary>
            <param name="location">Source location</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineStatus">
            <summary>
            State of the simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Created">
            <summary>
            The engine has just been created.
            <para>
            This is the initial state. All data access components are empty or uninitialized. 
            Either load a setup, or manually set it up through the data access components.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Loading">
            <summary>
            The engine is loading a setup.
            <para>
            This status will end in a status change to <see cref="F:DHI.Mike1D.Engine.EngineStatus.Loaded"/> or <see cref="F:DHI.Mike1D.Engine.EngineStatus.Failed"/>.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Loaded">
            <summary>
            The engine has succesfully loaded the setup.
            <para>
            Changes to the data access compenent are allowed in this state.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Validating">
            <summary>
             The engine is validating whether it is setup properly.
             <para></para>
             This status will end in a status change to the state (<see cref="F:DHI.Mike1D.Engine.EngineStatus.Valid"/>) or <see cref="F:DHI.Mike1D.Engine.EngineStatus.Invalid"/>.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Valid">
            <summary>
             The engine is in a valid state, and setup properly. At this point, the engine can be initialized
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Invalid">
            <summary>
             The component is in an invalid state. When updating itself not all required input will be available,
             and/or it will not be able to provide the required output. 
             <para>
             The user can try modify the setup, and then validate again.
             </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Initializing">
            <summary>
            The engine is initializing itself.
            <para>
            This status will end in a status change to <see cref="F:DHI.Mike1D.Engine.EngineStatus.Initialized"/> or <see cref="F:DHI.Mike1D.Engine.EngineStatus.Failed"/>.
            </para>
            <para>
            During the initializing state the engine will initialize the static part of the engine, set up
            the computational network.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Initialized">
            <summary>
            The engine has succesfully initialized itself. 
            <para>
            All static data structures have been created. It is possible to query the engine 
            for the computational network and connect to offered/accepted quantities.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Preparing">
            <summary>
             The engine is preparing itself for running the simulation.
             <para>
             This state will end in a status change to <see cref="F:DHI.Mike1D.Engine.EngineStatus.Paused"/> or <see cref="F:DHI.Mike1D.Engine.EngineStatus.Failed"/>.
             </para>
             <para>
             During the preparing state the engine will initialize the dynamic state, set up
             initial conditions, open input and output files.
             </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Running">
            <summary>
             The engine is running.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Paused">
            <summary>
             The engine is paused or not yet started.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Done">
            <summary>
             The engine has performed the simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Finishing">
            <summary>
             The engine is finishing, freeing and cleaning up the dynamic state and 
             closing output files. 
             <para>
             When all required actions have been performed,
             the status changes to <see cref="F:DHI.Mike1D.Engine.EngineStatus.Finished"/>.
             </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Finished">
            <summary>
             The engine has successfully performed its finalization
             actions. 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineStatus.Failed">
            <summary>
             The linkable component has failed in an operation.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineEventArgs">
            <summary>
            Event data for a status changed event.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineEventArgs.Status">
            <summary>
            Status of the engine.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineEventArgs.#ctor(DHI.Mike1D.Engine.EngineStatus)">
            <summary>
            Default constructor
            </summary>
            <param name="status">Status of engine</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.EnginePointSourceRunoffHandler">
            <summary>
            An EnginePointSourceRunoffHandler will distribute/add the runoff source
            to a number of points. 
            <para>
            Special for RR sources, since it can handle different AD concentrations for 
            different runoff discharges (total runoff, surface runoff, interflow runoff, baseflow runoff),
            where only total runoff is actually added to HD as source. The "ordinary" point source handler
            can not do that.
            </para>
            <para>
            The handler contains a list of "source points", one for each source point.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceRunoffHandler.ApplyExternalSource(System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all ISourcePoints
            </summary>
            <param name="time">DateTime to use when getting boundary value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceRunoffHandler.ApplyExternalIntervalSource(System.DateTime,System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all ISourcePoints
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EnginePointSourceRunoffHandler.SourcePointRunoff">
            <summary>
            Class that adds the given source on gridpoints of type HDHGridPoint inside a 
            given span. 
            
            Special for Runoff and runoff component sources, since it can handle different AD concentrations for 
            different runoff discharges types (total runoff, surface runoff, interflow runoff, baseflow runoff) 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceRunoffHandler.SourcePointRunoff.AddSourceRunoffContribution">
            <summary>
             Add a rainfall runoff contributionsource. The surface area of the river is subtracted
             from the area available for runoff. 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineRoutingElement">
            <summary>
            A routing element spans from the previous element location to this element location, 
            or if no previous element, then the start of the reach.
            <para>
            Within a routing element the incoming discharge can be routed by different methods
            specified in the <see cref="P:DHI.Mike1D.Engine.EngineRoutingElement.RoutingMethod"/>. All incoming discharge into the element
            is routed by the method (i.e. an inflow point source will have the same effect
            regardless of where in the routing element it is connected).
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineRoutingElement.Location">
            <summary>
            Location of the routing element end point
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineRoutingElement.Description">
            <summary>
            User's descriptive information related to the routing element
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineRoutingElement.RoutingMethod">
            <summary>
            Routing method
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineRoutingElement.RoutingElevation">
            <summary>
            Type of elevation evaluation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineRoutingElement.MuskingumK">
            <summary>
            Muskingum K parameter
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineRoutingElement.MuskingumX">
            <summary>
            Muskingum X parameter
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineRoutingElement.QhTable">
            <summary>
            Qh table (actually a h-Q table) for calculating water levels from discharges
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineRoutingElement.ToString">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineRoutingElement.CreateDefaultElement(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Create a default routing element, utilizing direct routing. 
            </summary>
            <param name="location">Location of the routing element</param>
            <returns>New default routing element</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase">
            <summary>
            Base class for applying runoff sources to network.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.ComponentValuesSource">
            <summary>
            Helper structure to store precalculated values for a component
            that is used for every grid point.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.ComponentValuesSource.LoadValues">
            <summary> Bool indicating if Value is load or concentration </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.ComponentValuesSource.LoadFraction">
            <summary> Fraction of component originating from a specific load item </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.RainComponentValueSource">
            <summary>
            Helper structure to store precalculated values for a component
            that is used for every grid point - for NetRainfall components.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.RainComponentValueSource.ComponentIndex">
            <summary> AD component index </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.RainComponentValueSource.Value">
            <summary> Value in unit of AD/ST component (hence no unit conversion is required) </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.RainComponentValueSource.ValueGetter">
            <summary> Getter for <see cref="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.RainComponentValueSource.Value"/> </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.RainComponentValueSource.UpdateValue(System.DateTime)">
            <summary>
            Update <see cref="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.RainComponentValueSource.Value"/>.
            </summary>
            <param name="time"></param>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.DischargeGetter">
            <summary> Getter for TotalRunoff or CatchmentDischarge </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.NetRainfallGetter">
            <summary> Getter for NetRainfall - null when this is used for CatchmentDischarge, or when RemoveOverlappingRiverArea is false </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.DischargeModifier">
            <summary> Modifier for TotalRunoff or CatchmentDischarge - for DA pertubations of TotalRunoff or CatchmentDischarge </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase._totalRunoffRaw">
            <summary> Runoff before modifier is applied. Required to calculate component concentrations from loads </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase._totalRunoff">
            <summary> Runoff after modifier is applied </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.RainComponentValueArray">
            <summary> Concentrations for rain. null if not active (no AD, no rain or no components for rain) </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineSourceRunoffHandlerBase.UpdateCatchmentValues(System.DateTime)">
            <summary>
            Update buffer values for both HD and AD.
            </summary>
            <param name="time"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory">
            <summary>
            Factory class for setting up flood map files
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.#ctor(DHI.Mike1D.Generic.StopwatchCollection,System.String,DHI.Mike1D.Generic.IFilePath)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.CreateFloodMap(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IFilePath,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Create and setup up flood map files.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.Finish">
            <summary>
            Finish flood map, close output files etc.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.CreateRiverSpan(DHI.Mike1D.Engine.EngineReach,System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{DHI.Mike1D.Engine.EngineReach,System.Collections.Generic.List{DHI.Mike1D.Engine.FloodMaps.RiverSpanHPoint}}},DHI.Mike1D.Engine.HGridPoint)">
            <summary>
            Create a river span from the provided h gridpoint to the next h grid point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.GetClosestUpstreamGridPoint(System.Collections.Generic.List{DHI.Mike1D.Engine.FloodMaps.RiverSpanHPoint},System.Double,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Boolean)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location upstream.
            <para>
            It is assumed that the EngineReach max and min chainages
            are containing the given chainage, otherwise null is returned.
            </para>
            </summary>
            <param name="gridPoints">List of grid points to search in</param>
            <param name="chainage">Chainage value to start search at</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <param name="allowExact">Boolean specifying whether if a grid point is found at exactly the chainage value is to be included in the search.</param>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.GetClosestDownstreamGridPoint(System.Collections.Generic.List{DHI.Mike1D.Engine.FloodMaps.RiverSpanHPoint},System.Double,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Boolean)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location upstream.
            <para>
            It is assumed that the EngineReach max and min chainages
            are containing the given chainage, otherwise null is returned.
            </para>
            </summary>
            <param name="gridPoints">List of grid points to search in</param>
            <param name="chainage">Chainage value to start search at</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <param name="allowExact">Boolean specifying whether if a grid point is found at exactly the chainage value is to be included in the search.</param>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.AddMbQuads(DHI.Mike1D.Engine.FloodMaps.MappingBox,System.Boolean,DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.MapBoxPoint,DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.MapBoxPoint)">
            <summary>
            Add mapping box quads on either left or right side of river center line.
            <para>
            When the first degenerate mapping quad is found, the procedure stops.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.Distance(DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate)">
            <summary>
            Calculate Distance between two coordinates 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.GridpointHXsNotInterpolated(DHI.Mike1D.Engine.GridPoint)">
            <summary>
            Predicate that accepts an HGridPoint with a non-interpolated BaseCrossSection
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.GetLeftRightBankV(DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.MapBoxPoint)">
            <summary>
            Get the relative position of the bank marker. Sets relative position to 1
            if bank markers are not defined.
            </summary>
            <param name="cs">Cross section</param>
            <param name="mbPoint">MapBoxPoint to store values in</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.GetLeftRightCoordinates(DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,DHI.Mike1D.Generic.Spatial.Geometry.Vector,DHI.Mike1D.Engine.FloodMaps.RiverSpanHPoint,DHI.Mike1D.Engine.FloodMaps.RiverSpanHPoint,DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.MapBoxPoint)">
            <summary>
            Returns two list of coordinates, for the left and right side of the river.
            </summary>
            <param name="point">Coordinate at current point</param>
            <param name="directionUnitVector">Direction of reach at current point</param>
            <param name="upHPoint">H point upstream of point with cross section</param>
            <param name="doHPoint">H point downstream of point with cross section</param>
            <param name="mbPoint">Map box point to store data at</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.Interpolate(System.Collections.Generic.List{DHI.Mike1D.Generic.Spatial.Geometry.Coordinate},System.Collections.Generic.List{DHI.Mike1D.Generic.Spatial.Geometry.Coordinate},System.Double,System.Int32,System.Int32,System.Collections.Generic.List{DHI.Mike1D.Generic.Spatial.Geometry.Coordinate}@)">
            <summary>
            Interpolate up and downstream coordinates, store result in <paramref name="coords"/>
            </summary>
            <param name="upCoords">Upstream coordinates</param>
            <param name="doCoords">Downstream coordinates</param>
            <param name="factor">Factor between up and downstream coordinates</param>
            <param name="first">First coordinate</param>
            <param name="last">Last coordinate</param>
            <param name="coords">List to store new coordinates to</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.GetLeftRightCoordinatesOnXs(DHI.Mike1D.Engine.FloodMaps.RiverSpanHPoint,DHI.Mike1D.CrossSectionModule.ICrossSection,System.Collections.Generic.List{DHI.Mike1D.Generic.Spatial.Geometry.Coordinate}@,System.Collections.Generic.List{DHI.Mike1D.Generic.Spatial.Geometry.Coordinate}@,System.Int32@,System.Int32@)">
            <summary>
            Returns two list of coordinates, for the left and right side of the river, at the provided
            cross section.
            </summary>
            <param name="riverSpanHPoint">H point</param>
            <param name="cs">Cross section to get coordinates from</param>
            <param name="leftCoords">Coordinates on left side of river, ordered from center and out</param>
            <param name="rightCoords">Coordinates on right side of river, ordered from center and out</param>
            <param name="leftBankIndex">Index of left bank coordinate, size of leftCoords if not defined</param>
            <param name="rightBankIndex">Index of right bank coordinate, size of leftCoords if not defined</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.Validate(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Validate setup for use with flood maps
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFactory.Validate(DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Validate a single cross section for use with flood maps
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.FloodMapFile">
            <summary>
            Class that handles one DFS2 file with flood map information
            </summary>
            <remarks>
            It stores a list of active grid cells which are those being updated
            whenever new data is available. All other grid cells will have delete-values
            written.
            <para>
            The calculation of values are handled by an <see cref="T:DHI.Mike1D.Engine.FloodMaps.IFloodMapCalculator"/>
            that for a given item retrieves/calculates the values from the engine.
            </para>
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.FloodMapFile._projectionRotation">
            <summary> True if rotation is from projection north, false if rotation is from true north </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.#ctor(DHI.Mike1D.HDParameterDataAccess.MapOutputFile,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IFilePath,DHI.Mike1D.Generic.StopwatchCollection)">
            <summary>
            Create new flood map file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.Finalize">
            <summary>
            Finish, close file etc. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.Initialize(DHI.Mike1D.Generic.Spatial.QuadSearchTree{DHI.Mike1D.Engine.FloodMaps.MappingBox})">
            <summary>
            Initialize flood map file, utilizing mapping box search tree.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.Prepare">
            <summary>
            Prepare the flood map file. For dynamic output, open the file
            and write initial data to the file. For others, load
            initial data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.Update(System.DateTime)">
            <summary>
            Called every time a time step has completed successfully
            </summary>
            <param name="time">Time of engine</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.Finish">
            <summary>
            For dynamic output, close the file. For the statistical output
            create the file, write data and close the file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.Finish(System.Boolean)">
            <summary>
            For dynamic output, close the file. For the statistical output
            create the file, write data and close the file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.DoStore(System.DateTime)">
            <summary>
            Return a boolean that indicates whether to write the time step or not according to frequency. 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell">
            <summary>
            Structure containg ij linear index, mapbox, (u,v) relative mapping box coordinates and bottom level
            at center of cell.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell.#ctor(System.Int32,System.Boolean,DHI.Mike1D.Engine.FloodMaps.RiverSpan,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Default constructor, setting all values
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell.Ij">
            <summary>
            Element index of the grid-cell, linear index (combined x,y index)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell.Bank">
            <summary>
            Flag specifying whether grid cell is in bank or in main river
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell.ParentRiverSpan">
            <summary>
            River span containing cell(i,j), if contained
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell.U">
            <summary>
            Relative coordinate within river span (between H-points) in main river direction
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell.UpV">
            <summary>
            Relative coordinate within river span in cross sectional direction
            in the upstream direction
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell.DoV">
            <summary>
            Relative coordinate within river span in cross sectional direction
            in the downstream direction
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.FloodMapFile.ActiveGridCell.BottomLevel">
            <summary>
            BottomLevel of river at center of cell
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.FloodMapMinMaxGlobalWlCalculator">
            <summary>
            Class for calculating max wl by utilizing the wlMinMax EngineDataItem, i.e.
            no updates during the simulation.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.FloodMapWaterLevelDepthCalculator">
            <summary>
             Class for calculating wl or depth dynamically
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad">
            <summary>
            A mapping box quadrilateral contains mapping between and (x,y) coordinate
            within the quad to the local coordinate system (u,v).
            <para>
            To handle cases where the mapping box contains bank lines, the relative v 
            coordinate can vary in the upstream and the downstream end.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad.Quad">
            <summary>
            Quadrilateral containing the 4 corner coordinates
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad.Bank">
            <summary>
            Flag specifying wether this mapping box quad is in the main river (false) or the left/right bank.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad.UpVstart">
            <summary>
            Start value of relative v coordinate in upstream end.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad.UpVend">
            <summary>
            End value of relative v coordinate in upstream end.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad.DoVstart">
            <summary>
            Start value of relative v coordinate in downstream end.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad.DoVend">
            <summary>
            End value of relative v coordinate in downstream end.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad.MapXy2Uv(System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>
            Map from (x,y) coordinates to (u,v) coordinates, where
            the v value can vary in the upstream and downstream end.
            </summary>
            <returns>True if mapping succeded</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.MappingBox">
            <summary>
            A mapping box is a box between two cross section lines. The box is split up
            into a number of quadrilaterals, with at least one left and one right of the river center line. 
            The two inner most quads share the river centre line as the baseline, while more outer-laying
            quads share base line with the more inner quad top line.
            <para>
            In cases where the cross section lines intersects, the quads either
            becomes a triangle, or degenerates and must be discarded.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.MappingBox._hgpUFactor">
            <summary> Factor for converting u coordinate in mapping box to u coordinate between nearest H-points </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.MappingBox._hgpUOffset">
            <summary> Offset for converting u coordinate in mapping box to u coordinate between nearest H-points </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.MappingBox.IsActive">
            <summary> Flag specifying whether this mapping box is being used by anyone</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.MappingBox.Quads">
            <summary> List of mapping box quads. Empty if mapping box is invalid in some way.</summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MappingBox.#ctor(DHI.Mike1D.Engine.EngineReach,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MappingBox.#ctor(DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,System.Double,System.Double,DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Constructor - For Test purposes only
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MappingBox.Init">
            <summary>
            iniitalize mapping box
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MappingBox.IsPointInMapBox(System.Double,System.Double)">
            <summary>
            Returns true if (x,y) point is inside mappint box.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MappingBox.GetQuad(System.Double,System.Double)">
            <summary>
            Returns the <see cref="T:DHI.Mike1D.Engine.FloodMaps.MapBoxQuad"/> that contains the (x,y) coordinate,
            or null if none does so.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MappingBox.Distance(DHI.Mike1D.Generic.Spatial.Geometry.Coordinate,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate)">
            <summary>
            Calculate Distance between two coordinates 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.MappingBox.StartChainage">
            <summary>
            Start chainage of mapping box
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.MappingBox.EndChainage">
            <summary>
            End chainage of mapping box
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.MappingBox.Reach">
            <summary>
            Reach that mapping box belongs to
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.MappingBox.Extent">
            <summary>
            Extent of mapping box. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MappingBox.GetHGridpointCrossSectionFactor(System.Double)">
            <summary>
            Interpolation factor between the two h points with cross section, based
            on the factor within the map box, e.g. u from st to uv coordiantes
            </summary>
            <param name="mapBoxFactor">Map box interpolation factor</param>
            <returns>Interpolation factor between two h points with cross sections</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.MappingBox.GetHGridpointFactor(System.Double)">
            <summary>
            Interpolation factor between the two neighbouring h points, based
            on the factor within the map box, e.g. u from <see cref="!:MapSt2Uv"/>
            </summary>
            <param name="u">Map box interpolation factor</param>
            <returns>Interpolation factor between two h points</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.RiverSpanHPoint">
            <summary>
            A river span H point is a structure that contains
            all required information on the H point in the river
            to calculate the transversal geometry of the h-point.
            The H-point itself is missing the exact coordinate and 
            a direction unit vector.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.FloodMaps.RiverSpan">
            <summary>
            A river span is a box between two H points. It can be shared by
            many <see cref="T:DHI.Mike1D.Engine.FloodMaps.MappingBox"/>'s, in case digipoints are present in between
            or close to the two H points.
            <para>
            It contains a lot of the functionality for calculating values 
            (water depth/level etc.) within the span.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.RiverSpan.UpstreamSpanHPoint">
            <summary> Nearest Upstream H point</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.RiverSpan.UpstreamSpanHPointCrossSection">
            <summary> Nearest Upstream H point with a non-interpolated cross section</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.RiverSpan.DownstreamSpanHPoint">
            <summary> Nearest Downstream H point</summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.FloodMaps.RiverSpan.DownstreamSpanHPointCrossSection">
            <summary> Nearest Downstream H point with a non-interpolated cross section</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.RiverSpan.UpstreamHGridPoint">
            <summary> Nearest Upstream H point</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.RiverSpan.UpstreamHGridPointCrossSection">
            <summary> Nearest Upstream H point with a non-interpolated cross section</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.RiverSpan.DownstreamHGridPoint">
            <summary> Nearest Downstream H point</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.RiverSpan.DownstreamHGridPointCrossSection">
            <summary> Nearest Downstream H point with a non-interpolated cross section</summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.FloodMaps.RiverSpan.DirectionUnitVector">
            <summary>
            Direction of the mapping box
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.RiverSpan.GetHGridpointCrossSectionFactor(System.Double)">
            <summary>
            Interpolation factor between the two h points with cross section, based
            on the factor within the map box, e.g. u from <see cref="!:MapSt2Uv"/>
            </summary>
            <param name="mapBoxFactor">Map box interpolation factor</param>
            <returns>Interpolation factor between two h points with cross sections</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.FloodMaps.RiverSpan.GetCrossSectionX(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double)">
            <summary>
            Returns the x coordinate at the relative coordinate v of the cross section
            </summary>
            <param name="cs">Cross section</param>
            <param name="v">Relative coordinate, ranging from -1 to 1</param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ComponentValues">
            <summary>
            Class containing value for a component
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ComponentValues.ComponentIndex">
            <summary>
            Index of component
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ComponentValues.IsLoad">
            <summary>
            Flag indicating if value is a load or a concentration
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ComponentValues.Value">
            <summary>
            Value of component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.#ctor">
            <summary>
            Private constructor to support singleton pattern
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.LicenseCheckerSingleton.Instance">
            <summary>
            Get the singleton license checker instance
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseChecker">
            <summary>
            Provides access to the DHI license system through LicManCliWrapper2004.dll
            </summary>
            <remarks>
            This class is implemented as internal class in several modules that all require
            license checking functionality. Please update all LicenseChecker classes simultaneously.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseChecker.SelectLicense(System.String)">
            <summary>
            Add a DHI license identifier to the list of license that will be requested.
            </summary>
            <param name="licenseType"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseChecker.RequestLicense(System.Int32)">
            <summary>
            Request licenses. Calls DHI.Generic.MikeZero.License.LicenseWrapper.RequestLicenseWin()
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseChecker.GetMaxNodes">
            <summary>
            Get maximum number of nodes supported by the active license (returns MaxNode1).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseChecker.ConfirmLicense">
            <summary>
            Confirm that all license are still valid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseChecker.ReleaseLicense">
            <summary>
            Release all licenses.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseChecker.GetLicenseErrorDiagnosticsItem(System.Int32)">
            <summary>
            Convert a license error code to an error string
            </summary>
            <param name="rc"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple">
            <summary>
            A wrapper for making procedure calls in the DHI license managment DLL.
            This file is based on DHI.Generic.MIKEZero.LicenseWrapper.cs.
            Compared to that file, the following has been changed:
            1) Thread safety has been removed.
            2) Chaching of license checkout has been removed 
            3) Access to maximum node count information has been added
            
            The changes have been implemented in order to be able to check the same license 
            multiple times (DHI.Generic.MIKEZero.LicenseWrapper.cs has a 1 minute window)
            and point 3 above.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple._ReleaseAllLicensesApp">
            <summary>
            Releases all licenses checked out by the process.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple._ReleaseAllLicensesApp(System.String,System.String)">
            <summary>
            Releases specific licenses checked out by the process.
            </summary>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple._RequestLicenseApp(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.Int32)">
            <summary>
            Requests licenses for the specific module and submodule.
            </summary>
            <param name="rndNum">Random number used for scrambling of data.</param>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
            <param name="versionMajor">Major version number.</param>
            <param name="versionMinor">Minor version number.</param>
            <param name="maxNode1">Unspecified.</param>
            <param name="maxNode2">Unspecified.</param>
            <param name="maxNode3">Unspecified.</param>
            <param name="maxNode4">Unspecified.</param>
            <param name="startTimer">Non-zero, if wait-timer should be started.</param>
            <returns>0, if the function succeeded, otherwise number indicating error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple.ConfirmAllLicensesWin">
            <summary>
            Verifies, whether all requested licenses are still avialable.
            </summary>
            <returns>0, if all the licenses are still avialable, otherwise number indicating
            error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple.ReleaseAllLicensesWin">
            <summary>
            Releases all licenses checked out by the process.
            </summary>        
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple.ReleaseLicenseWin(System.String,System.String)">
            <summary>
            Releases specific licenses checked out by the process.
            </summary>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>   
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple.RequestLicenseWin(System.Int32,System.String,System.String,System.Int64,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int32)">
            <summary>
            Requests licenses for the specific module and submodule.
            </summary>
            <param name="rndNum">Random number used for scrambling of data.</param>
            <param name="moduleName">Module name.</param>
            <param name="subModuleName">Submodule name.</param>
            <param name="versionMajor">Major version number.</param>
            <param name="versionMinor">Minor version number.</param>
            <param name="maxNode1">Unspecified.</param>
            <param name="maxNode2">Unspecified.</param>
            <param name="maxNode3">Unspecified.</param>
            <param name="maxNode4">Unspecified.</param>
            <param name="startTimer">Non-zero, if wait-timer should be started.</param>
            <returns>0, if the function succeeded, otherwise number indicating error.</returns>        
        </member>
        <member name="M:DHI.Mike1D.Engine.LicenseCheckerSingleton.LicenseWrapperSimple.GetMaxNodesByModuleName(System.String,System.Int64@,System.Int64@,System.String@,System.String@)">
            <summary>
             Get maximum number of nodes for a specified license.
            </summary>
            <param name="moduleName"></param>
            <param name="maxNode1"></param>
            <param name="maxNode2"></param>
            <param name="maxNode3"></param>
            <param name="maxNode4"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleRouting.RoutingHDElement">
            <summary>
            A routing element spans from 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleRouting.RoutingHDElement.Length">
            <summary>
            Length of routing element
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRouting.RoutingHDElement.Slope">
            <summary>
            Slope of routing element. Used by Muskingum-Cunge method.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleRouting.RoutingHDNode._lateralInflow">
            <summary>
            Inflow into node during this time step
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRouting.RoutingHDNode.Index">
            <summary>
            Index into the list of nodes in the <see cref="T:DHI.Mike1D.Engine.ModuleRouting.RoutingModule"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRouting.RoutingHDNode.GetUpstreamDischarge(System.DateTime)">
            <summary>
            Calculate and return the discharge coming from upstream connections
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleRouting.RoutingHDReach">
            <summary>
            The RoutingHDReach has as many HD routing elements as it has grid points.
            The EngineRoutingReach may have grid points without a routing element
            <para>
            At the grid points which does not have an engine-routing-element, 
            the HD routing elements are set up in a special way.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRouting.RoutingHDReach.StartNode">
            <summary>
            Start node. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRouting.RoutingHDReach.EndNode">
            <summary>
            End Node node.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRouting.RoutingHDReach.DischargeGetter.ElementCount">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRouting.RoutingHDReach.WlGetter.ElementCount">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleRouting.RoutingModule">
            <summary>
            The routing module solves the routing equations on a EngineNet.
            <para>
            RoutingModule also implements the <see cref="T:DHI.Mike1D.Generic.Graph.IGraph"/> interface,
            defining only the part of the routing network in the graph.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleRouting.RoutingModule._reaches">
            <summary>
            List of routing reaches
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ModuleRouting.RoutingModule.Id">
            <inheritdoc />
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleRouting.RoutingModule._reachCalculationOrder">
            <summary>
            The reaches ordered such that the "upstream" reaches
            are before their downstream parts.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.ModuleRouting.RoutingModule._engineToRoutingReach">
            <summary>
            A list matching the reaches in the Enginenet. It is as long as the number
            of EngineReaches, and returns null for those reaches not defined in this
            module.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRouting.RoutingModule.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.StopwatchCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Constructor creating a new RoutingModule and initializing it with the given EngineNet and
            HD parameters.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRouting.RoutingModule.SetupModule">
            <summary>
            Sets up the module, making a state copy of nodes and reaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRouting.RoutingModule.GetRoutingReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Returns the routing reach matching the provided engine reach. If
            not routing reach exist for the engine reach, null is returned.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRouting.RoutingModule.WriteState(DHI.Mike1D.ModelState.ModelStateWriter)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.ModuleRouting.RoutingModule.Finish">
            <summary>
             Release any license and clean up
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ModuleRouting.RoutingModule.GridPointProxy">
            <summary>
            The grid point proxy wraps an RoutingHDElement inside the IDoubleProxy interface
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.SourceInSpanHPoints">
            <summary>
            Class that adds the given source on gridpoints of type HDHGridPoint inside a 
            given span.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceInSpanHPoints._firstHPointIndex">
            <summary> Index of first grid point in reach included in span </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceInSpanHPoints._firstHPointScaleFactor">
            <summary> Fraction of first grid point in reach that is in the span </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceInSpanHPoints._lastHPointIndex">
            <summary> Index of last grid point in reach included in span </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceInSpanHPoints._lastHPointScaleFactor">
            <summary> Fraction of last grid point in reach that is in the span </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceInSpanHPoints._sourceSpanLength">
            <summary> Total span included in source from this reach </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceInSpanHPoints._spanFraction">
            <summary> Fraction of the source span in the total span, in case source is added to more than one reach/span </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceInSpanHPoints.Setup(DHI.Mike1D.Engine.ModuleHD.HDReach,DHI.Mike1D.Engine.ModuleAD.ADReach,System.Double)">
            <summary>
            Setup to include entire span.
            </summary>
            <param name="hdReach"></param>
            <param name="adReach">null if AD is not enabled</param>
            <param name="spanfraction">This spans fraction of the total span that the source is applied to. Set to 1.0 if this is the only span in the source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceInSpanHPoints.Setup(DHI.Mike1D.Engine.ISourcePoint,System.Double)">
            <summary>
            Setup to include entire span.
            </summary>
            <param name="hdReachSourcePoint"></param>
            <param name="spanfraction">This spans fraction of the total span that the source is applied to. Set to 1.0 if this is the only span in the source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceInSpanHPoints.Setup(DHI.Mike1D.Engine.ModuleHD.HDReach,DHI.Mike1D.Engine.ModuleAD.ADReach,DHI.Mike1D.Generic.ILocationSpan,System.Double)">
            <summary>
            Setup to include only part of span
            </summary>
            <param name="hdReach"></param>
            <param name="adReach">null if AD is not enabled</param>
            <param name="reachPartSpan">Must be entirely included in reach.LocationSpan</param>
            <param name="spanfraction">This spans fraction of the total span that the source is applied to. Set to 1.0 if this is the only span in the source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceInSpanHPoints.AddSourceContribution(System.Double,DHI.Mike1D.Engine.ComponentValues[])">
            <summary>
             Add a total contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
            <param name="compValues">AD component values, null if none</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceInSpanHPoints.AddSourcePerLengthContribution(System.Double,DHI.Mike1D.Engine.ComponentValues[])">
            <summary>
             Add a contribution per length to the source.
            </summary>
            <param name="val">Value per length to add to source</param>
            <param name="compValues">AD component values, null if none</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceInSpanHPoints.AddSourcePerAreaContribution(System.Double,DHI.Mike1D.Engine.ComponentValues[])">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
            <param name="compValues">AD component values, null if none</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.SourcePointNodeInfiltrationDecorator">
            <summary>
            Decorate a ISourcePoint with mechanism to limit total inflow to that point. 
            Total inflow is m3/s from multiple sources summed over multiple sources.
            <para>
            Only works for <see cref="M:DHI.Mike1D.Engine.SourcePointNodeInfiltrationDecorator.AddSourceContribution(System.Double)"/> (total inflow).
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointNodeInfiltrationDecorator.#ctor(DHI.Mike1D.Engine.ModuleHD.HDNode)">
            <summary>
            Constructor. sourcePoint is the decoratoed 
            </summary>
            <param name="hdNode">Point to decorate</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointNodeInfiltrationDecorator.AddSourceContribution(System.Double)">
            <summary>
             Add a contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointNodeInfiltrationDecorator.AddSourcePerLengthContribution(System.Double)">
            <summary>
             Add a contribution per length to the source.
            </summary>
            <param name="val">Value per length to add to source</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointNodeInfiltrationDecorator.AddSourcePerAreaContribution(System.Double)">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineRoutingReach">
            <summary>
            A reach that calculates the flow based on some routing scheme instead of a dynamic scheme.
            <para>
            A routing reach contains a number of <see cref="P:DHI.Mike1D.Engine.EngineRoutingReach.Elements"/> which defines routing
            method, and optionally how to calculate water levels. It also contains
            a number of <see cref="T:DHI.Mike1D.Engine.RoutingGridPoint"/> in the <see cref="P:DHI.Mike1D.Engine.EngineReach.GridPoints"/> list.
            There may be more grid points than routing elements.
            </para>
            </summary>
            <remarks>
            An <see cref="T:DHI.Mike1D.Engine.EngineRoutingReach"/> deliberately extends from an EngineReach,
            since the type of reach can not be changed during the simulation.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineRoutingReach.Elements">
            <summary>
            Elements
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineRoutingReach.DivideAt(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Divide reach at <paramref name="location"/>,
            cut away the piece of the reach that is after location and returns the cut
            away piece as a new reach. <paramref name="node"/> is used for connecting the two.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineRoutingReach.CreateNewReach">
            <summary>
            Create new routing reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IEngineTimeCheckPointSet">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.EquidistantTimeCheckPointSet">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EquidistantTimeCheckPointSet.#ctor(System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EquidistantTimeCheckPointSet.#ctor(System.DateTime,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EquidistantTimeCheckPointSet.#ctor(System.DateTime,System.DateTime,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineTimeCheckPointController">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.IEngineTimeStep">
            <summary>
            Interface for controlling the size of the time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IEngineTimeStep.NextTimeStep(System.DateTime)">
            <summary>
            Return the new time step, based on the current time.
            </summary>
            <param name="currentTime">Current time</param>
            <returns>New time step</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.IEngineTimeStep.Reset">
            <summary>
            Reset the time stepping information.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IEngineTimeStepAdaptive">
            <summary>
            Interface for controlling the size of the time step adaptively
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.IEngineTimeStepAdaptive.TimeStepOk">
            <summary>
            Flag indicating if last time step was ok. If not ok, the 
            <see cref="M:DHI.Mike1D.Engine.IEngineTimeStepAdaptive.DecreaseTimeStep(System.DateTime,System.TimeSpan)"/> will be called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IEngineTimeStepAdaptive.DecreaseTimeStep(System.DateTime,System.TimeSpan)">
            <summary>
            Returns a new decreased time step, based on the current time and the current dt.
            <para>
            This method is called when a time step has been rejected and needs to be re-evaluated, 
            hence this method must return a time step that is smaller than the current one.
            </para>
            <para>
            If the <paramref name="currentDt"/> is already the minimum allowed time step, this can
            be returned again.
            </para>
            </summary>
            <param name="currentTime">Current time</param>
            <param name="currentDt">Current dt</param>
            <returns>New time step</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineTimeSteppingConstant">
            <summary>
            Class handling constant time stepping
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingConstant.#ctor(DHI.Mike1D.HDParameterDataAccess.TimeStepping)">
            <summary>
            Create a new time stepping object using the provided time step
            as the constant timestep
            </summary>
            <param name="timeStepping">Timestepping setup</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingConstant.#ctor(System.TimeSpan)">
            <summary>
            Create a new time stepping object using the provided time step
            as the constant timestep
            </summary>
            <param name="timeStep">Constant time step to use</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingConstant.Prepare(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingConstant.Reset">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingConstant.NextTimeStep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineTimeSteppingTabulated">
            <summary>
            Class handling tabulated time stepping
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTimeSteppingTabulated._tabTSItem">
            <summary>
            Date Times Array. From Dfs0 file. Only if TabulatedTS is selected
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingTabulated.#ctor(DHI.Mike1D.Generic.TimeSeries.TsItemDataDouble)">
            <summary>
            Create a new tabulated time stepping class.
            </summary>
            <param name="tabulatedTsItem">Time series to get time step from</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingTabulated.Prepare(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingTabulated.Reset">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingTabulated.NextTimeStep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineTimeSteppingDecoupledFile">
            <summary>
            Class handling time stepping when running HD based on a 
            HD decoupled file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTimeSteppingDecoupledFile.DecoupledFile">
            <summary>
            The decoupled result file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTimeSteppingDecoupledFile.DischargeStepAveraged">
            <summary>
            Indicator of whether HD data uses discharge step averaged.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTimeSteppingDecoupledFile.TimeStepIndex">
            <summary>
            The current index in the decoupled file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingDecoupledFile.Prepare(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingDecoupledFile.Reset">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingDecoupledFile.NextTimeStep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive">
            <summary>
            Class handling adaptive time stepping
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.#ctor(DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Default constructor
            </summary>
            <param name="engineNet">Engine net</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.HDParameterDataAccess.TimeStepping)">
            <summary>
            Default constructor
            </summary>
            <param name="engineNet">Engine net</param>
            <param name="timeStepping">Time stepping parameters</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.SimulationEndTime">
            <summary>
            End of simulation time
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive._maxIncreaseFactor">
            <summary>
            Maximum factor whith which the time step can increase from one time step to the next
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive._maxDecreaseFactor">
            <summary>
            Maximum factor whith which the time step can decrease from one time step to the next
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.AdaptiveSafeFactor">
            <summary>
            Factor to multiply the preferred time step.
            <para>
            1.0 is not optimal, because then too many time steps fail. 
            Tests has indicated values between 0.95 and 0.99 to be optimal 
            for M11 type setups and between 0.8 and 0.9 for MU type setups.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive._minDecreaseFactor">
            <summary>
            Minimum factor with which the time step must decrease when <see cref="M:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.DecreaseTimeStep(System.DateTime,System.TimeSpan)"/>
            is called.
            This is varying during the simulation, getting smaller for every failed time step, and
            being reset for every succeeded time step
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive._preferredBufferFactor">
            <summary>
            Factor to multiply the preferred time step. Always between <see cref="F:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.AdaptiveSafeFactor"/> and 1.0. 
            </summary>
            <remarks>
            1.0 is not optimal, because then too many time steps fail. 
            Preliminary tests indicate something between 0.95 and 0.99 to be optimal 
            for M11 type setups and between 0.8 and 0.99 for MU type setups..
            <para>
            Whenever at time step is rejected, the factor is decreased by 0.01
            though never small than 0.95
            </para>
            <para>
            Whenever at time step is accepted, the factor is increased by 0.0001
            though never higher than 0.99
            </para>
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.UsedFixedChangeFactor">
            <summary>
            Flag indicating whether to use the constant change factor <see cref="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.FixedChangeFactor"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive._fixedChangeFactor">
            <summary>
            Default changefactor with wich the time is updated, in case of <see cref="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.UsedFixedChangeFactor"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.FixedChangeFactor">
            <summary>
            Change factor to multiply or divide the current time step with, in case <see cref="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.UsedFixedChangeFactor"/>
            has been set.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.DtMax">
            <summary>
            Maximum allowed time step
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.DtMin">
            <summary>
            Minimum allowed time step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.Prepare(System.DateTime,System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.Reset">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.NextTimeStep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.GetPreferredModuleTimeStep(System.Boolean,System.TimeSpan)">
            <summary>
            Returns the smallest preferred time step of all engine modules.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.TimeStepOk">
            <summary>
            Flag indicating if last time step was OK.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTimeSteppingAdaptive.DecreaseTimeStep(System.DateTime,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.IGridPoint">
            <summary>
            Interface to GridPoint. If access to GridPoint is needed from outside the network engine,
            then it should happen through this interface.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.IGridPoint.Location">
            <summary>
             Location of grid point
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.IGridPoint.PointIndex">
            <summary>
            Index in list of gridpoints
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineDistributedSourceRunoffHandler">
            <summary>
            An EngineDistributedSourceRunoffHandler will distribute/add the runoff source
            to a number of location spans. 
            <para>
            Special for RR sources, since it can handle different AD concentrations for 
            different runoff discharges (total runoff, surface runoff, interflow runoff, baseflow runoff),
            where only total runoff is actually added to HD as source. The "ordinary" distributed source handler
            can not do that.
            </para>
            <para>
            The handler contains a list of "source points", one for each source span,
            which can cover many grid points, and handles if grid points are only
            partially covered by the source span.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineDistributedSourceRunoffHandler.ApplyExternalSource(System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all ISourcePoints
            </summary>
            <param name="time">DateTime to use when getting boundary value</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineDistributedSourceRunoffHandler.SourceInSpanHPointsRunoff">
            <summary>
            Class that adds the given source on gridpoints of type HDHGridPoint inside a 
            given span. 
            
            Special for Runoff and runoff component sources, since it can handle different AD concentrations for 
            different runoff discharges types (total runoff, surface runoff, interflow runoff, baseflow runoff) 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineDistributedSourceRunoffHandler.SourceInSpanHPointsRunoff.AddSourceRunoffContribution">
            <summary>
             Add a rainfall runoff contributionsource. The surface area of the river is subtracted
             from the area available for runoff. 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineExtensions">
            <summary>
            Class with extensions methods for the engine classes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.Digipoints(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get the digipoints of the reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.Digipoints(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get the ith digipoint of the reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.DirectionUnitVector(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Engine.GridPoint)">
            <summary>
            Calculates the direction vector of the reach at the given gridpoint, 
            as the average from the last to the next gridpoint.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.IsSpillingNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            If node is spilling node, i.e. is a volume node, and has a cover that supports spilling
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.IsRoutingReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Returns true if the engine reach is a routing reach
            </summary>
            <param name="engineReach">Enginereach</param>
            <returns>True if engine is a routing reach</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.IsHdReach(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Returns true if the engine reach is a HD reach
            </summary>
            <param name="engineReach">Enginereach</param>
            <returns>True if engine is a HD</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.IsHDNode(DHI.Mike1D.Engine.EngineNet,System.Int32)">
            <summary>
            Returns true if the engine node at index <paramref name="i"/> is an HD node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.IsHDNode(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Returns true if the engine node is an HD node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.IsPressureNode(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Returns true if the engine node is in a pressurized section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.IsStructureOutlet(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Returns true if the engine node is a structure outlet
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.FindReachWithStructure(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.StructureModule.IStructure)">
            <summary>
            For a given structure, find the reach where it is located. Or null if it is not found.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.GetSurfaceArea(DHI.Mike1D.NetworkDataAccess.BasinGeometry,System.Double)">
            <summary>
            Get surface area of geometry at provided level, by interpolation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.GetSurfaceAreaCone(DHI.Mike1D.NetworkDataAccess.BasinGeometry,System.Double)">
            <summary>
            Get surface area of geometry at provided level, by interpolation of cone/pyramid geometry
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.GetVolume(DHI.Mike1D.NetworkDataAccess.BasinGeometry,System.Double,System.Boolean)">
            <summary>
            Get volume of geometry at provided level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.GetVolumeCone(DHI.Mike1D.NetworkDataAccess.BasinGeometry,System.Double,System.Boolean)">
            <summary>
            Get volume of geometry at provided level, by interpolation of cone/pyramid geometry
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.GetPorosity(DHI.Mike1D.NetworkDataAccess.BasinGeometry,System.Double)">
            <summary>
            Get surface area of geometry at provided level, by interpolation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.FlowIntoNode(DHI.Mike1D.Engine.ModuleHD.IHDReachConnection)">
            <summary>
            Evalueate whether flow is into or out of the node.
            <para>
            When discharge is very small, water level slope is also taken into account.
            </para>
            </summary>
            <returns>True when flow is into node.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.BuildIndexList(DHI.Mike1D.Engine.EngineReach,System.Predicate{DHI.Mike1D.Engine.GridPoint})">
            <summary>
            Return an index list for the reach, containing indices of grid points matching the predicate
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.BuildIndexList(DHI.Mike1D.Engine.EngineReach,System.Boolean,System.Boolean)">
            <summary>
            Build the indexlist for the specified gridpoints
            </summary>
            <param name="reach">The reach to build index list for</param>
            <param name="hPoints">True if H-gridpoints is to be added</param>
            <param name="qPoints">True if Q-gridpoints is to be added</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.BuildIndexList(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Engine.GridPointTypes)">
            <summary>
            Build the indexlist for the specified gridpoints
            </summary>
            <param name="reach">The reach to build index list for</param>
            <param name="gridPointTypes">Types of grid points to include in index list</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.BuildIndexListForEndPoints(DHI.Mike1D.Engine.EngineReach,System.Boolean,System.Boolean)">
            <summary>
            Build the indexlist for the specified gridpoints
            </summary>
            <param name="reach">The reach to build index list for</param>
            <param name="first">True if first gridpoints is to be added</param>
            <param name="last">True if last is to be added</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineExtensions.BuildIndexListForEndPoints(DHI.Mike1D.Engine.EngineReach,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Build the indexlist for the specified gridpoints
            </summary>
            <param name="reach">The reach to build index list for</param>
            <param name="hgp">H grid points, or Q grid points, only applicable for HD reaches</param>
            <param name="first">True if first gridpoints is to be added</param>
            <param name="last">True if last is to be added</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineFindExtensions">
            <summary>
            Extension methods for searching in the engine classes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineFindExtensions.GetClosestUpstreamGridpoint(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.ILocation,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Boolean)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location upstream.
            <para>
            It is assumed that the EngineReach max and min chainages
            are containing the given chainage, otherwise null is returned.
            </para>
            </summary>
            <param name="engineNet">EngineNet to search</param>
            <param name="location">Location to start search at</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <param name="allowExact">Boolean specifying whether if a grid point is found at exactly the chainage value is to be included in the search.</param>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineFindExtensions.GetClosestUpstreamGridpoint(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineReach},System.Double,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Boolean)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location upstream.
            <para>
            It is assumed that the EngineReach max and min chainages
            are containing the given chainage, otherwise null is returned.
            </para>
            </summary>
            <param name="reaches">reaches to search, assuming they share the same reach id</param>
            <param name="chainage">Location to start search at</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <param name="allowExact">Boolean specifying whether if a grid point is found at exactly the chainage value is to be included in the search.</param>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineFindExtensions.GetClosestDownstreamGridpoint(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.ILocation,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Boolean)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location downstream.
            <para>
            It is assumed that the EngineReach max and min chainages
            are containing the given chainage, otherwise null is returned.
            </para>
            </summary>
            <param name="engineNet">EngineNet to search</param>
            <param name="location">Location to start search at</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <param name="allowExact">Boolean specifying whether if a grid point is found at exactly the chainage value is to be included in the search.</param>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineFindExtensions.GetClosestDownstreamGridpoint(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineReach},System.Double,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Boolean)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location downstream.
            <para>
            It is assumed that the EngineReach max and min chainages
            are containing the given chainage, otherwise null is returned.
            </para>
            </summary>
            <param name="reaches">reaches to search, assuming they share the same reach id</param>
            <param name="chainage">Location to start search at</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <param name="allowExact">Boolean specifying whether if a grid point is found at exactly the chainage value is to be included in the search.</param>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineFindExtensions.GetHGridPointSpanningChainage(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineReach},System.Double)">
            <summary>
            Find the H grid point which grid-point-span includes the chainage.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineFindExtensions.GetNextHGridPoint(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineReach},DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Find the next H grid point. It will search in the list of reaches for the next H grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineFindExtensions.GridPointSpanChainageStart(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Start-chainage of the span of the grid point in the index.
            </summary>
            <param name="reach">Reach to examine</param>
            <param name="gpIndex">Grid point index to find span start chainage for.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineFindExtensions.GridPointSpanChainageEnd(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            End-chainage of the span of the grid point in the index.
            </summary>
            <param name="reach">Reach to examine</param>
            <param name="gpIndex">Grid point index to find span start chainage for.</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler">
            <summary>
            Abstract class implementing functionality for a global source and
            overriding spans. 
            
            It does weighting between the global and overriding spans, 
            for gridpoints that span their boundaries, such that the global contribution
            is grid-point independent.
            
            Implement the <see cref="M:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.GetGridpointEnumerator(DHI.Mike1D.Engine.ModuleHD.HDReach)"/> to specify which type of
            gridpoints that is to be iterated over.
            
            TODO: Missing node functionality (adding global source on a node, make a similar
            iterator as <see cref="M:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.GetGridpointEnumerator(DHI.Mike1D.Engine.ModuleHD.HDReach)"/> for the nodes)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler._reachSpanSources">
            <summary>
            Array having number of reaches elements, each being null or a list with overriding span sources 
            Array can be null (no overriding spans anywhere)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler._reachSpanSourcesDictionary">
            <summary>
            Helper dictionary used to loop only over reaches that have sources defined.
            Only used if there are no global sources.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler._sources">
            <summary>
            List of boundarysourcevalues, used when calculating the 
            buffer value in <see cref="F:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.BoundarySourceValue.MainValue"/>
            to only call GetValue once for each boundary source.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.DistributionType">
            <summary>
            Defines how the boundary value is distributed on the
            source point.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.SpanSource">
            <summary>
            helper class containing span and source+bufferValue
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.BoundarySourceValue">
            <summary>
            Helper class containing source and buffer value.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.FindBestGlobalSource(DHI.Mike1D.Engine.ModuleHD.HDGridPoint)">
            <summary>
            Returns the index of the best global source
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.FindBestGlobalSource(DHI.Mike1D.Engine.ModuleHD.HDNode)">
            <summary>
            Returns the index of the best global source
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler.BuildSpanSourceLists(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary)">
            <summary>
            For each reach find all the distributed overrides and add it to the <see cref="F:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler._reachSpanSources"/>.
            The <see cref="F:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler._reachSpanSources"/>[i] will be set to null if reach i has no distributed overrides.
            The <see cref="F:DHI.Mike1D.Engine.HDAbstractGlobalSourceHandler._reachSpanSources"/> it self will be null, if there is not distributed overrides at all.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.HDGlobalSourceOpenHHandler">
            <summary>
            Provides a global source handler adding source to open H points only.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HDGlobalSourceOpenHHandler.CreateOpenHSourceHandler(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleHD.HDModule,DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary)">
            <summary>
            Create a global source handler based on the <see cref="T:DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary"/>, 
            using <see cref="T:DHI.Mike1D.Engine.HGridPoint"/> with an open cross section only.
            
            This must be called after Prepare.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.HDWindSourceHandler">
            <summary>
            Provides a global source handler adding wind force to open q points, i.e.
            when both neighbour H grid points has an open cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HDWindSourceHandler.CreateWindSourceHandler(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleHD.HDModule,DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary)">
            <summary>
            Create a global source handler based on the <see cref="T:DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary"/>, 
            using <see cref="T:DHI.Mike1D.Engine.HGridPoint"/> with an open cross section only.
            
            This must be called after Prepare.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HDWindSourceHandler.ApplySource(DHI.Mike1D.Engine.ModuleHD.HDGridPoint,DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.Spatial.Geometry.Vector)">
            <summary>
            Comments in M11 code by: MOR 9/12-92
            ==================================================================
            Momentum eq:
              dQ/dt + .. .. .. = tau_w * b * cos(v) / rho_w
            rigth hand side is wind friction term
              tau_w : wind friction (N/m2)
              b     : river width (m)
              rho_w : density of water (kg/m3)
            The term is divided by rho_w because all other terms in the mom.
            eq. (in its original form) contained rho_w. Later all
            terms (in differens form) are multiplied by dx, so:
            wind friction term in source code becomes:
              tau_w * b * dx * cos(v) / rho_w
            where
              tau_w = Cw * rho_a * V*V
              Cw    = wind friction coefficient (dim. less app = 0.0025)
              rho_a = density of air (app = 1.3 kg/m3)
              V     = wind velocity (m/s)
            all in all the wind friction term becomes:
              Cw * rho_a * V*V * b * dx * cos(v) / rho_w ~=
              3.24E-6 * V*V *b * dx * cos(v)
            ==================================================================
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.HDGroundWaterLeakageSourceHandler">
            <summary>
            Provides a global source handler adding wind force to open q points, i.e.
            when both neighbour H grid points has an open cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HDGroundWaterLeakageSourceHandler.CreateGroundWaterLeakageHandler(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleHD.HDModule,DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary)">
            <summary>
            Create a global source handler based on the <see cref="T:DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary"/>, 
            using <see cref="T:DHI.Mike1D.Engine.HGridPoint"/> with an open cross section only.
            
            This must be called after Prepare.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HDResistanceSourceHandler.CreateResistanceSourceHandler(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleHD.HDModule,DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary)">
            <summary>
            Create a global source handler based on the <see cref="T:DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary"/>, 
            using <see cref="T:DHI.Mike1D.Engine.HGridPoint"/> with an open cross section only.
            
            This must be called after Prepare.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ISourcePoint">
            <summary>
            A point where a source contribution can be added.
            </summary>
            <remarks>
            <para>
            The difference between a source point and a <see cref="T:DHI.Mike1D.Generic.IDoubleSetter"/>
            is that the source point contributions are adding up (vs. ValueSetter is setting)
            and the setter is used before performing a new time step, while a source
            contribution is calculated and added during the time step (can be time step length
            dependent)
            </para>
            <para>
            The <see cref="M:DHI.Mike1D.Engine.ISourcePoint.AddSourcePerLengthContribution(System.Double)"/> and <see cref="M:DHI.Mike1D.Engine.ISourcePoint.AddSourcePerAreaContribution(System.Double)"/>
            are to be removed, and instead two more quantities are to be added to the sourcepointproxy.
            </para>
            </remarks>
            TODO: Remove AddSourcePerLengthContribution and AddSourcePerAreaContribution, and 
            instead add two more quantities to the sourcepointproxy
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePoint.AddSourceContribution(System.Double)">
            <summary>
            Add a contribution to the source point.
            </summary>
            <param name="val">Value to add to source</param>
            <returns> Actual value added, which may differ from value to add (if source point is accepting values per length/area or similar) </returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePoint.AddSourcePerLengthContribution(System.Double)">
            <summary>
             Add a contribution per length to the source.
            </summary>
            <param name="val">Value per length to add to source</param>
            <returns>Actual value added</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePoint.AddSourcePerAreaContribution(System.Double)">
            <summary>
             Add a contribution per area unit to the source.
            </summary>
            <param name="val">Value per area to add to source</param>
            <returns>Actual value added</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ISourcePointImplicit">
            <summary>
            A point where a source contribution can be added, containing an implicit term
            in the form of a derivative with respect to the state variable.
            <para>
            Current usage is adding a source that depends on the water level, and including
            a water level derivative to take the change of water level into account, i.e. 
            <code>
            Q_s = Q_s^n + dQdh * (H^{n+1} - H^n)
            </code>
            </para>
            <para>
            The actual source added can be calculated using the <see cref="M:DHI.Mike1D.Engine.ISourcePointImplicit.Evaluate"/> method
            after the time step has finished (at the <see cref="E:DHI.Mike1D.Engine.EngineNet.PostTimeStepEvent"/>).
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePointImplicit.AddSourceContribution(System.Double,System.Double)">
            <summary>
            Add a contribution to the source point
            </summary>
            <param name="val">Value to add</param>
            <param name="dValDstate">Value derivative</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePointImplicit.Evaluate">
            <summary>
            Post time step evaluation of the actual amount of source added
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IComponentSourcePoint">
            <summary>
            A component point where a component source contribution can be added.
            </summary>
            <remarks>
            <para>
            The difference between a source point and a <see cref="T:DHI.Mike1D.Generic.IDoubleSetter"/>
            is that the source point contributions are adding up (vs. ValueSetter is setting)
            and the setter is used before performing a new time step, while a source
            contribution is calculated and added during the time step (can be time step length
            dependent)
            </para>
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.IComponentSourcePoint.AddSourceContribution(System.Int32,System.Double)">
            <summary>
             Add a mass contribution to the AD source for the specified component.
            </summary>
            <param name="componentIndex"> </param>
            <param name="massPerSec">Load - mass per second</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.IComponentSourcePoint.AddSourceContribution(System.Int32,System.Double,System.Double)">
            <summary>
             Add a concentration contribution to the source for the specified component.
            </summary>
            <param name="componentIndex"> </param>
            <param name="concentration">Value to add to source</param>
            <param name="inflow">Discharge [m3/s]</param>
             <remarks>
             The inflow is required, to handle different inflows with different concentrations
             </remarks>
        </member>
        <member name="M:DHI.Mike1D.Engine.IComponentSourcePoint.OutflowConcentration(System.Int32)">
            <summary>
            The outflow concentration, i.e. concentration of component in water flowing out of the point.
            </summary>
            <param name="componentIndex">Index of component</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.ISourcePointProxy">
            <summary>
            Interface providing quantities and source points.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePointProxy.SourceAccepts">
            <summary>
            List of data types that is accepted for a source, i.e., that you can get a source point for.
            </summary>
            <returns>List of data types accepted</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePointProxy.SourcePoint(System.Int32)">
            <summary>
            Get source point
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ISimpleSourcePointProxy">
            <summary>
            A simple source point proxy, that can provide different source points 
            on different parts of the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISimpleSourcePointProxy.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a source point for the gridpoint in the reach.
            
            Usually this can only be called after the Prepare function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="gridPointIndex">Index to gridpoint to get source point for</param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISimpleSourcePointProxy.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Type)">
            <summary>
            Get a source point covering all gridpoints in the reach of the specified type
            
            Usually this can only be called after the Prepare function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="TGridPoint">Type of gridpoint.</param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISimpleSourcePointProxy.GetSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Type,DHI.Mike1D.Generic.ILocationSpan)">
            <summary>
            Get a source point covering all gridpoints in the span of the specified type
            
            Usually this can only be called after the Prepare function has been called.
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="TGridPoint">Type of gridpoint.</param>
            <param name="reachPartSpan"></param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.ISourcePointProxyProvider">
            <summary>
            Interface that provides source point proxies for different parts
            of the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePointProxyProvider.GetSourcePointProxy(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a source point proxy for the node.
            <para>
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </para>
            </summary>
            <param name="node">Node to get source point proxy for</param>
            <returns>null if no sourcepoint exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.ISourcePointProxyProvider.GetSourcePointProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a source point proxy for the gridpoint in the reach.
            <para>
            Usually this can only be called after the <see cref="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)"/> function has been called.
            </para>
            </summary>
            <param name="reach">Reach where gridpoint belongs to</param>
            <param name="gridPointIndex">Index to gridpoint to get source point for</param>
            <returns>A source point proxy</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EmptySourcePointProxy">
            <summary>
            The empty source point proxy. Use the static <see cref="P:DHI.Mike1D.Engine.EmptySourcePointProxy.Instance"/> property
            to get one.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EmptySourcePointProxy.#ctor">
            <summary>
            Constructor is private, to assure no one actually creates it.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EmptySourcePointProxy.Instance">
            <summary>
            Get the static instance of the empty proxy
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EmptySourcePointProxy.SourceAccepts">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EmptySourcePointProxy.SourcePoint(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Engine.SourceProxySetWrapper`1">
            <summary>
            Class that wraps a number of source proxies in one proxy.
            </summary>
            <typeparam name="TSourceProxy">Proxy type, derived from <see cref="T:DHI.Mike1D.Engine.ISourcePointProxy"/></typeparam>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceProxySetWrapper`1._proxies">
            <summary>
            Source proxies
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceProxySetWrapper`1._offers">
            <summary>
            List of all offers
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourceProxySetWrapper`1._offeredProxies">
            <summary>
            List of proxies and quantityIndex's for each IQuantity in the _offers
            i.e., this list is synchronized with the _offers
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceProxySetWrapper`1.#ctor">
            <summary>
            Protected constructor. If using this, remember to initialize the <see cref="F:DHI.Mike1D.Engine.SourceProxySetWrapper`1._proxies"/>
            member variable.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceProxySetWrapper`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a proxy set wrapper that wraps the provided set of proxies
            into one proxy
            </summary>
            <param name="proxies">Set of proxies to wrap</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceProxySetWrapper`1.SourcePoint(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceProxySetWrapper`1.SourceAccepts">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceProxySetWrapper`1.BuildOffers">
            <summary>
            Build _offers and _offeredProxies lists
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceProxySetWrapper`1.Initialize">
            <summary>
            Manually initialize offers and accepts data structures. Use this if AddToOffers() and AddToAccepts()
            is called manually instead of through BuildOffers() and BuildAccepts()
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceProxySetWrapper`1.AddToOffers(`0,System.Collections.Generic.IList{DHI.Mike1D.Generic.IQuantity})">
            <summary>
            Add quantities to offers.
            </summary>
            <param name="proxy"></param>
            <param name="quantities"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.IEngineNetParameter`1">
            <summary>
            Interface for getting values for a parameter that is defined
            over the enginenet.
            </summary>
            <remarks>
            Currently a <see cref="T:DHI.Mike1D.Engine.EngineNetParameterNetworkDataWrapper`1"/> is 
            implemented, but if the searching in 
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.Engine.ISourcePointStatistics">
            <summary>
             Statistic on a source point. Contains total inflow and total outflow.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ISourcePointStatistics.TotalInflow">
            <summary>
            Total inflow
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.ISourcePointStatistics.TotalOutflow">
            <summary>
            Total outflow
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.NodeCoverExpanding">
            <summary>
            An expanding cover on top of EngineNodeSewer. 
            Covers are connected to EngineNodeSewer with a Bridge Pattern (EngineNodeSewer as a reference to a NodeCover)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverExpanding.#ctor(System.Double,System.Double)">
            <summary>
            Create cover
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverExpanding.FlowArea(System.Double,System.Double)">
            <summary>
            Flow area of the expanding cover
            </summary>
            <param name="waterLevel"></param>
            <param name="diameterBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverExpanding.SurfaceArea(System.Double,System.Double)">
            <summary>
            Surface area of the expanding cover
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverExpanding.Volume(System.Double,System.Double)">
            <summary>
            Volume of wate in the cover.
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverExpanding.SpillingDischarge(System.Double,System.Double@)">
            <summary>
             Return discharge (q) out of cover and set dq/dh
             Both are 0 for expanding convers (no spill)
            </summary>
            <param name="waterLevel"></param>
            <param name="dqdh"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.NodeCoverSpilling">
            <summary>
            A spilling cover on top of EngineNodeSewer. Spilling covers will spill water out of the cover 
            above a certain water level.
            Covers are connected to EngineNodeSewer with a Bridge Pattern (EngineNodeSewer as a reference to a NodeCover)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSpilling.#ctor(System.Double,System.Double)">
            <summary>
            Create cover from Mike1DDataAccess.ICover
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeCoverSpilling.IsSpilling">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeCoverSpilling.SpillCoefficient">
            <summary>
            Setter for the spilling coefficient of spilling covers
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeCoverSpilling.SpillingWaterLevel">
            <summary>
            For spilling covers, spilling starts at this water level. Usually ground level plus a non-zero buffer pressure
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSpilling.Volume(System.Double,System.Double)">
            <summary>
            Volume of wate in the cover.
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSpilling.FlowArea(System.Double,System.Double)">
            <summary>
            Flow area of the cover
            </summary>
            <param name="waterLevel"></param>
            <param name="diameterBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSpilling.SurfaceArea(System.Double,System.Double)">
            <summary>
            Surface area of the cover
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSpilling.SpillingDischarge(System.Double,System.Double@)">
            <summary>
             Return discharge (q) out of cover and set dq/dh
            </summary>
            <param name="waterLevel"></param>
            <param name="dqdh"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.NodeCover">
            <summary>
            A cover on top of EngineNodeSewer. Covers can be expanding, sealed (contracting until a narrow tube)
            or spilling. Spilling covers will spill water out of the cover above a certain water level.
            Covers are connected to EngineNodeSewer with a Bridge Pattern (EngineNodeSewer as a reference to a NodeCover)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeCover.IsSpilling">
            <summary>
            Boolean indicating if this cover is spilling (removing water)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeCover._radiusAtWaterLevelStart">
            <summary>
            Diameter at the level where the cover starts
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeCover._waterLevelStart">
            <summary>
            Water level where the cover starts
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NodeCover._expansionCoefficient">
            <summary>
            Expansion coefficient. This is that factor with which the surface area can maximally expand. 
            Default value: 1000
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeCover.WaterLevelStart">
            <summary>
            Water level where the cover starts
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NodeCover.RadiusAtWaterLevelStart">
            <summary>
            Setter for the diameter at the water level where the cover starts
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.InCover(System.Double)">
            <summary>
            Returns true of waterLevel is inside the cover
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.Volume(System.Double,System.Double)">
            <summary>
            Volume of wate in the cover.
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.FlowArea(System.Double,System.Double)">
            <summary>
            Flow area of the cover
            </summary>
            <param name="waterLevel"></param>
            <param name="diameterBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.FlowAreaExpanding(System.Double,System.Double)">
            <summary>
            Flow area of an expanding cover (Expanding + Spilling covers use this)
            </summary>
            <param name="waterLevel"></param>
            <param name="diameterBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.VolumeExpanding(System.Double,System.Double)">
            <summary>
            Volume of an expanding cover (Expanding + Spilling covers use this)
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.SurfaceArea(System.Double,System.Double)">
            <summary>
            Surface area of the cover
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.SurfaceAreaExpanding(System.Double,System.Double)">
            <summary>
            Surface area of an expanding cover (Expanding + Spilling covers use this)
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCover.SpillingDischarge(System.Double,System.Double@)">
            <summary>
             Return discharge (q) out of cover and set dq/dh
            </summary>
            <param name="waterLevel"></param>
            <param name="dqdh"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineDistributedSourceHandler">
            <summary>
            An EngineDistributedSourceHandler will distribute/add the given source
            to a number of location spans. 
            <para>
            The handler contains a list of "source points", one for each source span,
            which can cover many grid points, and handles if grid points are only
            partially covered by the source span.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineDistributedSourceHandler.DistributionType">
            <summary>
            Defines how the boundary value is distributed on the
            source point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineDistributedSourceHandler.#ctor(DHI.Mike1D.BoundaryModule.IBoundarySource,DHI.Mike1D.BoundaryModule.TypeOfDistribution)">
            <summary>
            Default constructor
            </summary>
            <param name="bnd"></param>
            <param name="distributionType"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineDistributedSourceHandler.ApplyExternalSource(System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all ISourcePoints
            </summary>
            <param name="time">DateTime to use when getting boundary value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineDistributedSourceHandler.CreateEngineDistributedHSourceHandler(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ModuleHD.HDModule,DHI.Mike1D.Engine.ModuleAD.ADModule,DHI.Mike1D.BoundaryModule.IDistributedSourceBoundary)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.Engine.EngineDistributedSourceHandler"/> based on a 
            <see cref="T:DHI.Mike1D.BoundaryModule.IDistributedSourceBoundary"/>, 
            using <see cref="T:DHI.Mike1D.Engine.HGridPoint"/> only.
            
            This must be called after Prepare.
            </summary>
            <param name="engineNet">EngineNet to look in for network data</param>
            <param name="hdModule">Module to retrieve source points from</param>
            <param name="adModule">AD Module</param>
            <param name="bnd">Boundary to add</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineDistributedSourceHandler.CreateEngineDistributedHSourceHandler(DHI.Mike1D.Generic.ReachSearcher{DHI.Mike1D.NetworkDataAccess.IReach},DHI.Mike1D.Generic.Collections.NetworkValueIdList,DHI.Mike1D.BoundaryModule.IDistributedSourceBoundary,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.Engine.EngineDistributedSourceHandler"/> based on a 
            <see cref="T:DHI.Mike1D.BoundaryModule.IDistributedSourceBoundary"/>, 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineDistributedSourceBuilder">
            <summary>
            An EngineDistributedSourceBuilder is a helper class for distributed source
            where you add a number of location spans and reach id's, and when calling
            <see cref="M:DHI.Mike1D.Engine.EngineDistributedSourceBuilder.Proces"/>, the provided <see cref="T:DHI.Mike1D.Engine.EngineDistributedSourceBuilder.HandleReachSpan"/> method
            will be called for each reach that is covered by one of the added
            spans.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineDistributedSourceBuilder._bnd">
            <summary> Boundary that is processed. Used for error reporting only. </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineDistributedSourceBuilder._cc">
            <summary> CatchmentConnection that is processed. Used for error reporting only. </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineDistributedSourceBuilder.HandleReachSpan">
            <summary>
            Method signature for method to handle a reach that is part of the distributed source.
            </summary>
            <param name="sourceReachSpanFraction">Fraction of total distributing length that this span is covering</param>
            <param name="reach">Reach that this span is covering</param>
            <param name="sourceReachSpan">Span being the intersection of the source span and the reach span</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineDistributedSourceBuilder.Proces">
            <summary>
            Loops the matching spans, calculates scale factor and calls the <see cref="T:DHI.Mike1D.Engine.EngineDistributedSourceBuilder.HandleReachSpan"/> method for
            each included reach.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineGlobalSourceHandlerMidpoint.ItemSourcePoints">
            <summary>
            For each <see cref="T:DHI.Mike1D.BoundaryModule.IBoundaryItem"/> there is a list of <see cref="T:DHI.Mike1D.Engine.IRunoffSourcePoint"/>
            where that item should be applied to
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineGlobalSourceHandlerMidpoint.DistributionType">
            <summary>
            Defines how the boundary value is distributed on the
            source point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineGlobalSourceHandlerMidpoint.CreateOpenHSourceHandler(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Engine.ISimpleSourcePointProxy,DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.Engine.EngineGlobalSourceHandlerMidpoint"/> based on a 
            <see cref="T:DHI.Mike1D.BoundaryModule.IGlobalSourceBoundary"/>, 
            using <see cref="T:DHI.Mike1D.Engine.HGridPoint"/> with an open cross section only.
            
            This must be called after Prepare.
            </summary>
            <param name="engineNet">EngineNet to look in for network data</param>
            <param name="module">Module to retrieve source points from</param>
            <param name="bnd">Boundary to add</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.NodeCoverSealed">
            <summary>
            A cover on top of EngineNodeSewer. Covers can be expanding, sealed (contracting until a narrow tube)
            or spilling. Spilling covers will spill water out of the cover above a certain water level.
            Covers are connected to EngineNodeSewer with a Bridge Pattern (EngineNodeSewer as a reference to a NodeCover)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSealed.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create cover from Mike1DDataAccess.ICover
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSealed.FlowArea(System.Double,System.Double)">
            <summary>
            Flow area of the cover
            </summary>
            <param name="waterLevel"></param>
            <param name="diameterBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSealed.SurfaceArea(System.Double,System.Double)">
            <summary>
            Surface area of the cover
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSealed.Volume(System.Double,System.Double)">
            <summary>
            Volume of wate in the cover.
            </summary>
            <param name="waterLevel"></param>
            <param name="surfaceAreaBelowCover"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.NodeCoverSealed.SpillingDischarge(System.Double,System.Double@)">
            <summary>
             Return discharge (q) out of cover and set dq/dh
            </summary>
            <param name="waterLevel"></param>
            <param name="dqdh"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNodeManhole">
            <summary>
             The engine representation of a Manhole, specifying Diameter.
            </summary>
             <seealso cref="T:DHI.Mike1D.Engine.EngineNodeVolume"/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeManhole.#ctor(System.String,System.Double,System.Double,System.Double)">
            <summary>
             Create EngineNodeManhole
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeManhole.Diameter">
            <summary>
            Diameter of man hole. Used instead of GetDiameter(double waterLevel) if you know
            you have a manhole.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeManhole.GetSurfaceArea(System.Double)">
            <summary>
            Return the surface area for a given water level
            </summary>
            <param name="waterLevel">Water level to get surface area for.</param>
            <returns>Surface area. 0 if not relevant.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeManhole.GetStorageArea(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeManhole.GetVolume(System.Double)">
            <summary>
            Calculate volume in node for given water level.
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Volume in node for given water level</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeManhole.GetFlowArea(System.Double)">
            <summary>
            Calculate the flow area (area perpendicular to flow direction) for a given water level
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Flow area in node for given water level</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeManhole.GetStorageWidth(System.Double)">
            <summary>
            Calculate the storage width  for a given water level, for a manhole being the diameter
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Storage Width in node for given water level</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNetFactory">
            <summary>
            Factory Class for creating engine classes.
            <para>
            NOTE: This should be the only component depending on the dataaccess components,
            especially the NetworkDataAccess classes.
            </para>
            <para>
            If desired, this can be moved to another project, to remove dependencies 
            from EngineNetwork to DataAccess components.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNetFactory.EngineNet">
            <summary>
            The created EngineNet
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetFactory._sidestructureNetworkLocations">
            <summary> Location on side structure reach for all side structures </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetFactory._sidestructureLocations">
            <summary> structure.Location for side structures (main reach location, not side structure reach location) </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.GetStructureNetworkLocation(DHI.Mike1D.StructureModule.IStructure)">
            <summary>
            Get the location in the EngineNet network, in case of 
            side structures, it gives the name of the side structure
            reach and not the location defined in the structure (which is on the main reach)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateEngineNetwork(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
             Create a new EngineNet stored in <see cref="P:DHI.Mike1D.Engine.EngineNetFactory.EngineNet"/> and
             initialise it using the Network, HD parameters and CrossSections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateEngineNetwork(System.String,DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
             Create a new EngineNet stored in <see cref="P:DHI.Mike1D.Engine.EngineNetFactory.EngineNet"/> and
             initialise it using the Network, HD parameters and CrossSections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.InitializeEngineTime(DHI.Mike1D.HDParameterDataAccess.TimeStepping,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Create and initialize the engine time and stores it in the engine net.
            </summary>
            <param name="timeStepping">Time stepping parameters to use when creating the engine time class</param>
            <param name="hdParameters"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.InitializeStructureReachZLocations">
            <summary>
            Set the Z location of cross sections on structure reaches.
            This is a separate step since it needs to be done after the node bottom levels have been initialized.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.InitializeStructures(DHI.Mike1D.Generic.IDiagnostics,DHI.Mike1D.CrossSectionModule.CrossSectionData)">
            <summary>
            Initialize all structures, and give them reach cross sections
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.SetupNodeReachLists(DHI.Mike1D.Engine.EngineNet,System.Boolean)">
            <summary>
            Each node has a list of connecting reaches, for fast lookup. These lists
            are set up here.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.UpdateJunctionNodeBottomLevelsFromReaches(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Method for updating bottom level of junction nodes from surrounding reaches
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateNodeAndReachList(DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Creates a list of reaches from the branches of the data access module. Nodes 
            are added at the ends of the created reaches.
            
            The nodes added are nodes at branch ends. They are added to the existing list of nodes
            defined for connection of the links.
            </summary>
            <returns>
            A list of engine nodes where some reaches potentially needs to be splitted. 
            Used by the <see cref="M:DHI.Mike1D.Engine.EngineNetFactory.DivideReaches(DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)"/> - Nodes that have been added do
            an ConnectionLocation
            </returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.FindOrCreateNode(DHI.Mike1D.Generic.INetworkLocation,System.Collections.Generic.IList{DHI.Mike1D.Generic.ILocation},DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Tries to find a node by following the <paramref name="current"/> <see cref="T:DHI.Mike1D.Generic.INetworkLocation"/>,
            recursively if necessary. If no node is found, one is inserted.
            
            The <paramref name="sourceLocations"/> is used to stop infinite recursion
            in case of a connection loops. It contains all the locations where a node is required. 
            At first call, use a list with one location where the node is required.
            
            The <paramref name="sourceReach"/> is used when searching for reach connections, to not find itself
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetFactory._reachInternalNodesMap">
            <summary>
            A map that for each <see cref="T:DHI.Mike1D.Engine.EngineReach"/> holds a list of 
            location-<see cref="T:DHI.Mike1D.Engine.EngineNode"/> pairs where the EngineReach is to be divided
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNetFactory._divideLocations">
            <summary>
            A set of locations at which a reach has been divided.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.DivideReaches(DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Divide reaches that span the given node locations into smaller reaches.
            The EngineNodes in the nodeConnections list are created
            such that the <see cref="P:DHI.Mike1D.Engine.EngineNode.Location"/> matches the
            reach ID (LocationSpan.Id) of the reach that it is to divide.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateReachStructureMap(DHI.Mike1D.StructureModule.IStructureCollection)">
            <summary>
            Create a map of all structures, searchable on reach id and chainage.
            This is to avoid creating a H point on a structure location (there can
            be a cross section at a structure location)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.HasStructureAtLocation(System.Collections.Generic.List{DHI.Mike1D.Generic.ILocation},DHI.Mike1D.Generic.Location)">
            <summary>
             Return true if the reach has a structure grid point at the given location
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.HasStructureInSpan(System.Collections.Generic.List{DHI.Mike1D.Generic.ILocation},DHI.Mike1D.Generic.ILocationSpan)">
            <summary>
             Return true if the reach has a structure within the given location span
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.HasStructureGridPointInSpan(DHI.Mike1D.Engine.GridPoints,DHI.Mike1D.Generic.ILocationSpan)">
            <summary>
             Return true if the reach has a structure grid point within the given location span.
             It differs from above in that it searches in the grid points and also includes
             structures with relative location.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.AddStructurePoints(DHI.Mike1D.StructureModule.IStructureCollection,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            GridPoints are added for all composite structures that are placed in the network. Structures
            not in the network are silently ignored (handled in data access validation). 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateStructurePoint(DHI.Mike1D.StructureModule.IStructureCollection,DHI.Mike1D.StructureModule.ICompositStructure,DHI.Mike1D.Generic.ILocation,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create an HDStructureGridPoint at location
            </summary>
            <param name="compositStructure"></param>
            <param name="location"></param>
            <param name="crossSectionData"></param>
            <param name="boundaryData"> </param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.AddHPoints(DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Add storage (h) points.
            Storage points are added at the end of the reaches, where cross sections are defined and
            where it is needed in order to comply with MaxDx constraint
            </summary>
            <param name="crossSectionData">EngineCrossSection collection</param>
            <param name="hdParameterData">HD parameters</param>
            <param name="diagnostics">Diagnostics</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.AddCrossSectionGridPoint(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IZLocation,DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Add a grid point at the cross section position, or give a cross section to existing gridpoint 
            at cross section location.
            </summary>
            <param name="reach">Reach to add cross section/grid point to</param>
            <param name="zLocation">Location to add grid point at</param>
            <param name="crossSection">Cross section to add</param>
            <param name="hdParameterData">HD parameters</param>
            <returns>True if cross section was added</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.AddQPoints">
            <summary>
            Add Q points between each H point, in case there is no structure point already
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateNode(DHI.Mike1D.NetworkDataAccess.INode,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Create an EngineNode from an INode.
            </summary>
            <param name="node">INode to create enginenode from</param>
            <param name="hdParameterData"> </param>
            <returns>A new engine node</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateNodeManhole(DHI.Mike1D.NetworkDataAccess.IManhole,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Create an EngineNode from an IManhole.
            </summary>
            <param name="node">IManhole to create engine node from</param>
            <param name="hdParameterData"> </param>
            <returns>Engine manhole</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateNode(DHI.Mike1D.NetworkDataAccess.IOutlet)">
            <summary>
            Create an EngineNodeOutlet from an IOutlet.
            </summary>
            <param name="node">IOutlet to create engine outlet from</param>
            <returns>An engine outlet</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateNode(DHI.Mike1D.NetworkDataAccess.ISewerJunction)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.Engine.EngineSewerJunctionNode"/> from an <see cref="T:DHI.Mike1D.NetworkDataAccess.ISewerJunction"/>.
            </summary>
            <param name="node">IOutlet to create engine outlet from</param>
            <returns>An engine outlet</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateNodeBasin(DHI.Mike1D.NetworkDataAccess.IBasin,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Create an EngineNodeOutlet from an IBasin.
            </summary>
            <param name="node">IBasin to create engine basin from</param>
            <param name="hdParams">HD parameters</param>
            <returns>An engine basin</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateNode(DHI.Mike1D.NetworkDataAccess.IStructureNode)">
            <summary>
            Create an EngineStructureNode from an IStructureNode.
            <para>
            It is assumed that the structure functionality will be added by the user.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateNode(DHI.Mike1D.NetworkDataAccess.ILeapingWeir)">
            <summary>
            Create an EngineNodeLeapingWeir from an ILeapingWeir.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.CreateCover(DHI.Mike1D.NetworkDataAccess.ICover)">
            <summary>
            Create an engine node cover from the provided ICover
            </summary>
            <param name="cover">ICover</param>
            <returns>An engine node cover</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.AssignBoundaries(DHI.Mike1D.BoundaryModule.BoundaryData)">
            <summary>
             Assign all boundaries from the BoundaryData object
            </summary>
            <param name="bndData"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNetFactory.AssignOpenBoundaries(DHI.Mike1D.BoundaryModule.BoundaryData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
             Assign all boundaries from the BoundaryData object
            </summary>
            <param name="bndData"></param>
            <param name="runtimeDiagnostics"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.OpenBoundaryType">
            <summary>
             Types of open boundaries
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundaryType.Closed">
            <summary>
             Closed boundary
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundaryType.Outlet">
            <summary>
             Outlet boundary, no boundary source available, 
             always setting up free outflow (natural/critical outflow)
             or using bottom level when cross sections are not available (structure reaches)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundaryType.WaterLevel">
            <summary>
             Water level boundary
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundaryType.Inflow">
            <summary>
             Inflow boundary
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundaryType.QH">
            <summary>
             QH (discharge-waterlevel table) boundary
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundaryType.Undefined">
            <summary>
             Undefined boundary
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.OpenBoundarySubType">
            <summary>
             Sub type of open boundary
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundarySubType.Standard">
            <summary> Standard, no special action </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundarySubType.WaterLevelCoupled">
            <summary> Water level boundary coupled to external (surface) area. External coupled area must be provided, <see cref="P:DHI.Mike1D.Engine.EngineNode.ExternalCoupledArea"/></summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.OpenBoundarySubType.WaterLevelCoupledQ">
            <summary> Water level boundary coupled to external (surface) area with a discharge correction. External coupled area must be provided, <see cref="P:DHI.Mike1D.Engine.EngineNode.ExternalCoupledArea"/> </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNode">
            <summary>
            A general node without volume (river node).
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNode.NodeListIndex">
            <summary>
            Index of this node in the list of nodes. Optimization for
            fast lookup in the lists (instead of using find).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.OpenBoundaryType">
            <summary>
             Type of open boundary. Check if node is an open boundary using <see cref="P:DHI.Mike1D.Engine.EngineNode.InternalNode"/>
             before accessing this property.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.OpenBoundarySubType">
            <summary>
             Sub type of open boundary.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNode._openBoundaryType">
            <summary>
             Type of open boundary. Check if node is an open boundary using <see cref="P:DHI.Mike1D.Engine.EngineNode.InternalNode"/>
             before accessing this property.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.ExternalCoupledArea">
            <summary>
            When coupled to an external water level, the effect of changing the water level in the
            network model also affects the external water level. By specifying the external coupled area,
            the actual water level boundary is modified to take the change in this
            external coupled area into account.
            <para>
            It effectively has a smoothing effect on a coupling.
            The smaller coupled area, the more smoothing effect is applied.
            </para>
            <para>
            Setting the coupled area to 0 disables the procedure.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.HeadLossCalculator">
            <summary>
            Head loss calculator
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.InfiltrationCalculator">
            <summary>
            Infiltration calculator
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.CalculateInfiltrationFluxSuppression(DHI.Mike1D.Engine.ModuleHD.IHDNode,System.Double)">
            <summary>
            Slot-like functionality, scaling positive infiltrationFlux below 
            delh such that infiltrationFlux becomes zero at _engineNode.BottomLevel.
            Negative infiltration (water entering node) is left unchanged.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.OpenSourceBoundary">
            <summary>
            Get the IOpenSourceBoundary for the node. Null when node is an internal node 
            (not an open boundary node)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.InternalNode">
            <summary>
            Returns true if the node is internal, i.e., not a boundary node.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.ShadowNode">
            <summary>
            Returns true if the node is a shadow node, i.e. only representing a node from another domain (MPI)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.PressureReachNodeType">
            <summary>
            This nodes relation to pressurized sections of the network
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.PressureReachTailCrestLevel">
            <summary>
            Minimum water level in the outflow from pressurized sections, and hence also minimum water level in the pressurized section
            <para>
            Only applicable when <see cref="P:DHI.Mike1D.Engine.EngineNode.PressureReachNodeType"/> is <see cref="F:DHI.Mike1D.NetworkDataAccess.PressureReachNodeType.Tail"/>.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.#ctor(System.String,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.#ctor(System.String,System.Double,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.#ctor(DHI.Mike1D.Generic.ILocation,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.Location">
            <summary>
             The Location of the node. A node can be placed at more than one 
             location. This only handles one location. Used for searching for
             initial conditions.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.HasVolume">
            <summary>
            Boolean specifying whether the enginenode has a volume.
            <para>
            Must be overwritten for enginenodes with a volume
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNode._bottomLevel">
            <summary>
            Bottom level
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNode._groundLevel">
            <summary>
            Ground level
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.BottomLevel">
            <summary>
            Bottom level
            <para>
            For a junction node (node without volume (in a river setup)), 
            this is set to the smallest bottomlevel of the surrounding reaches.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.UpdateBottomLevelOfStructureReaches">
            <summary>
            Update bottom level of all structure reaches connected to the node
            to the same bottom level as the node.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.GroundLevel">
            <summary>
            Ground level
            <para>
            For a junction node (node without volume (in a river setup)), 
            this is not set, having value of <see cref="F:System.Double.MaxValue"/>.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.SetHeadloss(DHI.Mike1D.Engine.ModuleHD.IHeadLossCalculator)">
            <summary>
            Set head loss calculator, for user defined head loss calculations
            </summary>
            <param name="calculator"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.GetSurfaceArea(System.Double)">
            <summary>
            Return the surface area for a given water level
            </summary>
            <param name="waterLevel">Water level to get surface area for.</param>
            <returns>Surface area. 0 if not relevant.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.GetStorageArea(System.Double)">
            <summary>
            Return the storage area for a given water level
            Compared to surface area, storage area takes porosity into account
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.ID">
            <summary>
            Node ID string. (Not associated with the reach ID's)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNode._id">
            <summary>
            Node ID string.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.XCoordinate">
            <summary>
            X coordinate of node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.YCoordinate">
            <summary>
            Y coordinate of node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.MaxInflowFromSurface">
            <summary>
            Maximum inflow from the surface, i.e. rainfall runoff type inflows.
            <para>
            This is only relevant for sewer type nodes, where the inflow is limited
            by a surface opening like a sewer grate.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.Initialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Called in Initialize step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.Prepare">
            <summary>
            Called in prepare step
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNode.ReachConnection">
            <summary>
            Structure containing enginereach and which end that it is 
            connected to (start or end)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.ReachConnection.#ctor(DHI.Mike1D.Engine.EngineReachEnd,DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Constructor taing a EngineReach and an EngineReachEnd
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNode.ReachConnection.ReachEnd">
            <summary>
            End of reach
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNode.ReachConnection.EngineReach">
            <summary>
            EngineReach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNode.ReachConnection.GridPointAtEnd">
            <summary>
            Returns the grid point at this reach end.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNode.Reaches">
            <summary>
            List of engineReaches connected to this node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.AssignBoundary(DHI.Mike1D.Engine.OpenBoundaryType,DHI.Mike1D.BoundaryModule.IOpenSourceBoundary)">
            <summary>
            Assign a water level boundary to this node. Only one open boundary type can
            be assigned to each node
            </summary>
            <param name="openBoundaryType">Boundary type</param>
            <param name="openSourceBoundary">Boundary</param>
            <returns>True if successfull, false if already assigned an OpenBoundary</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.IDEquals(System.String)">
            <summary>
            Checks whether the otherId matches this nodes ID.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.SpillingDischargeCover(System.Double,System.Double@)">
            <summary>
            Return amount of water spilling out of cover, and set dq/dh. Only Manholes with a spilling cover return non-zero.
            </summary>
            <param name="waterLevel"></param>
            <param name="dqdh"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNode.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineSewerJunctionNode">
            <summary>
            A sewer junction node. It does not have any volume
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineSewerJunctionNode.#ctor(System.String,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNodeBasin">
            <summary>
            Basin node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeBasin.#ctor(System.String,System.Double,System.Double)">
            <summary>
             Create EngineNodeBasin
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeBasin.IsClosed">
            <summary>
            <para>
            Flag indicating if basin is closed.
            </para>
            <para>
            If the basin is closed, then surface area is not restricted to
            be monotonically increasing.
            </para>
            <para>
            Open basins counts in flooded area.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeBasin.Geometry">
            <summary>
            Basin geometry, with water level, flow area, and surface area data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeBasin.InfiltrationParameters">
            <summary>
            Infiltration parameters
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeBasin.GetSurfaceArea(System.Double)">
            <summary>
            Return the surface area for a given water level
            </summary>
            <param name="waterLevel">Water level to get surface area for.</param>
            <returns>Surface area. 0 if not relevant.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeBasin.GetStorageArea(System.Double)">
            <summary>
            Return the surface area for a given water level
            </summary>
            <param name="waterLevel">Water level to get surface area for.</param>
            <returns>Surface area. 0 if not relevant.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeBasin.GetVolume(System.Double)">
            <summary>
            Calculate volume in node for given water level
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Volume in node for given water level</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeBasin.GetVolume(System.Double,System.Boolean)">
            <summary>
            Calculate volume in node for given water level
            </summary>
            <param name="waterLevel">Water level in node</param>
            <param name="waterVolume">Flag indicating if it is water volume (in case of poros materials) or total volume</param>
            <returns>Volume in node for given water level</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeBasin.GetFlowArea(System.Double)">
            <summary>
            Calculate the flow area (area perpendicular to flow direction) for a given water level
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Flow area in node for given water level</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeBasin.GetStorageWidth(System.Double)">
            <summary>
            Calculate the storage width for a given water level.
            <para>
            Calculated as the diameter of a circle with the same surface area as the basin at the give water level.
            </para>
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Storage Width in node for given water level</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNodeOutlet">
            <summary>
            An Outlet is a volume free node where water flows out of the system. 
            <para>
            An outlet is the only type of open boundary that does not need a boundary condition
            </para>
            <para>
            An outlet can have a boundary condition (water level/QH), in which case the 
            water can also flow into the system.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeOutlet.StructureOutlet">
            <summary>
            Flag indicating if this is a structure outlet.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeOutlet.#ctor(System.String,System.Double,System.Double)">
            <summary>
            Create an EngineNodeOutlet
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EnginePointSourceHandler">
            <summary>
            An EnginePointSourceHandler will add the given source
            to a number of source points. Each sourcepoint contribution
            has a specific scalefactor that is multiplied to the source
            before it is added to the source point
            
            See also <see cref="T:DHI.Mike1D.Engine.EngineDistributedSourceHandler"/>.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EnginePointSourceHandler.SourcePointsNph">
            <summary>
            List of source points and scalefactor for each sourcepoint.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EnginePointSourceHandler.SourcePointsNp1">
            <summary>
            List of source points and scalefactor for each sourcepoint.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EnginePointSourceHandler._hasHD">
            <summary>
            Bool indicating if boundary has HD contribution. Most does.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EnginePointSourceHandler._boundary">
            <summary>
            The boundary to get the source value from.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.#ctor(DHI.Mike1D.BoundaryModule.IPointSourceBoundary)">
            <summary>
            Initialize EnginePointSourceHandler with this IPointSourceBoundary
            </summary>
            <param name="bnd">BoundarySource to get value from</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.#ctor(DHI.Mike1D.BoundaryModule.IOpenSourceBoundary)">
            <summary>
            Initialize EnginePointSourceHandler with this IPointSourceBoundary
            </summary>
            <param name="bnd">BoundarySource to get value from</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.ApplyExternalSourceNph(System.DateTime,System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all ISourcePoints
            </summary>
            <param name="timeN">Start of time step span</param>
            <param name="timeNp1">End of time step span</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.ApplyExternalSourceNp1(System.DateTime,System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all ISourcePoints
            </summary>
            <param name="timeN">Start of time step span</param>
            <param name="timeNp1">End of time step span</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.ApplyExternalSourceNph(System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all Nph ISourcePoints
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.ApplyExternalSourceNp1(System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all Np1 ISourcePoints
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.ApplyExternalSource(System.DateTime)">
            <summary>
            Public method to apply the source in this handler to all ISourcePoints
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.ApplyExternalSource(System.DateTime,System.Collections.Generic.List{DHI.Mike1D.Engine.EnginePointSourceHandler.SourcePointConnection})">
            <summary>
            Apply external source for time and on source points
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.CreateEnginePointSourceHandler(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.BoundaryModule.IPointSourceBoundary)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.Engine.EnginePointSourceHandler"/> based on a 
            <see cref="T:DHI.Mike1D.BoundaryModule.IPointSourceBoundary"/>, 
            using <see cref="T:DHI.Mike1D.Engine.HGridPoint"/> only.
            
            This must be called after Prepare.
            </summary>
            <param name="engineNet">EngineNet to look in for network data</param>
            <param name="bnd">Boundary to add</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.CreateEnginePointSourceHandler(DHI.Mike1D.Generic.Collections.NetworkValueIdList,DHI.Mike1D.BoundaryModule.IPointSourceBoundary)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.Engine.EnginePointSourceHandler"/> based on a 
            <see cref="T:DHI.Mike1D.BoundaryModule.IPointSourceBoundary"/>
            </summary>
            <param name="simpleEngineNet">EngineNet for storing network values</param>
            <param name="bnd">Boundary to add</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.CreateEnginePointSourceHandler(DHI.Mike1D.Generic.Collections.NetworkValueIdList,DHI.Mike1D.BoundaryModule.IOpenSourceBoundary)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.Engine.EnginePointSourceHandler"/> based on a 
            <see cref="T:DHI.Mike1D.BoundaryModule.IOpenSourceBoundary"/>
            </summary>
            <param name="simpleEngineNet">EngineNet for storing network values</param>
            <param name="bnd">Boundary to add</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EnginePointSourceHandler.GetSTComponentIndex(DHI.Mike1D.BoundaryModule.IPointSourceBoundary,System.Int32,DHI.Mike1D.STDataAccess.STData)">
            <summary>
            Get index of non-cohesive ST component
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ResultDataEngineNetChecker">
            <summary>
            Checks whether an IResultData exactly matches an enginenet.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ResultDataEngineNetChecker.#ctor(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Constructor. Helper class to check whether an IResultData exactly matches an enginenet.
            </summary>
            <param name="engineNet"></param>
            <param name="results"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ResultDataEngineNetChecker.Check(DHI.Mike1D.Generic.IDiagnostics,System.Boolean)">
            <summary>
            Check whether the results and the enginenet matches, writing
            differences into the provided diagnostics.
            </summary>
            <param name="diagnostics">Diagnostics to put warnings into</param>
            <param name="checkJunctionNodes">
            Set to true if also check on junction node id's - those not being an EngineNodeSewer.
            This check is not really necessary, since the initial value for a junction node
            only affects the initial water level in the result file, it is not used for computations
            </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.ResultDataEngineNetChecker.FindReach(DHI.Mike1D.Engine.EngineReach,System.Double@)">
            <summary>
            Find reach in results with the largest overlap
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ResultDataEngineNetChecker.CheckNetworksExact(DHI.Mike1D.ResultDataAccess.IResultData,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IDiagnostics,System.Boolean@)">
            <summary>
            Check if results matches with engineNet. They must match exactly, i.e.
            nodes and reaches have to be ordered in the same way.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SolverGridPoint">
            <summary>
            Solver gridpoint contains solver routines and solver coefficients
            for solving the reach tridiagonal system with 3 right hand sides (e0, e1, f)
            
            General for HD, AD and more
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverGridPoint.GridPoint">
            <summary>
            Gridpoint of structure
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverGridPoint.e0">
            <summary>
            Left node rhs
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverGridPoint.e1">
            <summary>
            Right node rhs (after doublesweep has finished)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverGridPoint.#ctor(DHI.Mike1D.Engine.GridPoint)">
            <summary>
            Constructor
            </summary>
            <param name="gridPoint">GridPoint in EngineNet that this solverGridPoint is based on</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SolverGridPointSrhs">
            <summary>
            Solver grid point supporting single right hand sides
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverGridPointSrhs.f">
            <summary>
            Right hand side (after doublesweep has finished)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverGridPointSrhs.SweepForward(System.Double@,System.Double@,System.Double@)">
            <summary>
            Forward sweep in the solution of the tri band matrix
            
            When done, diagonal element is 1 (not stored), under-diagonal element is zero (not stored),
            new over diagonal element (_co3) is stored in -_e1, and rhs (_co4) is updated in _f.
            </summary>
            <param name="e0prev">Previous node 1-rhs</param>
            <param name="e1prev">Previous over diagonal element</param>
            <param name="fprev">Previous rhs</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverGridPointSrhs.SweepBackward(System.Double@,System.Double@,System.Double@)">
            <summary>
            Backward sweep in the solution of the tri band matrix
            
            When done, both node-1-rhs (_e0), node-2-rhs (_e1) and f-rhs have been updated
            </summary>
            <param name="e0next">Next node-1 rhs</param>
            <param name="e1next">in: next over diagonal element. out: next node-2 rhs</param>
            <param name="fnext">next rhs</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverGridPointSrhs.Evaluate(System.Double,System.Double)">
            <summary>
            Based on firstValue (value on start node) and lastValue
            (value on end node), calculate solution on each gridpoint
            in reach based on:
               val = e0*firstValue + e1*lastValue + f
            </summary>
            <param name="firstValue">Value at start node</param>
            <param name="lastValue">Value at end node</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SolverGridPointMrhs">
            <summary>
            Solver grid point supporting multiple right hand sides
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverGridPointMrhs.f">
            <summary>
            Right hand side (after doublesweep has finished)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverGridPointMrhs.SweepForward(System.Double@,System.Double@,System.Double[]@,System.Int32)">
            <summary>
            Forward sweep in the solution of the tri band matrix
            
            When done, diagonal element is 1 (not stored), under-diagonal element is zero (not stored),
            new over diagonal element (_co3) is stored in -_e1, and rhs (_co4) is updated in _f.
            </summary>
            <param name="e0prev">Previous node 1-rhs</param>
            <param name="e1prev">Previous over diagonal element</param>
            <param name="fprev">Previous rhs</param>
            <param name="nrhs">Number of right hand sides</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverGridPointMrhs.SweepBackward(System.Double@,System.Double@,System.Double[]@,System.Int32)">
            <summary>
            Backward sweep in the solution of the tri band matrix
            
            When done, both node-1-rhs (_e0), node-2-rhs (_e1) and f-rhs have been updated
            </summary>
            <param name="e0next">Next node-1 rhs</param>
            <param name="e1next">in: next over diagonal element. out: next node-2 rhs</param>
            <param name="fnext">next rhs</param>
            <param name="nrhs">Number of right hand sides</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverGridPointMrhs.Evaluate(System.Int32,System.Double,System.Double)">
            <summary>
            Based on firstValue (value on start node) and lastValue
            (value on end node), calculate solution on each gridpoint
            in reach based on:
               val = e0*firstValue + e1*lastValue + f
            </summary>
            <param name="isol">index of solution vector</param>
            <param name="firstValue">Value at start node</param>
            <param name="lastValue">Value at end node</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SolverNode">
            <summary>
            Solver node contains solver routines and coefficients for
            solving the sparse node matrix system.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.SolverNode.NodeListIndex">
            <summary>
            Index of this node in the list of solver nodes. Optimization for
            fast lookup in the lists (instead of using find).
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.SolverNode.DiagonalElmt">
            <summary>
            Pointer to thos nodes diagonal element of node matrix
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SolverReachConnectionValues">
            <summary>
            Helper type that defines which reaches each node is connected to, and
            to which end of the reach.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.SolverReachConnectionValues.OtherElmt">
            <summary>
            Matrix element pointer to this nodes oposing node matrix element,
            for the reach in this reachConnection
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverNodeSrhs.RightHandSide">
            <summary>
            Contribution of this node to the right hand side
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverNodeSrhs.Value">
            <summary>
            Solution value at this node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverNodeMrhs.RightHandSide">
            <summary>
            Contribution of this node to the right hand side
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverNodeMrhs.Value">
            <summary>
            Solution value at this node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.ModuleReachConnection">
            <summary>
            Helper type that defines which reaches each node is connected to, and
            to which end of the reach.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SolverReach">
            <summary>
            Solver reach contains solver routines and coefficients 
            for solving the reach tridiagonal system with 3 right hand sides
            
            General for HD, AD and more
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SolverReachSrhs">
            <summary>
            Solver reach supporting single right hand side
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverReachSrhs.GridPoints">
            <summary>
            List of solver gridpoints in this reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverReachSrhs.DoubleSweep">
            <summary>
            Solves the tridiagonal reach system with 3 right hand sides (e0, e1, f)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverReachSrhs.Evaluate(System.Double,System.Double)">
            <summary>
            Based on firstValue (value on start node) and lastValue
            (value on end node), calculate solution on each gridpoint
            in reach based on:
               val = e0*firstValue + e1*lastValue + f
            </summary>
            <param name="firstValue">Value at start node</param>
            <param name="lastValue">Value at end node</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SolverReachMrhs">
            <summary>
            Solver reach supporting multiple right hand side
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SolverReachMrhs.GridPoints">
            <summary>
            List of solver gridpoints in this reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverReachMrhs.DoubleSweep(System.Int32)">
            <summary>
            Solves the tridiagonal reach system with 3 right hand sides (e0, e1, f)
            </summary>
            <param name="nrhs"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SolverReachMrhs.Evaluate(System.Int32,System.Double,System.Double)">
            <summary>
            Based on firstValue (value on start node) and lastValue
            (value on end node), calculate solution on each gridpoint
            in reach based on:
               val = e0*firstValue + e1*lastValue + f
            </summary>
            <param name="isol">Index of component</param>
            <param name="firstValue">Value at start node</param>
            <param name="lastValue">Value at end node</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.NodeSolverPardiso">
            <summary>
            Node solver for single right hand side systems.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardiso._nodes">
            <summary>
            Node list that is private to the node solver and in which the order of the nodes may be
            manipulated
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardiso._reaches">
            <summary>
            Reference to the branch list of the networkEngine
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardiso.Initialize(System.Collections.Generic.List{DHI.Mike1D.Engine.Solver.SolverNodeSrhs},System.Collections.Generic.List{DHI.Mike1D.Engine.Solver.SolverReachSrhs},System.Int32)">
            <summary>
            Initialize datastructures
            </summary>
            <param name="solverNodes"></param>
            <param name="reaches"></param>
            <param name="nrhs">Number of right hand sides</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardiso.GetSolutionToHD">
            <summary>
            Takes the solution and distributes it to the relevant nodes and reaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardiso.GetSolution(System.Double[])">
            <summary>
            Takes the solution and distributes it to the relevant nodes and reaches.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.NodeSolverPardisoMrhs">
            <summary>
            Node solver for multiple right hand side systems.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoMrhs._nodes">
            <summary>
            Node list that is private to the node solver and in which the order of the nodes may be
            manipulated
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoMrhs._reaches">
            <summary>
            Reference to the branch list of the networkEngine
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoMrhs.Initialize(System.Collections.Generic.List{DHI.Mike1D.Engine.Solver.SolverNodeMrhs},System.Collections.Generic.List{DHI.Mike1D.Engine.Solver.SolverReachMrhs},System.Int32)">
            <summary>
            Initialize datastructures
            </summary>
            <param name="solverNodes"></param>
            <param name="reaches"></param>
            <param name="nrhs">Number of right hand sides (maximum)</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoMrhs.GetSolution(System.Int32[])">
            <summary>
            Takes the solution and distributes it to the relevant nodes and reaches.
            </summary>
            <param name="valueIndexMap"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoMrhs.GetSolution(System.Double[])">
            <summary>
            Takes the solution and distributes it to the relevant branches/reaches.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase">
            <summary>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase._nrhs">
            <summary> Number of right hand sides </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase._nrhsMax">
            <summary> Maximum number of right hand sides </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase._reachVectorIndeces">
            <summary>
            List of every reaches indeces to first and last node solution/rhs.
            Key is StartNode index, Values is SecondNodeIndex
            Must be synchronized with Reaches list.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase._matrixC">
            <summary>
            System matrix
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase._rhs">
            <summary>
            Right hand side vector
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase._solution">
            <summary>
            Solution vector
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase.Initialize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initialize datastructures
            </summary>
            <param name="nodeCount">Number of nodes</param>
            <param name="reachCount">Number of reaches</param>
            <param name="nrhs">Number of right hand sides</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase.Prepare(System.Collections.Generic.IReadOnlyList{DHI.Mike1D.Engine.Solver.SolverReach})">
            <summary>
            Prepare the solver, setup matrix and relate matrix elements to
            branches
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoBase.SetupMatrix(System.Collections.Generic.IReadOnlyList{DHI.Mike1D.Engine.Solver.SolverReach})">
            <summary>
            Sets up a SparseCRLMatrix with the structure of the system 
            matrix, and converts this to a SparseCRSMatrixC which
            is the one to use in the solver.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.INodeSolver.SetCoeffients(System.Double)">
            <summary>
            
            </summary>
            <param name="timeStep">Time step in seconds</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.NodeSolverPardisoDebugger">
            <summary>
             Debugger for the Paradiso node solver
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Solver.NodeSolverPardisoDebugger.PrintInterval">
            <summary>
            Print solution to file for every PrintInterval steps
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoDebugger.PreSolve(System.Int32)">
            <summary>
             Print solution coefficients to files linsysC_A.[count].txt and linsysC_b.[count].txt
            </summary>
            <param name="solveCount"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoDebugger.PostSolve(System.Int32)">
            <summary>
             Post solver steps
            </summary>
            <param name="solveCount"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.NodeSolverPardisoDebugger.Prepare">
            <summary>
             Prepare the solver before first iteration
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement">
            <summary>
            Sparse linked matrix element type, used by NodeSolverLinkedMatrix (the "original" Mike11 solver)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.#ctor(System.Int32,System.Int32,DHI.Mike1D.Engine.Matrices.MatrixElementType)">
            <summary>
             Construct an element of a sparse matrix
            </summary>
            <param name="rowNumber"></param>
            <param name="columnNumber"></param>
            <param name="elementType"></param>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.Row">
            <summary>
            The row number
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.Column">
            <summary>
            The column number
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.ElementType">
            <summary>
             Type of this matrix elements
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.GetValue">
            <summary>
            The value of the Matrix Element
            </summary>
            <returns>Matrix element value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.SetValue(System.Double)">
            <summary>
            Set the value of the matrix element. Returns true if success, false
            if not possible
            </summary>
            <param name="value">Value to set matrix element to</param>
            <returns>true on success</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.AddToValue(System.Double)">
            <summary>
            Adds value to matrix element. Returns true if success, false
            if not possible
            </summary>
            <param name="value">Value to add to the matrix element</param>
            <returns>true on success</returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.Coef">
            <summary>
             Value os this matrix element.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.Next">
            <summary>
             Next element in matrix
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.Rel">
            <summary>
            Linked SparseLinkedMatrixElement (for instance used to store the diagonal element of this row)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.CompareTo(DHI.Mike1D.Engine.Matrices.ISparseMatrixElement)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the other parameter.Zero This object is equal to other. Greater than zero This object is greater than other. 
            </returns>
            
            <param name="elmt">An object to compare with this object.</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement.CompareTo(DHI.Mike1D.Engine.Solver.SparseLinkedMatrixElement)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the other parameter.Zero This object is equal to other. Greater than zero This object is greater than other. 
            </returns>
            
            <param name="elmt">An object to compare with this object.</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.IExternalForcing">
            <summary>
            Interface where you can add a contribution to
            the forcing of the system.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IExternalForcing.AddSourceContribution(System.Double)">
            <summary>
             Add a contribution to the source.
            </summary>
            <param name="val">Value to add to source</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.IProxyProvider">
            <summary>
             Interface for a proxy provider on a network
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IProxyProvider.GetProxy(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a proxy for the node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IProxyProvider.GetProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a proxy for the gridpoint in the reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IProxyProvider.GetProxy(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, covering a number of gridpoints
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IProxyProvider.GetProxyReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, generic data (not gridpoint associated)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IProxyProvider.GetProxy">
            <summary>
            Get a proxy for generic/global data
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IModule">
            <summary>
             Interface to Engine modules
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.IModule.Id">
            <summary>
            Id of module
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.IModule.Order">
            <summary>
            Order of module. Modules are processed in order.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModule.Prepare(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Prepare module for first time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModule.PrepareForTimeStep(System.Int32)">
            <summary>
             Prepare module for time step (set state(n+1) = state(n)).
             <para>
             </para>
            </summary>
             <param name="redoCount">
             Number of times this time step is redone. First time called
             for one time step, it will have the value of zero, and 
             if a time step needs to be redone, this will be larger than zero
             </param>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModule.PerformTimestep">
            <summary>
             Perform timestep and return true if solution is accepted. 
             Can be called several times for different values of Dt.
            </summary>
            <returns>True on success</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModule.FinalizeTimestep">
            <summary>
            FinalizeTimeStep allows the modules to do operations required when 
            a time step has successfully completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModule.PreferredTimeStep(System.Boolean,System.TimeSpan)">
            <summary>
             Returns the preferred time step for the current state. It is called between every time step
             and can increase as well as decrease the time step.
             <para>
             Used when <see cref="P:DHI.Mike1D.Engine.EngineTime.AdaptiveTimeSteppingActivated"/> is true.
             </para>
             <para>
             Do return the maximum of the allowed time step; in case a buffer is required, this is handled
             by a time step controller.
             </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModule.Finish">
            <summary>
             Finishes the module and releases any license
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IModuleNetwork">
            <summary>
            Interface extending the <see cref="T:DHI.Mike1D.Engine.IModule"/> interface with
            network features.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IModuleNetwork`2">
            <summary>
            Interface extending the <see cref="T:DHI.Mike1D.Engine.IModule"/> interface with
            network features.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IModuleNode">
            <summary>
            Node in an <see cref="T:DHI.Mike1D.Engine.IModuleNetwork"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.IModuleNode.EngineNode">
            <summary>
            EngineNode matching this module node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IModuleReach">
            <summary>
            Reach in an <see cref="T:DHI.Mike1D.Engine.IModuleNetwork"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.IModuleReach.EngineReach">
            <summary>
            EngineReach matching this module reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IModulePointState">
            <summary>
            Interface for the state of a point. NOT USED.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModulePointState.Offers">
            <summary>
             List of quantities that are available on the this point
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.IModuleReachState">
            <summary>
            Interface for a module reach state
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModuleReachState.Offers">
            <summary>
             List of quantities which the module offers
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModuleReachState.Accepts">
            <summary>
             List of quantities which the module accepts
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModuleReachState.GetGridPointProxy(System.Int32)">
            <summary>
            TODO: Summary
            </summary>
            <param name="gridPointIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.IModuleReachState.GetGridPointForcing(System.Int32)">
            <summary>
            Return an object where you can add forcing contribution to the specified grid point.
            </summary>
            <param name="gridPointIndex"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.DataHolderType">
            <summary>
             Type of data in a dataholder: Time, Node, Point, or Reach.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.DataHolderType.Time">
            <summary>
            Time data type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.DataHolderType.Node">
            <summary>
            Node data type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.DataHolderType.Point">
            <summary>
            Point data type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.DataHolderType.Reach">
            <summary>
            Reach data type
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineTime">
            <summary>
             NetworkEngine time.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime.OFFERS_Time">
            <summary>
            quantityIndex of offered time quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime.OFFERS_TimeStep">
            <summary>
            quantityIndex of offered timestep quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime.ACCEPTS_Time">
            <summary>
            quantityIndex of accepted time quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime.ACCEPTS_TimeStep">
            <summary>
            quantityIndex of accepted timestep quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime._timeNp1">
            <summary>
            Time at point n+1. State variable
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime._timeNph">
            <summary>
            Time at point n+. Derived variable
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime._timeN">
            <summary>
            Time at point n. Derived variable
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime._numberOfTimeSteps">
            <summary>
            Counts the number of time steps performed
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime._dt">
            <summary>
            Time step. Derived variable based on _dtSpan, use Dt property to update this.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime._ddt">
            <summary>
            Inverse Time step, 1/dt. Derived variable based on _dtSpan
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineTime._dtSpan">
            <summary>
            Time step in TimeSpan format. State variable
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.CheckPoints">
            <summary>
            Check point controller, handling check points in time that must be hit by the EngineTime.
            <para>
            This is not used when <see cref="P:DHI.Mike1D.Engine.EngineTime.EngineTimeStep"/> is null (constant time step)
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.TimeN">
            <summary>
            Time at time step n
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.TimeNph">
            <summary>
            Time at time step n + 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.TimeNp1">
            <summary>
            Time at time step n+1
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.NumberOfTimeSteps">
            <summary>
            Number of time steps performed.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.NumberOfTriedTimeSteps">
            <summary>
            Total number of time steps tried, also those failing.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.NumberOfTriesForTimeStep">
            <summary>
            Counts the number of time steps tried for the current time step
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.EngineTimeStep">
            <summary>
            The <see cref="T:DHI.Mike1D.Engine.IEngineTimeStep"/> does the actual calculation of the new time step.
            <para>
            If null, time step is decided directly by the current value of <see cref="P:DHI.Mike1D.Engine.EngineTime.Dt"/>/<see cref="P:DHI.Mike1D.Engine.EngineTime.DtSpan"/>.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.Dt">
            <summary>
            Time step
            Unit: [sec]. Rounded to nearest millisecond
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.DDt">
            <summary>
            Time step inverse - 1/Dt
            Unit: [1/sec]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.DtSpan">
            <summary>
            Time step
            Unit: [sec]. Rounded to nearest millisecond
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineTime.AdaptiveTimeSteppingActivated">
            <summary>
            Indicates whether adaptive time stepping is activated. Used to decide whether the state
            should be stored before a time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.SetTimeStepAndUpdateNp1(System.TimeSpan)">
            <summary>
            Adjusts the current timestep by setting both DtSpan and TimeNp1
            Unit: [sec]. Rounded to nearest millisecond
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.SetTimeSteady(System.DateTime)">
            <summary>
            Adjusts the current timestep by setting both DtSpan and TimeNp1
            Unit: [sec]. Rounded to nearest millisecond
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.Update">
            <summary>
            Steps time one time steps forward
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.ResetInitialTimeStep(System.TimeSpan)">
            <summary>
            Resets values for EngineTimeStep and sets DtSpan to initialTimeStep.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.NextTimeStep">
            <summary>
            Returns the size of the next time step. In case of adaptive time stepping
            this is a guess of the size of the next time step, and may not equal 
            the actual size of the time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.TryDecreaseTimeStep">
            <summary>
            Returns false if the time step should be decreased but cannot be decreased further. 
            Throws an exception if adaptive time stepping is not enabled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.ValueGetter(System.Int32)">
            <summary>
            Get value setter for the specified data quantity
            </summary>
            <param name="quantityIndex">Requested Quantity</param>
            <returns>A value getter delegate that can set the value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.ValueSetter(System.Int32)">
            <summary>
            Get value setter for the specified data type
            </summary>
            <param name="quantityIndex">Requested Quantity</param>
            <returns>A value setter delegate that can set the value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.Offers">
            <summary>
            List of data types that is offered and can be used in GetValue
            </summary>
            <returns>List of data types offered</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineTime.Accepts">
            <summary>
            List of data types that is accepted and can be used in SetValue
            </summary>
            <returns>List of data types accepted</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.CalendarConverter">
            <summary>
            Support class for conversions between DateTime objects and Modified Julian Dates
            Modified Julian Date is the number of days since November 17, 1858.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.CalendarConverter.ToModifiedJulian(System.DateTime)">
            <summary>
            Converts a DateTime object to modified julian date
            </summary>
            <param name="gregorianDate">DateTime object</param>
            <returns>Modified Julian Date (days since November 17, 1858)</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.CalendarConverter.ToDateTime(System.Double)">
            <summary>
            Converts a modified julian date to a DateTime object
            </summary>
            <param name="modifiedJulianDate">Modified Julian Date (days since November 17, 1858)</param>
            <returns>DateTime object</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.GridPointTypes">
            <summary>
            Enumeration of grid point types. 
            <para>
            Defined as flag so they can be used as selection, i.e. 
            <code>
              GridPointTypes allow = HGridPoint | QGridPoint
            </code>
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPointTypes.None">
            <summary> Undefined, or none </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPointTypes.HGridPoint">
            <summary> H grid point </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPointTypes.QGridPoint">
            <summary> Q grid point </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPointTypes.StructureGridPoint">
            <summary> Structure grid point. A structure grid point is also a Q grid point </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPointTypes.RoutingGridPoint">
            <summary> Routing grid point </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.GridPoint">
            <summary>
            Base class for all gridpoints
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.GridPoint.#ctor(DHI.Mike1D.Generic.ILocation)">
            <summary>
             Constructor
            </summary>
            <param name="location"></param>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPoint._location">
            <summary>
            Location in network. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.GridPoint.PointIndex">
            <summary>
            Index in list of gridpoints
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPoint._d2x">
            <summary>
            distance from previous point to next point.
            For the first grid point in the reach it is the distance to the grid point after this point.
            For the last grid point in the reach it is the distance to the gridpiont before this point.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.GridPoint.D2x">
            <summary>
            distance from previous point to next point.
            For the first grid point in the reach it is the distance to the grid point after this point.
            For the last grid point in the reach it is the distance to the gridpiont before this point.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPoint._ratio">
            <summary>
            Ratio used when interpolating between values in the 
            up and down stream reach direction
            v = (1-ratio)*v_{j-1} + ratio*v_{j+1}
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.GridPoint.Ratio">
            <summary>
            Ratio used when interpolating between values in the 
            up and down stream reach direction
            v = (1-ratio)*v_{j-1} + ratio*v_{j+1}
            <para>
            Ratio is <see cref="P:DHI.Mike1D.Engine.GridPoint.Dx"/>/<see cref="P:DHI.Mike1D.Engine.GridPoint.D2x"/>
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.GridPoint._dx">
            <summary>
            Distance to prev point
            for the first grid point in a reach it is zero.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.GridPoint.Dx">
            <summary>
            Distance to prev point. 
            For the first grid point in a reach it is zero.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.GridPoint.Location">
            <summary>
             Location of grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.GridPoint.GetGridPointSpan">
            <summary>
            Get the <see cref="T:DHI.Mike1D.Generic.ILocationSpan"/> around this gridpoint where
            the values are valid, usually the span from the previous gridpoint
            to the next gridpoint in the reach.
            </summary>
            <returns>A span covering the valid area of the gridpoint.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.GridPoint.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than obj. Zero This instance is equal to obj. Greater than zero This instance is greater than obj. 
            </returns>
            
            <param name="obj">An object to compare with this instance. </param>
            <exception cref="T:System.ArgumentException">obj is not the same type as this instance. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.Engine.GridPoint.Initialize">
            <summary>
            Preparing gridpoint for calculation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.GridPoint.ToString">
            <summary>
            Overriding ToString method, providing better info in GUI when debugging
            Only in debug, do not enable in release
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.GridPoints">
            <summary>
             List of gridpoints
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.HGridPoint">
            <summary>
            Storage point where water level is defined. 
            Represents the water level and the volume between 
            prev and next Q-point. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.HGridPoint.#ctor(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.HGridPoint.BottomLevel">
            <summary>
            Bottom level of h grid point. 
            <para>
            When a cross section is present, this is set equal to 
            <see cref="P:DHI.Mike1D.CrossSectionModule.ICrossSection.ZMin"/>, otherwise the bottom
            level is taken from the digipoints
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.HGridPoint._engineCrossSection">
            <summary>
            Cross section. ICrossSection wrapped with slot functionality
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.HGridPoint.EngineCrossSection">
            <summary>
            Cross section. ICrossSection wrapped with slot functionality
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.RoutingGridPoint">
            <summary>
            Routing grid point, where discharge is defined.
            Can also contain a water level, and a cross section.
            <para>
            There is a routing grid point in the end of every 
            <see cref="T:DHI.Mike1D.Engine.EngineRoutingElement"/>.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.RoutingGridPoint.#ctor(DHI.Mike1D.Generic.IZLocation,DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.Engine.EngineRoutingElement)">
            <summary>
            Create new routing grid point at location.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.RoutingGridPoint.CrossSection">
            <summary>
            Cross section.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.RoutingGridPoint.RoutingElement">
            <summary>
            Routing element that this grid point is associated with. 
            The grid point is located at the end of the routing element.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IQGridPoint">
            <summary>
            Interface to QGridPoint. If access to QGridPoint is needed from outside the network engine,
            then it should happen through this interface.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.IRunoffSourcePoint">
            <summary>
            An <see cref="T:DHI.Mike1D.Engine.ISourcePoint"/> that is capable of handling runoff input, where
            it is required to take surface area of river into account.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.IRunoffSourcePoint.AddSourceRunoffContribution(System.Double,System.Double)">
            <summary>
             Add a rainfall runoff contribution to the source. The surface area of the river is subtracted
             from the area available for runoff. 
            </summary>
            <param name="val">Contribution in m^3/sec</param>
            <param name="catchmentArea">Area of the catchment</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.ISparseMatrix">
            <summary>
            Interface to a sparse matrix type. 
            
            The implementer can use as well one based as zero based
            row/column indices.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.ISparseMatrix.Size">
            <summary>
            Size of matrix, Size X Size
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.ISparseMatrix.NumElmts">
            <summary>
            Number of non-zero elements in matrix
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.ISparseMatrix.Capacity">
            <summary>
            Maximum number of matrix elements that the sparse matrix 
            can handle. Can be lower than Size x Size
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ISparseMatrix.getMatrixElement(System.Int32,System.Int32)">
            <summary>
            Get a matrix element pointer pointing at the given row/column index.
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
            <returns>Matrix element pointer</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ISparseMatrix.addMatrixElement(System.Int32,System.Int32)">
            <summary>
            Add a matrix element at the given row/column index and return its matrix 
            element pointer.
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
            <returns>Matrix element pointer</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ISparseMatrix.ClearMatrix">
            <summary>
            Set all matrix element values to zero. This does not remove the matrix element
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.ISparseMatrixElement">
             <summary>
             Interface to a matrix element. This can be used as a matrix element pointer.
            
             The implementer can use as well one based as zero based row/column indices.
             </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.ISparseMatrixElement.Row">
            <summary>
            The row number
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.ISparseMatrixElement.Column">
            <summary>
            The column number
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ISparseMatrixElement.GetValue">
            <summary>
            The value of the Matrix Element
            </summary>
            <returns>Matrix element value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ISparseMatrixElement.SetValue(System.Double)">
            <summary>
            Set the value of the matrix element. Returns true if success, false
            if not possible
            </summary>
            <param name="value">Value to set matrix element to</param>
            <returns>true on success</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ISparseMatrixElement.AddToValue(System.Double)">
            <summary>
            Adds value to matrix element. Returns true if success, false
            if not possible
            </summary>
            <param name="value">Value to add to the matrix element</param>
            <returns>true on success</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.PardisoSolver">
            <summary>
             Sparse matrix solver
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.PardisoSolver.DirectSolverInit(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initialises direct solver, allocating memory for matrix, rhs and solution vector
            </summary>
            <param name="N">Size of matrix, NxN</param>
            <param name="nnz">Number of nonzero elements - maximum</param>
            <param name="nrhs">Number of right hand sides - maximum</param>
            <param name="numthreads">Number of threads to use</param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.PardisoSolver.LUSolver(System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Solves the linear system A*x = b. Uses a LU factorization, i.e., solving P*L*U*x = b
            </summary>
            <param name="n">in. Size of system, n x n</param>
            <param name="nrhs">in. Number of right hand sides</param>
            <param name="a">in/out. Pointer to array of doubles of size n x n (in unmanaged memory) containing elements of A in column major order. When done, overwritten with the LU factors</param>
            <param name="ipiv">out. Pointer to array if integers (in unmanaged memory) of size n. outputs the pivot indices P</param>
            <param name="b">in/out. Pointer to array of doubles of size n (in unmanaged memory). In is right hand side b, out is solution x.</param>
            <returns>Integer with status. 0 on succes. negative if input arguments had an illegal value. positive, system is exactly singular.</returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.PardisoSolver.pSetup">
            <summary>
            Pointer value to C setup
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.PardisoSolver.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new solver object, with a matrix size of
            size x size, containing at most nnz number of non-zero
            elements
            </summary>
            <param name="size">Size of matrix, size x size</param>
            <param name="nnz">Maximum numbber of nonzero elements in matrix</param>
            <param name="nrhs">Number of right hand sides</param>
            <param name="numThreads">Number of threads to use (configures both Pardiso and OpenMP)</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.PardisoSolver.Finalize">
            <summary>
             Default destructor. Releases resources used by the solver.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.PardisoSolver.getSolutionArrayC">
            <summary>
            Return a ArrayC representation of the C result array.
            (Pointer to unmanaged C array).
            Every time Run is called, the values here are updated, old values overwritten, 
            however the pointer stays the same (same memory location). 
            Hence, this object can be reused between calls to Run, but 
            cannot be used to store historic data.
            </summary>
            <returns>The C result array</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.PardisoSolver.getRhsArrayC">
            <summary>
            Return a ArrayC representation of the C rhs array (Right Hand Side).
            (Pointer to unmanaged C array).
            Every time before Run is called, the values here are to be updated with the new right hand side.
            The pointer stays the same (same memory location), values are updated. 
            Hence, this object can be reused between calls to Run, but 
            cannot be used to store historic data.
            </summary>
            <returns>The C rhs array</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.PardisoSolver.getMatrixC">
            <summary>
            Return a SparseCRSMatrixC (pointers to unmanaged C arrays).
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.PardisoSolver.Solve(System.Int32,System.Int32)">
            <summary>
            Solve the linear system.
            Actually: go through the steps defined by phase, where
            1: Analyse
            2: Factorize
            3: Solve
            The phase parameter is given as a 2 digit number, specifying 
            first and last phase to complete. The phase value 11 will only analyse, 
            while the phase value 13 will do all 3 phases. Phase value must be one
            of 11,12,13,22,23,33.
            </summary>
            <param name="phase">Phase value</param>
            <param name="nrhsActual">For phase 3: Actual number of right hand sides. Must be less or equal to the number of right hand sides defined originally</param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix">
            <summary>
            Sparse matrix structure based on linked list.
            
            Row and column numbers are zero based.
            
            The matrix elements are structured in a linked list, 
            ordered in row major order (first row with all columns 
            first, second row with all columns next). 
            
            Performance: When getting/adding matrix elements, it is a 
            O(number_of_columns_in_row) operation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.Size">
            <summary>
            Size of matrix, Size x Size
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.Capacity">
            <summary>
            Maximum number of elements allowed
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.NumElmts">
            <summary>
            Number of (non-zero) elements in matrix
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.First">
            <summary>
            Returns the first element in the linked linst of MatrixElements
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix._rowIndex">
            <summary>
            For performance. The rowIndex array points to the first column in 
            that row. If there is no columns in that row, it points to the first 
            matrix element in a row below that row. If there are no elements below
            that row, null is returned.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.#ctor(System.Int32)">
            <summary>
            Create a sparse matrix of given size
            </summary>
            <param name="size">Size of matrix</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.getMatrixElement(System.Int32,System.Int32)">
            <summary>
            Get matrix element pointer at given row/column index
            </summary>
            <param name="row">Row index, zero based</param>
            <param name="column">Column index, zero based</param>
            <returns>Matrix element pointer</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.addMatrixElement(System.Int32,System.Int32)">
            <summary>
            Add a matrix element at the given row/column index and return
            a pointer to the matrix element. If matrix element already
            exists, the existing matrix element is returned.
            </summary>
            <param name="row">Row index, zero based</param>
            <param name="column">Column index, zero based</param>
            <returns>Matrix element pointer</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.ClearMatrix">
            <summary>
            Sets all coefficient in matrix to zero
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.SkylineZeroPad">
            <summary>
            Pad with zeros from off-diaginal elements to diagonal, 
            for elements below the diagonal, the row is padded, 
            for elements above the diagonal, the column is padded.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrix.ContinuousRowPad">
            <summary>
            Pad each row with zeros between first and last matrix element
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.MatrixElementType">
            <summary>
            Type of matrix element
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Matrices.MatrixElementType.UnderDiagonal">
            <summary>
            Under/below the diagonal
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Matrices.MatrixElementType.Diagonal">
            <summary>
            On the diagonal
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Matrices.MatrixElementType.OverDiagonal">
            <summary>
            Over/above the diagonal
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Matrices.MatrixElementType.RightHandSide">
            <summary>
            Right hand side
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement">
            <summary>
             Single element in a sparse matrix
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.#ctor(System.Int32,System.Int32)">
            <summary>
             Construct element at (row,column)
            </summary>
            <param name="row"></param>
            <param name="column"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Construct element at (row,column) and set it to value
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <param name="value"></param>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.Row">
            <summary>
            Row number of Matrix element
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.Column">
            <summary>
            Column number of matrix element
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.ElementType">
            <summary>
             Type of element: MatrixElementType.Diagonal, MatrixElementType.UnderDiagonal, or MatrixElementType.OverDiagonal
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.Coef">
            <summary>
            Get or set the coefficient. Deprecated, use GetValue and SetValue instead
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.GetValue">
            <summary>
            The value of the Matrix Element
            </summary>
            <returns>Matrix element value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.SetValue(System.Double)">
            <summary>
            Set the value of the matrix element. Returns true if success, false
            if not possible
            </summary>
            <param name="value">Value to set matrix element to</param>
            <returns>true on success</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.AddToValue(System.Double)">
            <summary>
            Adds value to matrix element. Returns true if success, false
            if not possible
            </summary>
            <param name="value">Value to add to the matrix element</param>
            <returns>true on success</returns>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.Next">
            <summary>
            Next element in list of MatrixElements
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRLMatrixElement.CompareTo(DHI.Mike1D.Engine.Matrices.ISparseMatrixElement)">
            <summary>
            Checks if this matrix element points to the same row/column as the other matrix element
            </summary>
            <param name="other">The other matrix element.</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC">
            <summary>
            Sparse matrix storing its value in compressed row storage 
            format, values are stored in C arrays. This is an unsafe
            implementation, so be carefull! 
            
            This implementation follows the Intel MKL sparse matrix storage 
            format for direct sparse solvers. It is a subset of the CSR 
            (compressed sparse row) format for Sparse BLAS level 2 and 3.
            
            Row and column indices are one based.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.Size">
            <summary>
            Size of matrix, Size X Size
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.Capacity">
            <summary>
            Maximum number of matrix elements that the sparse matrix 
            can handle. This is set when initiating a SparseCRSMatrixC
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.NumElmts">
            <summary>
            Number of non-zero elements in matrix. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.ValuesPtr">
            <summary>
            Pointer to unmanaged memory containing the values of the matrix elements. 
            
            The array is Capacity number of elements long, though possibly only NumElmts are used
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.RowIndexPtr">
            <summary>
            Pointer to unmanaged memory containing row indices. The i'th element (RowIndex[i-1]) 
            specifies the index in the values array of the first non-zero element in i'th row row.
            If no elements in the i'th row, RowIndex[i-1] == RowIndex[i].
            Index values are one based.
            
            The array is Size long (number of rows long)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.ColumnsPtr">
            <summary>
            Pointer to unmanaged memory containing column number of a given matrix element. Column
            indices are one based. 
            
            The array is Capacity number of elements long, though possibly only NumElmts are used
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a sparse matrix of size N x N, with maximum number of non-zero entries.
            Memory for storage of matrix data is automatically allocated. 
            Memory is automatically free'd when the object is garbage collected.
            </summary>
            <param name="N">Size N x N of matrix</param>
            <param name="maxcapacity">Maximum number of nonzero entries</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.#ctor(System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Create sparse matrix. Use input pointers as storage pointers.
            It is the users responsibility to make sure that
            the pointers are C array of correct type and size.
            It is also the users responsibility to free the memory
            associated with the C pointers, when it is no longer needed.
            </summary>
            <param name="size">Size size x size of matrix</param>
            <param name="maxcapacity">Max number of nonzero entries</param>
            <param name="values">Pointer value to values array</param>
            <param name="rowIndex">Pointer value to rowIndex array</param>
            <param name="columns">Pointer value to columns array</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.Finalize">
            <summary>
            Allows an <see cref="T:System.Object"></see> to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Object"></see> is reclaimed by garbage collection.
            </summary>
            
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.setValue(System.Int32,System.Double)">
            <summary>
            Sets a given value at given index in Values.
            </summary>
            <param name="index">Index into Values array</param>
            <param name="value">Value to set at index</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.getValues">
            <summary>
            Copies the unmanaged C Values array to managed C# array.
            Changes to the C# array does not change the C array values.
            </summary>
            <returns>Copy of values</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.setValues(System.Collections.Generic.List{System.Double})">
            <summary>
            Copies managed C# array to unmanaged C array.
            </summary>
            <param name="values">Values to copy</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.addMatrixElement(System.Int32,System.Int32)">
            <summary>
            Not supported by this type of matrix
            (Add a matrix element at the given row/column index and return its matrix 
            element pointer.)
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
            <returns>Matrix element pointer</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.getMatrixElement(System.Int32,System.Int32)">
            <summary>
            Get a matrix element pointer pointing at the given row/column index.
            </summary>
            <param name="row">Row index, one based</param>
            <param name="column">Column index, one based</param>
            <returns>Matrix element pointer</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.ClearMatrix">
            <summary>
            Set all matrix element values to zero. This does not remove the matrix element
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.consolePrint">
            <summary>
            Print out one line for each matrix element containing
            element number, column number and value.
            Print out one line for each row containing
            row number, rowindex value for this row.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.convertSparseCRLMatrix(DHI.Mike1D.Engine.Matrices.SparseCRLMatrix,DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC@,System.Boolean)">
            <summary>
            Convert a sparseCRLMatrix (CompressRowLinked) to a 
            SparseCRSMatrixC (Compressed Row Storage, C version)
            (The CRLMatrix can not have more elements than the CRSMatrixC, 
            but it can have less.)
            </summary>
            <param name="inmat">In matrix</param>
            <param name="outmat">Out matrix</param>
            <param name="removeZeroElements">Remove zero matrix elements in out-matrix, if existing as element in in-matrix</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.printToFile(System.String,System.Boolean)">
            <summary>
            Prints matrix to file. Each matrix element on the form
            
             row_no  col_no  value
            
            Row and column numbers are one based. Can be imported to a Matlab Sparse matrix by:
            
            A_sparse = load(filename)
            A = spconvert(A_sparse)
            
            File is overwritten if existing.
            </summary>
            <param name="filename">Filename to print to.</param>
            <param name="append">True to append to existing file, false to overwrite existing file</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC.printCoefficient(System.IO.TextWriter,System.Int32,System.Int32,System.Double,System.IFormatProvider)">
            <summary>
            Printing one line to TextWriter with row number, column number and value.
            </summary>
            <param name="sw_A">Textwriter to write to</param>
            <param name="row">row number</param>
            <param name="col">column number</param>
            <param name="val">value</param>
            <param name="culture">Culture to use in print</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement">
            <summary>
            Matrix element pointer to a matrix element of a SparseCRSMatrixC element.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement.#ctor(DHI.Mike1D.Engine.Matrices.SparseCRSMatrixC,System.Int32,System.Int32)">
            <summary>
            Create a matrix element.
            </summary>
            <param name="matrix">Matrix which this referes to</param>
            <param name="index">Linear index (zero based) of element into matrix</param>
            <param name="row">Row number, one based</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement.Row">
            <summary>
            Row number of Matrix element
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement._row">
            <summary>
            Row number is difficult to extract from the matrix structure, hence
            saving it locally
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement.Column">
            <summary>
            Column number of matrix element
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement.ElementType">
            <summary>
             Return current element type: Diagonal, OverDiagonal, or UnderDiagonal
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement.GetValue">
            <summary>
            The value of the Matrix Element
            </summary>
            <returns>Matrix element value</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement.SetValue(System.Double)">
            <summary>
            Set the value of the matrix element. Returns true if success, false
            if not possible
            </summary>
            <param name="value">Value to set matrix element to</param>
            <returns>true on success</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement.AddToValue(System.Double)">
            <summary>
            Adds value to matrix element. Returns true if success, false
            if not possible
            </summary>
            <param name="value">Value to add to the matrix element</param>
            <returns>true on success</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.SparseCRSMatrixCElement.CompareTo(DHI.Mike1D.Engine.Matrices.ISparseMatrixElement)">
            <summary>
            Checks if this matrix element points to the same row/column as the other matrix element
            </summary>
            <param name="other">The other matrix element.</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.Matrices.ArrayC">
            <summary>
            Array storage, values are stored in unmanaged (C) array.
            This is an unsafe implementation, so be carefull!
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.ArrayC.Count">
            <summary>
            Number of elements in vector
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.Matrices.ArrayC.VectorPtr">
            <summary>
            Pointer to unmanaged memory (to C array)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.#ctor(System.Int32)">
            <summary>
            Create vector and allocate memory. Allocated memory is 
            automatically free'd when the object is garbage collected.
            </summary>
            <param name="N"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.#ctor(System.Int32,System.IntPtr)">
            <summary>
            Create vector, use ptr input pointer as storage pointer.
            It is the users responsibility to make sure that
            ptr is an unmanaged (C) array, type double, of size N.
            It is also the users responsibility to free the memory
            associated with ptr, when it is no longer needed.
            </summary>
            <param name="N">Size of vector</param>
            <param name="ptr">C Pointer value to array</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.Finalize">
            <summary>
            Allows an <see cref="T:System.Object"></see> to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Object"></see> is reclaimed by garbage collection.
            </summary>
            
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.Clear">
            <summary>
            Set all array elements to zero
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.getValues">
            <summary>
            Copies values from the C unmanaged array to C# managed array.
            Updates in the returned list does not change values in 
            the vector.
            </summary>
            <returns>List of copied values</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.setValues(System.Double[])">
            <summary>
            Copies values from C# managed array to C unmanaged array
            </summary>
            <param name="vals">Values to copy</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.printToFile(System.String,System.Boolean)">
            <summary>
            Print array to file. Each line is on the form
            
            index  value
            
            index is one-based.
            
            Filename is overwritten, if existing.
            </summary>
            <param name="filename">Filename to write to.</param>
            <param name="append">True to append to existing file, false to overwrite existing file</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.printCoefficient(System.IO.TextWriter,System.Int32,System.Double,System.IFormatProvider)">
            <summary>
            Prints one line to TextWriter containing row number and value.
            </summary>
            <param name="sw_x">TextWriter to print to</param>
            <param name="row">row number</param>
            <param name="val">value</param>
            <param name="culture">Culture to use when printing value</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.Matrices.ArrayC.CopyTo(DHI.Mike1D.Engine.Matrices.ArrayC)">
            <summary>
            Copyes data from this arrayC to the target arrayC. They must have same size
            </summary>
            <param name="target">Target to copy data to.</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNodeVolume">
            <summary>
            A node with volume. Usually it is where several sewer links are joining in the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeVolume.#ctor(System.String,System.Double,System.Double)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeVolume.HasVolume">
            <summary>
            Boolean specifying whether the enginenode has a volume.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeVolume.Delh">
            <summary>
            The Delh controls the height of the bottom slot
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeVolume.CriticalLevel">
            <summary>
            Used in result presentation. Passed directly to the result file.
            Unit: [m]
            Default: 0
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeVolume.VolumeErrorInTimestep(System.Double,System.Double,System.Double)">
            <summary>
            Return the amount of water added due to non-volume preserve scheme. The volume is 
            equal to A*(wl_Np1 - wl_N) - (CorrectVolume_Np1 - CorrectVolume_N), where A is the 
            surface area at Np1.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeVolume.GetVolume(System.Double)">
            <summary>
            Calculate volume in node for given water level
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Volume in node for given water level</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeVolume.GetFlowArea(System.Double)">
            <summary>
            Calculate the flow area (area perpendicular to flow direction) for a given water level
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Flow area in node for given water level</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeVolume.GetStorageWidth(System.Double)">
            <summary>
            Calculate the storage width  for a given water level
            </summary>
            <param name="waterLevel">Water level in node</param>
            <returns>Storage Width in node for given water level</returns>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNodeVolume._delh">
            <summary>
            The Delh controls the height of the bottom slot
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNodeVolume._criticalLevel">
            <summary>
            Used in result presentation. Passed directly to the result file.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeVolume.BufferPressure">
            <summary>
            A spilling cover will start to spill once the water reaches 
            _cover.SpillingWaterLevel = _cover.WaterLevelStart + bufferpressure
            The SpillingWaterLevel is needed in the headloss calculation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodeVolume.SpillingDischargeCover(System.Double,System.Double@)">
            <summary>
            Return amount of water spilling out of cover, and set dq/dh
            </summary>
            <param name="waterLevel"></param>
            <param name="dqdh"></param>
            <returns></returns>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNodeVolume._cover">
            <summary>
            Cover on this node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeVolume.Cover">
            <summary>
            Cover on this node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodeVolume.IsSpillingNode">
            <summary>
            Return true is this is node has a spilling cover
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.NetworkState">
            <summary>
             Network state. Holds a list of NetworkStateItem's.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NetworkState.Items">
            <summary>
             Items in this network state.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkState.SaveToFile(System.String)">
            <summary>
             Save network state to file
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkState.LoadFromFile(System.String)">
            <summary>
             Load network state from file
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.NetworkStateItem">
            <summary>
             A network state item. Hold an array of doubles identified by a DataHolderType, a DataType, and an ID
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateItem.#ctor">
            <summary>
             Default constructor. Does not set any values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateItem.#ctor(DHI.Mike1D.Engine.DataHolderType,System.String,DHI.Mike1D.Generic.PredefinedQuantity,System.Double[])">
            <summary>
             Create network state item with an array of values
            </summary>
            <param name="type"></param>
            <param name="id"></param>
            <param name="predefinedQuantity"></param>
            <param name="values"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.NetworkStateItem.#ctor(DHI.Mike1D.Engine.DataHolderType,System.String,DHI.Mike1D.Generic.PredefinedQuantity,System.Double)">
            <summary>
             Create network state item with a single value
            </summary>
            <param name="type"></param>
            <param name="id"></param>
            <param name="predefinedQuantity"></param>
            <param name="value"></param>
        </member>
        <member name="P:DHI.Mike1D.Engine.NetworkStateItem.Type">
            <summary>
             DataHolderType of this NetworkStateItem
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NetworkStateItem._type">
            <summary>
             Protected DataHolderType of this NetworkStateItem
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NetworkStateItem.ID">
            <summary>
             ID of this NetworkStateItem
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NetworkStateItem._id">
            <summary>
             Protected ID of this NetworkStateItem
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NetworkStateItem.PredefinedQuantity">
            <summary>
             DataType of this NetworkStateItem
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NetworkStateItem._predefinedQuantity">
            <summary>
            Protected DataType of this NetworkStateItem
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.NetworkStateItem.Values">
            <summary>
             Values of this NetworkStateItem
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.NetworkStateItem._values">
            <summary>
            Protected values of this NetworkStateItem
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNodes">
            <summary>
             List of EngineNode's, providing functionality for fast searching on node id.
             <para>
             The list does not allow nodes with the same id.
             </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNodes._list">
            <summary>
            List of all nodes in original order
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNodes._map">
            <summary>
            Map from node id to node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.#ctor">
            <summary>
             Default constructor.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.Engine.EngineNode})">
            <summary>
             Constructor initializing the list with another collection.
            </summary>
            <param name="nodes">The list to use as the initial list</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.CheckForDuplicates(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Check if the list already contains a node with the id of the new node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.Find(System.String)">
            <summary>
            Find EngineNode based on Node ID.
            </summary>
            <param name="nodeId">ID of node to find</param>
            <returns>EngineNode</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.Find(System.Predicate{DHI.Mike1D.Engine.EngineNode})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire list.
            <para>
            Linear searching, o(n), so use with care.
            </para>
            </summary>
            <param name="match">The System.Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise null.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the 
            collection, if that number is less than a threshold value.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.Add(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.Clear">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.Contains(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.CopyTo(DHI.Mike1D.Engine.EngineNode[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.Remove(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodes.Count">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodes.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.IndexOf(DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.Insert(System.Int32,DHI.Mike1D.Engine.EngineNode)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNodes.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNodes.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Engine.ProxyUtil">
            <summary>
            <para>
            Class for easing handling of proxies, and providing
            proxy functionality for the entire <see cref="T:DHI.Mike1D.Engine.EngineNet"/>,
            spanning quantities from all its modules.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.#ctor(DHI.Mike1D.Engine.EngineNet)">
            <summary>
             Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetProxy(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a proxy for the node
            Provides proxy functionality for all Modules in the engineNet
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetProxy(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a proxy for the gridpoint in the reach
            Provides proxy functionality for all Modules in the engineNet
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetProxy(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, covering a number of gridpoints
            Provides proxy functionality for all Modules in the engineNet
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetProxyReachGeneric(DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Get a proxy for the reach, generic data (not gridpoint associated).
            Provides proxy functionality for all Modules in the engineNet
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetProxy">
            <summary>
            Get a proxy for generic/global data
            Provides proxy functionality for all Modules in the engineNet
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Getter(DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:System.Func`1"/> for the node and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetterUnboxed(DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:System.Func`1"/> for the node and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Getter(DHI.Mike1D.Engine.EngineReach,System.Int32,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:System.Func`1"/> for the gridpoint and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetterUnboxed(DHI.Mike1D.Engine.EngineReach,System.Int32,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:System.Func`1"/> for the gridpoint and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Getters(DHI.Mike1D.Engine.EngineReach,System.Int32,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns a set of <see cref="T:System.Func`1"/> for the gridpoint and quantity.
            We can return several quantities with the same id (usually they will differ in their description).
            If the quantity is not offerent, an empty list is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GettersFraction(DHI.Mike1D.Engine.EngineReach,System.Int32,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns a set of <see cref="T:System.Func`1"/> for the gridpoint and quantity.
            We can return several quantities with the same id (usually they will differ in their description).
            If the quantity is not offerent, an empty list is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Getter(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IVectorGetter`1"/> for the node and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Getter(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity,System.Int32[]@)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IVectorGetter`1"/> for the reach and quantity.
            Also returns an indexList with indices of gridpoints in reach where each element value belongs to.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Getter(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity,System.Int32[]@,DHI.Mike1D.Generic.IQuantity@)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IVectorGetter`1"/> for the reach and quantity.
            Also returns an indexList with indices of gridpoints in reach where each element value belongs to.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetterRechGeneric(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IVectorGetter`1"/> for generic data on the reach and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.GetterReachGeneric(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Generic.IElementSetDefinition@)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IVectorGetter`1"/> for generic data on the reach and quantity.
            Also returns an <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/> specifying where each element value belongs to.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Getter(DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IVectorGetter`1"/> for quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Getter(DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Generic.IElementSetDefinition@)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IVectorGetter`1"/> for quantity.
            Also returns an <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/> specifying where each element value belongs to.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Setter(DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IDoubleGetSet"/> for the node and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Setter(DHI.Mike1D.Engine.EngineReach,System.Int32,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IDoubleGetSet"/> for the gridpoint and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Setter(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetSet"/> for the node and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Setter(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity,System.Int32[]@)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetSet"/> for the reach and quantity.
            Also returns an indexList with indices of gridpoints in reach where each element value belongs to.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.SetterRechGeneric(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetSet"/> for generic data on the reach and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.SetterReachGeneric(DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Generic.IElementSetDefinition@)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetSet"/> for generic data on the reach and quantity.
            Also returns an <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/> specifying where each element value belongs to.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Setter(DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetSet"/> for quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.Setter(DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Generic.IElementSetDefinition@)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetSet"/> for quantity.
            Also returns an <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/> specifying where each element value belongs to.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.SourcePoint(System.String,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Returns an <see cref="T:DHI.Mike1D.Engine.ISourcePoint"/> for the node and quantity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.SourcePoint(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Returns an <see cref="T:DHI.Mike1D.Engine.ISourcePoint"/> for the location and quantity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.SourcePoint(DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Engine.ISourcePoint"/> for the node and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.ProxyUtil.SourcePoint(DHI.Mike1D.Engine.EngineReach,System.Int32,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            Returns an <see cref="T:DHI.Mike1D.Engine.ISourcePoint"/> for the gridpoint and quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ProxyUtil.NodeProxy">
            <summary>
            Class implementing proxy functionality for a node of the <see cref="T:DHI.Mike1D.Engine.EngineNet"/>, 
            offering/accepting quantities from a list of IModules.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ProxyUtil.GridPointProxy">
            <summary>
            Class implementing proxy functionality for a gridpoint of the <see cref="T:DHI.Mike1D.Engine.EngineNet"/>, 
            offering/accepting quantities from a list of IModules.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ProxyUtil.ReachProxy">
            <summary>
            Class implementing proxy functionality for a reach of the <see cref="T:DHI.Mike1D.Engine.EngineNet"/>, 
            offering/accepting quantities from a list of IModules.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ProxyUtil.ReachGenericProxy">
            <summary>
            Class implementing proxy functionality for generic data of a reach of the <see cref="T:DHI.Mike1D.Engine.EngineNet"/>, 
            offering/accepting quantities from a list of IModules.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.ProxyUtil.GenericProxy">
            <summary>
            Class implementing proxy functionality for generic/global data of the <see cref="T:DHI.Mike1D.Engine.EngineNet"/>, 
            offering/accepting quantities from a list of IModules.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.SourceProxyExtensions">
            <summary>
            Extension class for <see cref="T:DHI.Mike1D.Engine.ISourcePointProxy"/> implementations
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourceProxyExtensions.SourcePoint(DHI.Mike1D.Engine.ISourcePointProxy,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            <para>
            From the proxy, return an <see cref="T:DHI.Mike1D.Engine.ISourcePoint"/> for the specified quantity.
            </para>
            <para>
            It returns the first quantity of that type that is offered,
            and null if the quantity is not offered.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.QGridPoint">
            <summary>
            Grid point where discharge is defined. 
            Represents the discharge from the
            prev to the next H-point. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.QGridPoint.#ctor(DHI.Mike1D.Generic.ILocation)">
            <summary>
             QGridPoint constructor. Calls GridPoint(location).
            </summary>
            <param name="location"></param>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineReachEnd">
            <summary>
            Enumeration specifying an end of the reach.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineReachEnd.Start">
            <summary>
            Start of reach (low chainage end)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineReachEnd.End">
            <summary>
            End of reach (high chainage end)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineReach">
            <summary>
            A reach is the common representation used for branch and links. A reach may hence be either a 
            part of a river or a pipe.
            <para>
            Digipoints are found in the <see cref="P:DHI.Mike1D.Engine.EngineReach.LocationSpan"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.Prepare">
            <summary>
            Called as a part of the prepare step. Calls on to each gridpoint in the reach.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.GridPoints">
            <summary>
            List of gridpoints within reach, in order from start to end of reach. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.DigiPoints">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.StartNode">
            <summary>
            Start node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.EndNode">
            <summary>
            End node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.LocationSpan">
            <summary>
            Location span that covers this reach.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.TopoID">
            <summary>
            Id for the cross section topologi that is to be used for the reach
            If no TopoID is used, set to empty string (null will be handled as the empty string).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.MaximumDx">
            <summary>
            The maximal allowed distance between two points of the same type?
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.ReverseDirection">
            <summary>
            Reverse the positive flow direction of the reach. Default is false
            </summary>
            <remarks>
            The direction of the reach has no impact on the actual calculations. 
            The following are changed with the direction:
            <list type="bullet">
            <item>Initial conditions for the discharge (also hotstart) - change of sign.</item>
            <item>Open inflow boundary conditions (Q and QH boundaries) - change of sign.</item>
            <item>Values from q-gridpoint - change of sign before value is returned</item>
            <item>Structure gridpoints - structure is reversed.</item>
            </list>
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.NonReturn">
            <summary>
            Restrict flow in the first q-grid point to be positive only. Default is false
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.IsRegulatedReach">
            <summary>
            Regulate reach with a discharge structure on first q-grid point. This is
            used for MU setups to limit Q to a QMax(H) and QMax(dH). QMax is set by a control 
            in the control module
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.IsStructureReach">
            <summary>
            A structure reach is an h-q-h reach where the q point is a structure point.
            <para>
            A structure reach does not contain any volume, and the h points have no cross sections.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.IsPressureReach">
            <summary>
            A pressure reach is a reach that is always under pressure. Pressure reaches have zero slope.
            Sections of the network can consist of pressure reaches. Downstream of these sections there are pumps,
            and upstream there are special tail nodes that function as a weir at the boundary to the normal reaches.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineReach.ReachListIndex">
            <summary>
            Index of this reach in the list of reaches. Optimization for
            fast lookup in the lists (instead of using find).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.IndexListH">
            <summary> Indices of H grid points in reach </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineReach.IndexListQ">
            <summary> Indices of Q grid points in reach </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.DivideAt(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Divide reach at <paramref name="location"/>,
            cut away the piece of the reach that is after location and returns the cut
            away piece as a new reach. <paramref name="node"/> is used for connecting the two.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.CreateNewReach">
            <summary>
            Create a new empty EngineReach of the correct type. 
            Used by the <see cref="M:DHI.Mike1D.Engine.EngineReach.DivideAt(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IDiagnostics)"/> method.
            <para>
            Override to return a specialized version of the <see cref="T:DHI.Mike1D.Engine.EngineReach"/>
            </para>
            </summary>
            <returns>A new empty engine reach of the correct type</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.GetHPointToHPointLocationSpans">
            <summary>
            Returns the location span from HGridPoint[0] to HGridPoint[1], HGridPoint[1] 
            to HGridPoint[2] and so on. They are returned as <see cref="T:DHI.Mike1D.Generic.ZLocationSpan"/>
            to provide linear interpolation in Z between the two h-points
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.GetOpenSpans">
            <summary>
            Returns the location span for all open parts of the reach, i.e., where
            the cross section is of an open type. Usually it is either the entire reach
            or not at all, but it can be 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.GetClosestUpstreamGridPoint``1(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location upstream.
            
            It is assumed that the EngineReach max and mean chainages
            are containing the given location (same location ID and
            overlapping chainage).
            </summary>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.GetClosestUpstreamGridPoint(System.Double,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Boolean)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location upstream.
            <para>
            It is assumed that the EngineReach max and min chainages
            are containing the given chainage, otherwise null is returned.
            </para>
            </summary>
            <param name="chainage">Chainage value to start search at</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <param name="allowExact">Boolean specifying whether if a grid point is found at exactly the chainage value is to be included in the search.</param>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.GetClosestDownstreamGridPoint(System.Double,System.Predicate{DHI.Mike1D.Engine.GridPoint},System.Boolean)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location upstream.
            <para>
            It is assumed that the EngineReach max and min chainages
            are containing the given chainage, otherwise null is returned.
            </para>
            </summary>
            <param name="chainage">Chainage value to start search at</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <param name="allowExact">Boolean specifying whether if a grid point is found at exactly the chainage value is to be included in the search.</param>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.GetClosestDownstreamGridPoint``1(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location downstream.
            
            It is assumed that the EngineReach max and mean chainages
            are containing the given location (same location ID and
            overlapping chainage).
            </summary>
            <returns>Closest HGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.GetClosestGridPoint``1(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Find the specified type of gridpoint which is closest to the given location.
            
            It is assumed that the EngineReach max and mean chainages
            are containing the given location (same location ID and
            overlapping chainage).
            </summary>
            <returns>Closest QGridPoint, null if none exists</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReach.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:DHI.Mike1D.Engine.CatchmentModifierInfo">
            <summary>
            Specification of where to apply a catchment value modifiers
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.CatchmentModifierInfo.CatchmentId">
            <summary>
            Id of catchment to apply modifier to
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.CatchmentModifierInfo.Quantity">
            <summary>
            Quantity to apply modifier to
            <para>
            Use e.g. one of
            <code>
            Quantity.Create(PredefinedQuantity.TotalRunOff);
            Quantity.Create(PredefinedQuantity.CatchmentDischarge);
            Quantity.Create(PredefinedQuantity.NetRainfall);
            </code>
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.CatchmentModifierInfo.Modifier">
            <summary>
            Modifier, that applies the actual value modification
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNet">
            <summary>
             The EngineNet holds the network that is used for the computations.
             
             It is the main entrance to module data/state.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.ProjectionString">
            <summary>
            Returns Projection String. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.RuntimeDiagnostics">
            <summary>
            Diagnostics instance for the engine net. Used during runtime.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.EngineTime">
            <summary>
            Simulation time. To be elaborated.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet._nodes">
            <summary>
            List of nodes in the net
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.Nodes">
            <summary>
             List of EngineNodes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.Reaches">
            <summary>
             List of Engine Reaches
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet._reachMap">
            <summary>
            Search map
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.DataModule">
            <summary>
            DataModule - always present
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.HDModule">
            <summary>
            hdModule - must always be present
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.ADModule">
            <summary>
            AD module
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.LTSModule">
            <summary>
            LTS module
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.Modules">
            <summary>
            All modules (HD, AD, WQ, ST)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet.StopwatchOverall">
            <summary>
            public because we need to access it to add other timers
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet._stopwatchAdaptiveTimeEval">
            <summary>
            Apply External Sources event
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet.StopwatchPostTimeStepEvent">
            <summary>
            public stopwatch for post time step event. When registering to the <see cref="E:DHI.Mike1D.Engine.EngineNet.PostTimeStepEvent"/>, 
            you may also add a child to this stop watch, to detail out the timings.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet.UseThreadedDomainDecomposition">
            <summary>
            Use Threaded domain decomposition
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet.domainThreadPool">
            <summary>
            Thread pool used for processing the domains created by domain decomposition
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.MaxNumberOfThreadsUser">
            <summary>
            Maximum number of threads to use.
            <para>
            Using more than one thread may give different results, due change in order of calculations 
            and therefor different rounding errors from simulation to simulation when running multiple threads. 
            If exact same results are required for each simulation, set this to 1.
            </para>
            <para>
            The number of threads actually used are limited by the smallest of
            this number, the number of logical processing units (number of CPU cores),
            the license and the OMP_NUM_THREADS environment variable.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet._numThreadsEnvStr">
            <summary> The MKL/OMP_NUM_TREADS value as read from the environment </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet._numThreadsEnvStrUpdated">
            <summary> Flag indicating the the XXX_NUM_THREADS environment variable has been updated </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.EngineNet._numThreadsEnvMkl">
            <summary> True if using the MKL_NUM_TREADS, false if using the OMP_NUM_THREADS </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.RemovableStructureLocations">
            <summary>
            List of location of structures that can be removed.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.StructureLocations">
            <summary>
            List of location of all structures. This location will be different
            for the <see cref="P:DHI.Mike1D.StructureModule.IStructure.Location"/> for side structures.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.CatchmentModifiers">
            <summary>
            Modifiers for catchment output.
            <para>
            Must be provided before prepare
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.AdditionalData">
            <summary>
            Internal method. Additional data from the MIKE 1D data object. Set during initialize.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.BaseFilePath">
            <summary>
            Internal method. Base file path of simulation. Set during initialize.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.#ctor">
            <summary>
            Create empty EngineNet.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.#ctor(DHI.Mike1D.Generic.StopwatchCollection)">
            <summary>
            Create empty EngineNet.
            
            StopwatchCollection will have added child watches
            used by the EngineNet.
            </summary>
            <param name="superswc">Add child watches to this watch</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.BuildSearchMaps">
            <summary>
            Build search maps. Whenever the list of reaches and nodes are updated, 
            this method must be called to rebuild search maps.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.FindReach(System.String)">
            <summary>
            Finds the reach that contains the specified location. If none of the reaches contains the 
            location null is returned. 
            If more than span exist with the same reachId, the first found is returned.
            </summary>
            <param name="reachId">Id of reach/span</param>
            <returns>An EngineReach with the given location or null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.FindReach(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Finds the reach that contains the specified location. If none of the reaches contains the 
            location null is returned. 
            
            If location is exactly on a node, the location can exist on more than one reaches, the
            first in the list is returned.
            </summary>
            <param name="location">Location to look for</param>
            <returns>An EngineReach with the given location or null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.FindReach(DHI.Mike1D.Generic.ILocation,System.Double)">
            <summary>
            Finds the reach that contains the specified location. If none of the reaches contains the 
            location null is returned. 
            
            If location is exactly on a node, the location can exist on more than one reaches, the
            first in the list is returned.
            </summary>
            <param name="location">Location to look for</param>
            <param name="tolerance">Tolerance accepted by the chainage when searching</param>
            <returns>An EngineReach with the given location or null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.FindAllReaches(System.String)">
            <summary>
            Finds all the reach that uses the specified name. If none of the reaches contains the 
            location null is returned. 
            </summary>
            <param name="reachName">Name of reach to look for</param>
            <returns>A set of EngineReaches with the given location or null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.TryFindReach(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.Engine.EngineReach@)">
            <summary>
            Finds the reach that contains the specified location. If none of the reaches contains the 
            location null is returned. 
            </summary>
            <param name="location">Location to look for</param>
            <param name="engineReach">An EngineReach with the given location or null if not found</param>
            <returns>True if found</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.FindNode(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Find EngineNode based on location.
            </summary>
            <param name="location">Location of node to find</param>
            <returns>EngineNode at location</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.GetClosestHGridPoint(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.Engine.EngineReach@)">
            <summary>
            Find the HGridPoint which is closest to the given location. A Reach
            must contain the given location. If no reach contains the given location, 
            null is returned.
            </summary>
            <param name="location">Location to find HGridpoint for</param>
            <param name="inReach">Outputs the reach that has the location</param>
            <returns>Closest HGridPoint, null if no reaches contains location.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.GetSourcePointSurfaceInflow(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a source point for surface inflow for the specified node. 
            The NodeMaxInflowReservoir class collects all inflow
            from surface and applies a max inflow limit to how much is forwarded to the node.
            The remainder of the inflow is stored in a reservoir "on top of" the node.
            When no limit is specified (<see cref="P:DHI.Mike1D.Engine.EngineNode.MaxInflowFromSurface"/>
            is big), all inflow is added directly to the node.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.GetComponentSourcePoint(DHI.Mike1D.Engine.EngineNode)">
            <summary>
            Get a source point for component sources. 
            <para>
            If no components are included in simulation, or if node is not part of 
            component simulation, null is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.GetComponentSourcePoint(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get a source point for component sources. 
            <para>
            The <paramref name="gridPointIndex"/> must match a grid point with
            volume, i.e. an <see cref="T:DHI.Mike1D.Engine.HGridPoint"/>.
            </para>
            <para>
            If no components are included in simulation, or if node is not part of 
            component simulation, null is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.GetComponentConcentration(DHI.Mike1D.Engine.EngineReach,System.Int32)">
            <summary>
            Get an array of all concentrations for all components at the given grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.Initialize(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            In the initialization step, the network is layed out and the engine component is 
            prepared for exchange item inspection.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeModules(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.HDParameterDataAccess.TimeStepping,System.DateTime,System.DateTime,DHI.Mike1D.ADDataAccess.ADComponentData,System.Boolean,DHI.Mike1D.STDataAccess.STData,System.Boolean,DHI.Mike1D.EcoLabDataAccess.EcoLabData,System.Boolean,System.Int32,System.Int32,DHI.Mike1D.Generic.StopwatchCollection,DHI.Mike1D.Generic.StopwatchCollection)">
            <summary>
             Initialize the modules. Called in general initialize step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeThreadPool">
            <summary>
            For threaded domain decomposition, setup thread pool.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.GetNumberOfThreadsEnvironment">
            <summary>
            Number of threads as defined by the environment variables.
            </summary>
            <returns>Number of threads, zero if not defined by environment variables.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.GetNumberOfThreads">
            <summary>
            Get the number of threads, taking the smallest of:
            input argument, the "OMP_NUM_THREADS" environment variable
            and the number of cores on the computer.
            <para>
            If the number of threads is smaller than the number of cores on 
            the computer, and "OMP_NUM_THREADS" is not set, then "OMP_NUM_THREADS"
            is set to this value.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeRoutingModule(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.CrossSectionModule.CrossSectionData,System.DateTime,DHI.Mike1D.Generic.StopwatchCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Initialize the routing module. Called in general initialize step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeHDModule(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.HDParameterDataAccess.TimeStepping,System.DateTime,System.DateTime,DHI.Mike1D.Generic.StopwatchCollection)">
            <summary>
             Initialize the HD module. Called in general initialize step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeADModule(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.Generic.StopwatchCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Initialize the routing module. Called in general initialize step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeSTModule(DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.STDataAccess.STData,DHI.Mike1D.Generic.StopwatchCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Initialize the routing module. Called in general initialize step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeELModule(DHI.Mike1D.EcoLabDataAccess.EcoLabData,DHI.Mike1D.Engine.ModuleAD.ADModule,DHI.Mike1D.Generic.StopwatchCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Initialize the routing module. Called in general initialize step
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeAdditionalOutput(DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
             Initialize additional output
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.InitializeAdAdditionalOutput(DHI.Mike1D.ADDataAccess.ADComponentData)">
            <summary>
             Initialize additional AD output
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.PrepareModules(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Call prepare on each module.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.Validate">
            <summary>
            Validate whether the EngineNet is in a valid state.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.Prepare(DHI.Mike1D.CrossSectionModule.CrossSectionData,System.DateTime,System.DateTime,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Prepares the engine for timestepping. 
            - Creates and prepares resultDataAccess components
            - Initialize the engine by either reading initial conditions, reading hotstart information, 
              by calculating steady solution or by some combination of these three
            
            Prepare() does not have to be called before OpenMI configuration phase.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.CreateRuntimeDiagnostics">
            <summary>
             Create a runtime Diagnostics instance. This is called from Mike1DController.Prepare()
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.Finish">
            <summary>
            Finish the simulation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.ErrorCheckPressureReachSections(System.Boolean)">
            <summary>
            Check for types of error specific to pressure reach sections of the network
            </summary>
            <param name="allowMultipleTailNodesInSection"></param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.StopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.ResetStopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.EngineNet.PauseSimulation">
            <summary>
            If this is true, then the simulation will pause before the next timestep
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.RunUntil(System.DateTime)">
            <summary>
            Performs time steps until the specified time is reached
            </summary>
            <param name="time">Time to run until</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.PerformTimeStep">
            <summary>
            Perform a time step. In case of failure, an exception is thrown, usually 
            through the <see cref="P:DHI.Mike1D.Engine.EngineNet.RuntimeDiagnostics"/>. 
            <para>
            In case of adaptive time stepping, this method will redo the time step 
            until the requirements are met or the minimum time step length is used.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.TryPerformTimeStep">
            <summary>
            Try to perform a single time step. 
            <para>
            In case adaptive time stepping is enabled,
            and the criterias are not met, false is returned. This method will not redo a failed 
            timestep, use <see cref="M:DHI.Mike1D.Engine.EngineNet.PerformTimeStep"/> instead.
            </para>
            <para>
            In case adaptive time stepping is not enabled, this will always return true.
            </para>
            </summary>
            <returns>True if timestep was succesfully performed.</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.TryDecreaseTimeStep">
            <summary>
            Returns true if the time step can be decreased further. Returns 
            false if adaptive time stepping is not enabled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.PrepareForTimestep(System.Int32)">
            <summary>
            Set state(n+1) = state(n), including update of _time. 
            Increase timestep if possible.
            </summary>
            <param name="redoCount">The number of times this time step is being redone</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.PerformModuleTimeStep">
            <summary>
            PerformTimeSteps tries to propagate the engine one step forward
            in time.
            </summary>
            <returns>bool indicating the success of the time step</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.FinalizeTimeStep">
            <summary>
            FinalizeTimeStep allows the modules to do operations required when 
            a time step successfully completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.ReleaseLicense">
            <summary>
            Call this to release all licenses after simulation is done.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNet.TimeStepDelegate">
            <summary>
             Delegate that is used when triggering a PreTimeStepEvent or ApplyExternalSourcesEvent.
            </summary>
            <param name="timeN">Time at start of time step</param>
            <param name="timeNp1">Time at end of time step</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineNet.TimeDelegate">
            <summary>
             Delegate that is used when triggering a PostTimeStepEvent event.
            </summary>
            <param name="time">New time of solution</param>
        </member>
        <member name="E:DHI.Mike1D.Engine.EngineNet.SpecialEvent">
            <summary>
            Special events
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.EngineNet.SimulationPreparedEvent">
            <summary>
            An event that is called when the simulation has been prepared
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.EngineNet.PreTimeStepEvent">
            <summary>
            An event that is called everytime a timestep is initiated.
            <para>
            Arguments: 
            <list type="bullet">
            <item><description>Time N</description></item>
            <item><description>Time N+1</description></item>
            <item><description>redo-counter, incremented when an adaptive time step is redone. Initially zero.</description></item>
            </list>
            </para>
            <para>
            For adaptive time stepping a timestep can be rejected and recalculated, 
            in which case this event is triggered more than once for the same time step,
            but with a different end time and the redocounter (third argument) is incremented.
            </para>
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.EngineNet.ApplyExternalSourcesEvent">
            <summary>
            An event that is called everytime external sources are to be applied
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.EngineNet.EvaluateHDImplicitSourcesEvent">
            <summary>
            An event that is called everytime external HD implicit sources are to be evaluated.
            <para>
            The event can be used when an AD component must be applied based on a HD implicit source.
            </para>
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.EngineNet.PostIterationEvent">
            <summary>
            An event that is called everytime an iteration was successfully performed.
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.EngineNet.PostTimeStepEvent">
            <summary>
            An event that is called everytime a timestep was successfully performed.
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Engine.EngineNet.SimulationDoneEvent">
            <summary>
            An event that is called when the simulation is done
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.AnyPostIterationEvent">
            <summary>
            Is there a PostIterationEvent
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.TriggerSpecialEvent(System.String)">
            <summary>
            Trigger a special event, with the provided id
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.TriggerPostIterationEvent">
            <summary>
            
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.TriggerPostTimeStepEvent">
            <summary>
            Internal trigger method. Do not use!
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.TriggerSimulationDoneEvent">
            <summary>
            Internal code, do not use
            <para>
            Trigger simulation-done event.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineNet.ReAssignBoundarySource(DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.BoundaryModule.IOpenSourceBoundary)">
            <summary>
            Reassign an open bounadry to a node.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineReachMap">
            <summary>
            Helper class for fast searcing of enginereaches
            <para>
            If storing a large amount of data in each span, consider instead one of the <see cref="T:DHI.Mike1D.Generic.NetworkData`1"/>
            classes. This class is a light-weight version of the <see cref="T:DHI.Mike1D.Generic.NetworkData`1"/> implementation.
            </para>
            <para>
            It does fast lookup in a dictionary of span-id's, containing a list of spans for each id, 
            and it does linear searching in the chainages.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReachMap.Add(DHI.Mike1D.Generic.ILocationSpan,DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Add to map
            </summary>
            <param name="span">Span that data belongs to</param>
            <param name="data">Data</param>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReachMap.Add(System.String,DHI.Mike1D.Engine.EngineReach)">
            <summary>
            Add to map
            </summary>
            <param name="reachId">Reach that data belongs to</param>
            <param name="data">Data</param>
            <returns>true if added, false if data already exists for this span</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReachMap.Sort">
            <summary>
            Sort reaches with the same name on start chainage
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReachMap.Find(System.String)">
            <summary>
            Find data based on the provided reach id. 
            If more than span exist with the same reachId, the first found is returned.
            </summary>
            <param name="reachId">Id of reach/span</param>
            <returns>Data, null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReachMap.Find(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Find data based on the provided location. 
            <para>
            It will first search without chainage tolerance, and if none found, 
            search using tolerance of <see cref="F:DHI.Mike1D.Generic.Constants.LOCATION_EQUAL_TOLERANCE"/>.
            </para>
            </summary>
            <param name="location">Location to find</param>
            <returns>Data, null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReachMap.Find(DHI.Mike1D.Generic.ILocation,System.Double)">
            <summary>
            Find data based on the provided location. 
            </summary>
            <param name="location">Location to find</param>
            <param name="tolerance">Tolerance accepted by the chainage when searching</param>
            <returns>Data, null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReachMap.FindAll(System.String)">
            <summary>
            Find data based on the provided location. 
            </summary>
            <param name="locationID">Id of location to find</param>
            <returns>Data, null if not found</returns>
        </member>
        <member name="T:DHI.Mike1D.Engine.EngineReaches">
            <summary>
             List of EngineReaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReaches.#ctor">
            <summary>
            Initializes a new instance of the list that is empty
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReaches.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.Engine.EngineReach})">
            <summary>
            Initializes a new instance of the list that contains elements 
            copied from the collection.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReaches.CreateReachSearchMap">
            <summary>
            Create a search map, containing all current reaches in the Reaches class
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Engine.EngineReaches.Find(DHI.Mike1D.Generic.ILocation)">
            <summary>
             Set value of reach given by id.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourcePointStatistics._totalInflow">
            <summary> Always positive </summary>
        </member>
        <member name="F:DHI.Mike1D.Engine.SourcePointStatistics._totalOutflow">
            <summary> Always positive </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.SourcePointStatistics.TotalInflow">
            <summary>
            Total inflow. Always positive
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.SourcePointStatistics.TotalOutflow">
            <summary>
            Total outflow. Always positive.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.SourcePointStatistics.AddInflow(System.Double,System.Double)">
            <summary>
            Update total in/outflow by adding inflow and outflow for one time step.
            </summary>
            <param name="inflowThisTimestep">Always positive, [m^3]</param>
            <param name="outflowThisTimestep">Always positive, [m^3]</param>
        </member>
        <member name="T:DHI.Mike1D.Engine.StructureGridPoint">
            <summary>
            Grid point containing one or more structures. Structure GridPoints replaces Q-points 
            in the scheme.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Engine.StructureGridPoint.CompositStructure">
            <summary>
             Composite structure is list of structures at this point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Engine.StructureGridPoint.#ctor(DHI.Mike1D.Generic.IZLocation,DHI.Mike1D.StructureModule.ICompositStructure,System.Boolean)">
            <summary>
             StructureGridPoint constructor. Calls GridPoint(location).
            </summary>
            <param name="location">Location of structure gridpoint</param>
            <param name="compositStructure">Set of structures on the gridpoint</param>
             <param name="reverseDirection">Set to true if the direction of the structure is reversed</param>
        </member>
        <member name="P:DHI.Mike1D.Engine.StructureGridPoint.ReverseDirection">
            <summary>
            Flag indiciting whether the direction of the structure is reversed compared
            to the reach positive direction. This is the case when the <see cref="P:DHI.Mike1D.Engine.EngineReach.ReverseDirection"/>
            is set.
            </summary>
        </member>
        <member name="T:DHI.MPI.MPI">
            <summary>
            Class for utilizing MPI functionality.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.rank">
            <summary> Rank of this process. </summary>
        </member>
        <member name="F:DHI.MPI.MPI.nprocesses">
            <summary> Number of processes involved. </summary>
        </member>
        <member name="F:DHI.MPI.MPI.providedThreadLevel">
            <summary> Provided thread level. </summary>
        </member>
        <member name="T:DHI.MPI.MPI.MPI_Status">
            <summary>
            Low-level representation of the status of an MPI communication operation.
            </summary>
            <remarks>
            This structure is used internally by Intel MPI
            </remarks>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_Status.count_lo">
            <summary>
            This field is only available if the underlying MPI is Intel MPI.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_Status.count_hi_and_cancelled">
            <summary>
            This field is only available if the underlying MPI is Intel MPI.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_Status.MPI_SOURCE">
            <summary>
            The rank of the source of the MPI message.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_Status.MPI_TAG">
            <summary>
            The MPI message tag associated with this communication.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_Status.MPI_ERROR">
            <summary>
            The MPI error code associated with this communication.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_COMM_WORLD">
            <summary>
              Predefined communicator containing all of the MPI processes.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_COMM_SELF">
            <summary>
              Predefined communicator containing only the calling process.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_COMM_NULL">
            <summary>
              Predefined communicator representing "no communicator". 
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_CHAR">
            <summary>
            A single character. There is no equivalent to this type in C# or .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_SIGNED_CHAR">
            <summary>
            A single, signed character. This is equivalent to the <c>sbyte</c> type
            in C# and the <c>System.SByte</c> type in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_UNSIGNED_CHAR">
            <summary>
            A single, unsigned character. There is no equivalent to this type in C# or .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_BYTE">
            <summary>
            A single byte. This is equivalent to the <c>byte</c> type
            in C# and the <c>System.Byte</c> type in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_WCHAR">
            <summary>
            A single, wide character. The equivalent is <c>char</c> in C# and <c>System.Char</c> in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_SHORT">
            <summary>
            A signed short integer. This is equivalent to the <c>short</c> type in C# and
            <c>System.Int16</c> in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_UNSIGNED_SHORT">
            <summary>
            An unsigned short integer. This is equivalent to the <c>ushort</c> type in C# and
            <c>System.UInt16</c> in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_INT">
            <summary>
            A signed integer. This is equivalent to the <c>int</c> type in C# and
            <c>System.Int32</c> in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_UNSIGNED">
            <summary>
            An unsigned integer. This is equivalent to the <c>uint</c> type in C# and
            <c>System.UInt32</c> in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_LONG">
            <summary>
            A long signed integer. There is no equivalent in C# or .NET, because the 64-bit 
            integer in C# and .NET is mapped to <see cref="F:DHI.MPI.MPI.MPI_LONG_LONG_INT"/>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_UNSIGNED_LONG">
            <summary>
            A long unsigned integer. There is no equivalent in C# or .NET, because the 64-bit 
            unsigned integer in C# and .NET is mapped to <see cref="F:DHI.MPI.MPI.MPI_UNSIGNED_LONG_LONG"/>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_FLOAT">
            <summary>
            A single-precision floating-point value. The equivalent is <c>float</c> in C#
            and <c>System.Single</c> in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_DOUBLE">
            <summary>
            A double-precision floating-point value. The equivalent is <c>double</c> in C#
            and <c>System.Double</c> in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_LONG_DOUBLE">
            <summary>
            An extended-precision floating-point value. There is no equivalent in C# or .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_LONG_LONG_INT">
            <summary>
            A long long signed integer. The equivalent is <c>long</c> in C# and
            <c>System.Int64</c> in .NET. This is a synonym for <see cref="F:DHI.MPI.MPI.MPI_LONG_LONG"/>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_UNSIGNED_LONG_LONG">
            <summary>
            A long long unsigned integer. The equivalent is <c>ulong</c> in C# and
            <c>System.UInt64</c> in .NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_LONG_LONG">
            <summary>
            A long long signed integer. The equivalent is <c>long</c> in C# and
            <c>System.Int64</c> in .NET. This is a synonym for <see cref="F:DHI.MPI.MPI.MPI_LONG_LONG_INT"/>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_PACKED">
            <summary>
            A special data type used to indicate data that has been packed with <see cref="!:MPI_Pack"/>.
            This type is only used by the lowest-level MPI operations.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_DATATYPE_NULL">
            <summary>
            A special datatype value that indicates "no datatype".
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Comm_size(System.Int32,System.Int32@)">
            <summary>
            Determines the number of processes in the communicator.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Comm_rank(System.Int32,System.Int32@)">
            <summary>
            Determines the rank of the calling process in the communicator.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Comm_compare(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Compare two communicators.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Comm_c2f(System.Int32)">
            <summary>
            Convert C communicator to Fortran communicator.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Init(System.Int32@,System.Byte**@)">
            <summary>
            Initializes MPI. This routine must be called before any other MPI routine.
            </summary>
            <param name="argc">The number of arguments in <paramref name="argv"/>.</param>
            <param name="argv">
              A pointer to an array of C-style strings containing all of
              the command-line arguments.
            </param>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_THREAD_SINGLE">
            <summary>
            Indicates that the MPI program is single-threaded. See <see cref="!:Threading.Single"/>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_THREAD_FUNNELED">
            <summary>
            Indicates that the MPI program is multi-threaded, but all MPI operations will be called
            from the main thread. See <see cref="!:Threading.Funneled"/>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_THREAD_SERIALIZED">
            <summary>
            Indicates that the MPI program is multi-threaded, but only one thread will call into MPI
            at any given time. See <see cref="!:Threading.Serialized"/>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_THREAD_MULTIPLE">
            <summary>
            Indicates that the MPI program is multi-threaded, and any thread can call into MPI
            at any time. See <see cref="!:Threading.Multiple"/>.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Init_thread(System.Int32@,System.Byte**@,System.Int32,System.Int32@)">
            <summary>
            Initializes the MPI library with thread support. This operation subsumes <see cref="M:DHI.MPI.MPI.MPI_Init(System.Int32@,System.Byte**@)"/>.
            See <see cref="!:MPI.Environment(ref string[], MPI.Threading)"/>.
            </summary>
            <param name="argc">Pointer to the number of arguments passed on the command line.</param>
            <param name="argv">Pointer to the command-line arguments (array of C-style strings).</param>
            <param name="required">
              The threading level required by the caller, which must be one of the <c>MPI_THREAD_*</c> 
              constants.
            </param>
            <param name="provided">
              Returns the actual threading level that the MPI implementation is providing, which will be
              one of the <c>MPI_THREAD_*</c> constants.
            </param>
            int MPI_Init_thread(int *argc, char ***argv, int required, int *provided) MPICH_ATTR_WEAK_ALIAS("PMPI_Init_thread");
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Is_thread_main(System.Int32@)">
            <summary>
            Determine whether the calling thread is the main MPI thread (that called <see cref="M:DHI.MPI.MPI.MPI_Init(System.Int32@,System.Byte**@)"/>
            or <see cref="M:DHI.MPI.MPI.MPI_Init_thread(System.Int32@,System.Byte**@,System.Int32,System.Int32@)"/>. See <see cref="!:MPI.Environment.IsMainThread"/>.
            </summary>
            <param name="flag">Returns whether the calling thread is the main thread.</param>
            int MPI_Is_thread_main(int *flag) MPICH_ATTR_WEAK_ALIAS("PMPI_Is_thread_main");
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Query_thread(System.Int32@)">
            <summary>
            Determine the level of threading support provided by the MPI library. 
            </summary>
            <param name="provided">Returns one of the <c>MPI_THREAD_*</c> constants.</param>
            int MPI_Query_thread(int *provided) MPICH_ATTR_WEAK_ALIAS("PMPI_Query_thread");
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Finalize">
            <summary>
            Finalizes (shuts down) MPI. This routine must be called before exiting the
            program.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Initialized(System.Int32@)">
            <summary>
            Determine whether MPI has already been initialized.
            </summary>
            <param name="flag">Will be set to a non-zero value if the MPI environment has been initialized.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Finalized(System.Int32@)">
            <summary>
            Determine whether MPI has already been finalized.
            </summary>
            <param name="flag">Will be set to a non-zero value if the MPI environment has been finalized.</param>
            <returns></returns>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Abort(System.Int32,System.Int32@)">
            <summary>
            Aborts the current MPI program.
            </summary>
            <param name="comm">The communicator that will be used to abort the program.</param>
            <param name="errcode">The error code to be returned from the MPI process.</param>
            <returns>This routine does not return.</returns>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_MAX_PROCESSOR_NAME">
            <summary>
            The maximum length of the string returned by <see cref="M:DHI.MPI.MPI.MPI_Get_processor_name(System.Byte[],System.Int32@)"/>.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Get_processor_name(System.Byte[],System.Int32@)">
            <summary>
            Retrieve the name of the processor or compute node that is currently executing.
            See <see cref="!:Environment.ProcessorName"/>.
            </summary>
            <param name="name">
              Pointer to an array of bytes that will, on return, contain the name of
              the currenly executing processor. If the processor name requires more
              than *<paramref name="len"/> ASCII characters, only the first 
              *<paramref name="len"/> characters will be written. To be sure that you
              will always get the full processor name, <paramref name="name"/> should
              refer to at least <see cref="F:DHI.MPI.MPI.MPI_MAX_PROCESSOR_NAME"/> characters.
            </param>
            <param name="len">
              A pointer to the number of bytes in the processor name. On input, this is 
              the number of bytes that <paramref name="name"/> refers to. When this
              function returns, this will point to the number of bytes in the actual name.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DHI.MPI.MPI.MPI_Get_processor_name(System.String@,System.Int32@)" -->
        <member name="F:DHI.MPI.MPI.MPI_MAX_ERROR_STRING">
            <summary>
            The maximum number of characters that can occur in an error string returned from 
            <see cref="M:DHI.MPI.MPI.MPI_Error_string(System.Int32,System.Byte[],System.Int32@)"/>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_SUCCESS">
            <summary>
            Error value indicating no error.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_BUFFER">
            <summary>
            Error class indicating an invalid buffer pointer.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_COUNT">
            <summary>
            Error class indicating an invalid count argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_TYPE">
            <summary>
            Error class indicating an invalid data type argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_TAG">
            <summary>
            Error class indicating an invalid tag argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_COMM">
            <summary>
            Error class indicating an invalid communicator.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_RANK">
            <summary>
            Error class indicating an invalid rank.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_ROOT">
            <summary>
            Error class indicating an invalid root.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_TRUNCATE">
            <summary>
            Error class indicating that a message was truncated on receive.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_GROUP">
            <summary>
            Error class indicating an invalid group argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_OP">
            <summary>
            Error class indicating an invalid operation argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_REQUEST">
            <summary>
            Error class indicating an invalid request argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_TOPOLOGY">
            <summary>
            Error class indicating an invalid topology for a communicator argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_DIMS">
            <summary>
            Error class indicating an invalid dimension argument (for cartesian communicators).
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_ARG">
            <summary>
            Error class indicating an invalid argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_OTHER">
            <summary>
            Error class indicating an error that is know, but not described by other MPI
            error classes.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_UNKNOWN">
            <summary>
            Error class indicating that an unkown error occurred.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_INTERN">
            <summary>
            Error class indicating that an internal error occurred in the MPI implementation.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_IN_STATUS">
            <summary>
            Error class indicating that the actual error code is in the status argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_PENDING">
            <summary>
            Error class indicating that a request is still pending.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_FILE">
            <summary>
            Error class indicating an invalid file handle argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_ACCESS">
            <summary>
            Error class indicating that permission was denied when accessing a file.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_AMODE">
            <summary>
            Error class indicating that the amode argument passed to MPI_File_open is invalid.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_BAD_FILE">
            <summary>
            Error class indicating an invalid file name.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_FILE_EXISTS">
            <summary>
            Error class indicating that the file already exists.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_FILE_IN_USE">
            <summary>
            Error class indicating that the file is already in use.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_NO_SPACE">
            <summary>
            Error class indicating that there is not enough space for the file.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_NO_SUCH_FILE">
            <summary>
            Error class indicating that no such file exists.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_IO">
            <summary>
            Error class indicating an I/O error.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_READ_ONLY">
            <summary>
            Error class indicating that the file is read-only.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_CONVERSION">
            <summary>
            Error class indicating that an error occurred in a user-supplied data conversion function.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_DUP_DATAREP">
            <summary>
            Error class indicating that conversion functions could not be registered because a conversion
            function has already been registered for this data representation identifier.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_UNSUPPORTED_DATAREP">
            <summary>
            Error class indicating that an unsupported data representation was passed to <c>MPI_FILE_SET_VIEW</c>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_INFO">
            <summary>
            Error class indicating an invalid info argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_INFO_KEY">
            <summary>
            Error class indicating an invalid info key.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_INFO_VALUE">
            <summary>
            Error class indicating an invalid info value.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_INFO_NOKEY">
            <summary>
            Error class indicating that the requested info key is not defined.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_NAME">
            <summary>
            Error class indicating that an attempt has been made to look up a service
            name that has not been published.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_NO_MEM">
            <summary>
            Error class indicating that no memory is available when trying to allocate
            memory with <c>MPI_Alloc_mem</c>.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_NOT_SAME">
            <summary>
            Error class indicating that a collective argument is not the same on all processes,
            or collective routines were called in a different order.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_PORT">
            <summary>
            Error class indicating that a named port does not exist or has been closed.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_QUOTA">
            <summary>
            Error class indicating that the user's quota has been exceeded.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_SERVICE">
            <summary>
            Error class indicating that an attempt to unpublish a service 
            name that has already been unpublished or never was published.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_SPAWN">
            <summary>
            Error class indicating that an attempt to spawn a process has failed.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_UNSUPPORTED_OPERATION">
            <summary>
            Error class indicating that an operation is unsupported.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_WIN">
            <summary>
            Error class indicating an invalid window argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_BASE">
            <summary>
            Error class indicating an invalid base argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_LOCKTYPE">
            <summary>
            Error class indicating an invalid locktype argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_KEYVAL">
            <summary>
            Error class indicating an invalid attribute key.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_RMA_CONFLICT">
            <summary>
            Error class indicating that there were conflicting accesses within a window.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_RMA_SYNC">
            <summary>
            Error class indicating that RMA calls were incorrectly synchronized.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_SIZE">
            <summary>
            Error class indicating an invalid size argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_DISP">
            <summary>
            Error class indicating an invalid displacement argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_ASSERT">
            <summary>
            Error class indicating an invalid assert argument.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERR_LASTCODE">
            <summary>
            The last valid error code for a predefined error class.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERRORS_ARE_FATAL">
            <summary>
            Predefined error handler that indicates that the MPI program should be terminated
            if an error occurs. This is the default error handler in the low-level MPI, which
            is overridden by MPI.NET.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERRORS_RETURN">
            <summary>
            Predefined error handler that indicates that the MPI routine that detected an error 
            should return an error code. MPI.NET uses this error handler to translate MPI 
            errors into program exceptions.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ERRHANDLER_NULL">
            <summary>
            Predefined error handler that represents "no" error handler.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Errhandler_create(System.IntPtr,System.Int32@)">
            <summary>
            Creates a new MPI error handler from a user function. Attaching this error handler 
            to a communicator will invoke the user error handler when an error occurs. 
            This feature is not supported in MPI.NET; instead, MPI.NET installs its own error
            handler that translates MPI errors into .NET exceptions.
            </summary>
            <param name="function">The user's function.</param>
            <param name="errhandler">The newly-created error handler.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Errhandler_set(System.Int32,System.Int32)">
            <summary>
            Set the error handler for a given communicator. This feature is not supported in MPI.NET; 
            instead, MPI.NET installs its own error handler that translates MPI errors into .NET exceptions.
            </summary>
            <param name="comm">The communicator.</param>
            <param name="errhandler">The error handler.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Errhandler_get(System.Int32,System.Int32@)">
            <summary>
            Retrieve the error handler for a given communicator. This feature is not supported in MPI.NET; 
            instead, MPI.NET installs its own error handler that translates MPI errors into .NET exceptions.
            </summary>
            <param name="comm">The communicator.</param>
            <param name="errhandler">The error handler attached to the communicator.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Errhandler_free(System.Int32@)">
            <summary>
            Free a user-defined error handler that was created with <see cref="M:DHI.MPI.MPI.MPI_Errhandler_create(System.IntPtr,System.Int32@)"/>.
            This feature is not supported in MPI.NET; instead, MPI.NET installs its own error handler 
            that translates MPI errors into .NET exceptions.
            </summary>
            <param name="errhandler"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Error_string(System.Int32,System.Byte[],System.Int32@)">
            <summary>
            Retrieves an error string corresponding to the given MPI error code. Used internally by
            MPI.NET to provide an error string in MPI.NET exceptions.
            </summary>
            <param name="errorcode">The error code.</param>
            <param name="text">Byte array that will be filled with a string describing the error.</param>
            <param name="resultlen">Returns the number of elements placed into the buffer <paramref name="text"/>.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Error_string(System.String@,System.Int32,System.Int32@)">
            <summary>
            Retrieves the errort string corresponding to the given MPI error code.
            </summary>
            <param name="errorcode">The error code.</param>
            <param name="text">
              String that will, on return, contain the description of the error.
            </param>
            <param name="resultlen">
              Returns the length of the string.
            </param> 
            <remarks>The method is thread safe.</remarks>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Error_class(System.Int32,System.Int32@)">
            <summary>
            Maps an MPI error code into an error class. Error classes describe (in general) what kind of
            error occurred, and can be used to provide better information to the user. The MPI_ERR_* constants
            give the various error classes present in MPI. Used internally by MPI.NET.
            </summary>
            <param name="errorcode">The error code returned from MPI.</param>
            <param name="errorclass">Set to the error class</param>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ANY_SOURCE">
            <summary>
            Predefined value for the "source" parameter to MPI receive or probe operations, 
            which indicates that a message from any process may be matched.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_ANY_TAG">
            <summary>
            Predefined value for the "tag" parameter to MPI receive or probe operations,
            which indicates that a message with any tag may be matched.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Send(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Send a message to another process within the communicator. 
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Recv(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,DHI.MPI.MPI.MPI_Status@)">
            <summary>
            Receive a message from another process within the communicator. 
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Sendrecv(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,DHI.MPI.MPI.MPI_Status@)">
            <summary>
              Simultaneously send and receive a message from another process within the communicator.
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Test_cancelled(DHI.MPI.MPI.MPI_Status@,System.Int32@)">
            <summary>
            Determine whether a particular communication operation was cancelled.
            </summary>
            <param name="status">Status object</param>
            <param name="flag">Will be set to a non-zero value if the communnication was cancelled.</param>
            <returns>Error code.</returns>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Get_count(DHI.MPI.MPI.MPI_Status@,System.Int32,System.Int32@)">
            <summary>
            Determine the number of elements transmitted by a communication operation.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_MAX">
            <summary>
            Compute the maximum value via an MPI reduction operation. 
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_MIN">
            <summary>
            Compute the minimum value via an MPI reduction operation. 
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_SUM">
            <summary>
            Compute the sum via an MPI reduction operation. 
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_PROD">
            <summary>
            Compute the product via an MPI reduction operation.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_LAND">
            <summary>
            Compute the logical AND via an MPI reduction operation.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_BAND">
            <summary>
            Compute the bitwise AND via an MPI reduction operation.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_LOR">
            <summary>
            Compute the logical OR via an MPI reduction operation.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_BOR">
            <summary>
            Compute the bitwise OR via an MPI reduction operation.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_LXOR">
            <summary>
            Compute the logical exclusive OR via an MPI reduction operation.
            There is no high-level operation corresponding to this predefined
            MPI reduction.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_BXOR">
            <summary>
            Compute the bitwise exclusive OR via an MPI reduction operation.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_MINLOC">
            <summary>
            Compute the minimum value and location of that value via
            an MPI reduction operation. There is no high-level operation
            corresponding to this predefined MPI reduction.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_MAXLOC">
            <summary>
            Compute the maximum value and location of that value via
            an MPI reduction operation. There is no high-level operation
            corresponding to this predefined MPI reduction.
            </summary>
        </member>
        <member name="F:DHI.MPI.MPI.MPI_OP_NULL">
            <summary>
            Placeholder operation that indicates "no operation".
            </summary>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Allreduce(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Perform a parallel reduction operation that summarizes the results from the input provided
            by all of the processes in the communicator. Semantically, this is equivalent to an
            <see cref="M:DHI.MPI.MPI.MPI_Reduce(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> to an arbitrary root followed by an <see cref="M:DHI.MPI.MPI.MPI_Bcast(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)"/> from 
            that process.
            </summary>
            <param name="sendbuf">
              Buffer containing the "outgoing" values contributed by the calling process to the reduction operation.
            </param>
            <param name="recvbuf">
              Buffer that will receive the results of the parallel reduction.
            </param>
            <param name="count">
              The number of elements in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.
            </param>
            <param name="datatype">
              The type of data in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.
            </param>
            <param name="op">
              The MPI reduction operation to use, which may be one of the predefined reduction operations
              or a user-defined operation created with <see cref="M:DHI.MPI.MPI.MPI_Op_create(System.IntPtr,System.Int32,System.Int32@)"/>.
            </param>
            <param name="comm">
              The communicator over which the reduction will occur.
            </param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Allgather(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Gather the values provided by each process into an array containing the contributions of all
            of the processes. This operation is equivalent to a <see cref="M:DHI.MPI.MPI.MPI_Gather(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)"/> to an arbitrary
            root followed by an <see cref="M:DHI.MPI.MPI.MPI_Bcast(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)"/> from that root.
            </summary>
            <param name="sendbuf">Buffer containing the values that will be sent from this process.</param>
            <param name="sendcount">The number of elements to send.</param>
            <param name="sendtype">The datatype describing the send buffer.</param>
            <param name="recvbuf">Buffer that will contain all of the values contributed by every process.</param>
            <param name="recvcount">The number of elements to receive from each process.</param>
            <param name="recvtype">The type of data that will be stored in the receive buffer.</param>
            <param name="comm">The communicator over which data will be gathered.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Allgatherv(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Gather the values provided by each process into an array containing the contributions of all
            of the processes. This operation differs from <see cref="M:DHI.MPI.MPI.MPI_Allgather(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)"/> in that it 
            permits different processes to provide a different number of elements to be gathered.
            </summary>
            <param name="sendbuf">Buffer containing the values that will be sent from this process.</param>
            <param name="sendcount">The number of elements to send.</param>
            <param name="sendtype">The datatype describing the send buffer.</param>
            <param name="recvbuf">Buffer that will contain all of the values contributed by every process.</param>
            <param name="recvcounts">
              An array whose ith element is the number of elements to be received from the process 
              with rank i.
            </param>
            <param name="displs">
              An array whose ith element is the offset (in <paramref name="recbuf"/>) at which the
              data from process i should be placed.
            </param>
            <param name="recvtype">The type of data that will be stored in the receive buffer.</param>
            <param name="comm">The communicator over which data will be gathered.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Alltoall(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Transmits data from every process in a communicator to every other process in the communicator.
            Similar to <see cref="M:DHI.MPI.MPI.MPI_Allgather(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)"/>, except that each process can send different data to
            every other process. To send a different amount of data to each process, use 
            <see cref="M:DHI.MPI.MPI.MPI_Alltoallv(System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32)"/> or <see cref="M:DHI.MPI.MPI.MPI_Alltoallw(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32)"/>.
            </summary>
            <param name="sendbuf">
              Buffer containing the data to send from this process. The ith position in this buffer  
              contains the data that will be sent to the process with rank i.
            </param>
            <param name="sendcount">The number of elements to send to each process.</param>
            <param name="sendtype">The type of data stored in <paramref name="sendbuf"/>.</param>
            <param name="recvbuf">
              Buffer that will receive data sent from other processes to this process.
            </param>
            <param name="recvcount">
              The number of elements that will be received from each process.
            </param>
            <param name="recvtype">The type of data stored in <paramref name="recvbuf"/>.</param>
            <param name="comm">The communicator used for collective communication.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Alltoallv(System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Transmits data from every process in a communicator to every other process in the communicator.
            Similar to <see cref="M:DHI.MPI.MPI.MPI_Allgatherv(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32)"/>, except that each process can send different data to
            every other process. If all of your processes send the same amount of data to each other, use
            the simpler <see cref="M:DHI.MPI.MPI.MPI_Alltoall(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)"/>; if you need the data sent to different processes to
            have different datatypes, use <see cref="M:DHI.MPI.MPI.MPI_Alltoallw(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32)"/>.
            </summary>
            <param name="sendbuf">
              Buffer containing the data to send from this process. The ith position in this buffer  
              contains the data that will be sent to the process with rank i.
            </param>
            <param name="sendcounts">
              An array whose ith element contains the number of elements to be send to the process with
              rank i.
            </param>
            <param name="sdispls">
              An array whose ith element contains the offsets into <paramref name="sendbuf"/> where the
              data destined for the process with rank i begins.
            </param>
            <param name="sendtype">The type of data in <paramref name="sendbuf"/>.</param>
            <param name="recvbuf">
              Buffer that will receive data sent from other processes to this process.
            </param>
            <param name="recvcounts">
              An array whose jth element contains the number of elements that will be received from the
              process with rank j.
            </param>
            <param name="rdispls">
              An array whose jth element contains the offset into <paramref name="recvbuf"/> where the
              data received from the process with rank j begins.
            </param>
            <param name="recvtype">The type of data in <paramref name="recvbuf"/>.</param>
            <param name="comm">The communicator used for collective communication.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Alltoallw(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Transmits data from every process in a communicator to every other process in the communicator.
            Similar to <see cref="M:DHI.MPI.MPI.MPI_Allgatherv(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32)"/>, except that each process can send different data to
            every other process. If all of your processes send the same amount of data to each other, use
            the simpler <see cref="M:DHI.MPI.MPI.MPI_Alltoall(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)"/>; if the volume of data sent to each process can be different
            but all of the data has the same type, use <see cref="M:DHI.MPI.MPI.MPI_Alltoallv(System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32)"/>.
            </summary>
            <param name="sendbuf">
              Buffer containing the data to send from this process. The ith position in this buffer  
              contains the data that will be sent to the process with rank i.
            </param>
            <param name="sendcnts">
              An array whose ith element contains the number of elements to be send to the process with
              rank i.
            </param>
            <param name="sdispls">
              An array whose ith element contains the offsets into <paramref name="sendbuf"/> where the
              data destined for the process with rank i begins.
            </param>
            <param name="sendtypes">
              An array whose ith element contains the type of data that will be sent to rank i.
            </param>
            <param name="recvbuf">
              Buffer that will receive data sent from other processes to this process.
            </param>
            <param name="recvcnts">
              An array whose jth element contains the number of elements that will be received from the
              process with rank j.
            </param>
            <param name="rdispls">
              An array whose jth element contains the offset into <paramref name="recvbuf"/> where the
              data received from the process with rank j begins.
            </param>
            <param name="recvtypes">
              An array whose jth element contains the type of data that will be received from the process
              with rank j.
            </param>
            <param name="comm">The communicator used for collective communication.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Barrier(System.Int32)">
            <summary>
            A synchronization barrier where no processor leaves the barrier until all processors have entered the barrier.
            See <see cref="T:System.Threading.Barrier"/>.
            </summary>
            <param name="comm">The communicator whose processes will be synchronized.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Bcast(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Broadcast a value from the root process to every process within the communication.
            </summary>
            <param name="buffer">
              Pointer to the data that will be broadcast. At the root, this buffer will be
              read; in all other processes, the buffer will be written.
            </param>
            <param name="count">The number of elements that <paramref name="buffer"/> points to.</param>
            <param name="datatype">The type of data stored in the <paramref name="buffer"/>.</param>
            <param name="root">The rank of the root processor, from which the data will be broadcast.</param>
            <param name="comm">The communicator over which the data will be transmitted.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Exscan(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Performs a partial exclusive reduction on the data, returning the result from combining the data provided 
            by the first P-1 processes to the process with rank P. 
            </summary>
            <param name="sendbuf">Buffer containing the data to contribute to the reduction.</param>
            <param name="recvbuf">Buffer that will receive the result of combining the first Rank values.</param>
            <param name="count">Number of values in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.</param>
            <param name="datatype">The type of data in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.</param>
            <param name="op">The reduction operation used to combine values.</param>
            <param name="comm">The communicator over which the communication will occur.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Gather(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Gather the values provided by each process into an array containing the contributions of all
            of the processes. This routine differs from <see cref="M:DHI.MPI.MPI.MPI_Allgather(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)"/> in that the results 
            are gathered to only the "root" process, which is identified by its <paramref name="rank"/> 
            in the communicator. 
            </summary>
            <param name="sendbuf">Buffer containing the values that will be sent from this process.</param>
            <param name="sendcount">The number of elements to send.</param>
            <param name="sendtype">The datatype describing the send buffer.</param>
            <param name="recvbuf">
              Buffer that will contain all of the values contributed by every process.
              This argument is only significant at the root.
            </param>
            <param name="recvcount">
              The number of elements to receive from each process.
              This argument is only significant at the root.
            </param>
            <param name="recvtype">
              The type of data that will be stored in the receive buffer.
              This argument is only significant at the root.
            </param>
            <param name="root">The rank of the "root" process.</param>
            <param name="comm">The communicator over which data will be gathered.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Gatherv(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Gather the values provided by each process into an array containing the contributions of all
            of the processes. This routine differs from <see cref="M:DHI.MPI.MPI.MPI_Allgather(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)"/> in that the results 
            are gathered to only the "root" process, which is identified by its <paramref name="rank"/> 
            in the communicator. 
            </summary>
            <param name="sendbuf">Buffer containing the values that will be sent from this process.</param>
            <param name="sendcount">The number of elements to send.</param>
            <param name="sendtype">The datatype describing the send buffer.</param>
            <param name="recvbuf">
              Buffer that will contain all of the values contributed by every process.
              This argument is only significant at the root.
            </param>
            <param name="recvcounts">
              An array whose ith element is the number of elements to receive from process i.
              This argument is only significant at the root.
            </param>
            <param name="displs">
              An array whose ith element contains the displacement (into <paramref name="recvbuf"/>) at
              which the data from process i will be placed. This argument is only significant at the root.
            </param>
            <param name="recvtype">
              The type of data that will be stored in the receive buffer.
              This argument is only significant at the root.
            </param>
            <param name="root">The rank of the "root" process.</param>
            <param name="comm">The communicator over which data will be gathered.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Reduce(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Perform a parallel reduction operation that summarizes the results from the data contributed
            by all of the processes in a communicator. Unlike <see cref="M:DHI.MPI.MPI.MPI_Allreduce(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)"/>, the results 
            of this operation are returned only to the process whose rank is equivalent to 
            <paramref name="root"/>, i.e., the "root" process.
            </summary>
            <param name="sendbuf">
              Buffer containing the "outgoing" values contributed by the calling process to the reduction operation.
            </param>
            <param name="recvbuf">
              Buffer that will receive the results of the parallel reduction. This argument is
              only significant at the root.
            </param>
            <param name="count">
              The number of elements in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.
            </param>
            <param name="datatype">
              The type of data in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.
            </param>
            <param name="op">
              The MPI reduction operation to use, which may be one of the predefined reduction operations
              or a user-defined operation created with <see cref="M:DHI.MPI.MPI.MPI_Op_create(System.IntPtr,System.Int32,System.Int32@)"/>.
            </param>
            <param name="root">
              Identifies the root process (which will receive the intermediate of the reduction) by
              its rank in the communicator <paramref name="comm"/>.
            </param>
            <param name="comm">
              The communicator over which the reduction will occur.
            </param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Reduce_scatter(System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            The equivalent of a <see cref="M:DHI.MPI.MPI.MPI_Reduce(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> followed by a <see cref="M:DHI.MPI.MPI.MPI_Scatterv(System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)"/>, performing a
            reduction on the data provided in <paramref name="sendbuf"/> and then scattering those results
            </summary>
            <param name="sendbuf">Buffer containing the data to be reduced.</param>
            <param name="recvbuf">Buffer that will receive this process's results.</param>
            <param name="recvcounts">
              An array whose ith element gives the number of results that will go to the process with rank i.
            </param>
            <param name="datatype">The type of data in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.</param>
            <param name="op">The operation used to combine each element in <paramref name="sendbuf"/>.</param>
            <param name="comm">The communicator over which this collective will operate.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Scan(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Performs a partial reduction on the data, returning the result from combining the data provided 
            by the first P processes to the process with rank P. 
            </summary>
            <param name="sendbuf">Buffer containing the data to contribute to the reduction.</param>
            <param name="recvbuf">Buffer that will receive the result of combining the first Rank values.</param>
            <param name="count">Number of values in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.</param>
            <param name="datatype">The type of data in <paramref name="sendbuf"/> and <paramref name="recvbuf"/>.</param>
            <param name="op">The reduction operation used to combine values.</param>
            <param name="comm">The communicator over which the communication will occur.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Scatter(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Scatters data from one process (the "root" process) to all of the processes in a communicator,
            with different parts of the data going to different processes. 
            </summary>
            <param name="sendbuf">
              Buffer containing the data to be sent. Only significant at the root process.
            </param>
            <param name="sendcount">
              The number of elements to send to each process. Only significant at the root process.
            </param>
            <param name="sendtype">
              The type of data in <paramref name="sendbuf"/>. Only significant at the root process.
            </param>
            <param name="recvbuf">A buffer that will receive the calling process's part of the data.</param>
            <param name="recvcount">The number of elements to receive.</param>
            <param name="rectype">The type of data to receive.</param>
            <param name="root">The rank of the "root" process, which supplies the data.</param>
            <param name="comm">The communicator over which the data will be scattered.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Scatterv(System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Scatters data from one process (the "root" process) to all of the processes in a communicator,
            with different parts of the data going to different processes. Unlike <see cref="M:DHI.MPI.MPI.MPI_Scatter(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)"/>,
            different processes may receive different amounts of data.
            </summary>
            <param name="sendbuf">
              Buffer containing the data to be sent. Only significant at the root process.
            </param>
            <param name="sendcounts">
              An array whose ith element contains the number of elements to send to process i.
              Only significant at the root process.
            </param>
            <param name="displs">
              An array whose ith element contains the offset (into <paramref name="sendbuf"/>)
              if the data to be sent to process i. Only significant at the root process.
            </param>
            <param name="sendtype">
              The type of data in <paramref name="sendbuf"/>. Only significant at the root process.
            </param>
            <param name="recvbuf">A buffer that will receive the calling process's part of the data.</param>
            <param name="recvcount">The number of elements to receive.</param>
            <param name="recvtype">The type of data to receive.</param>
            <param name="root">The rank of the "root" process, which supplies the data.</param>
            <param name="comm">The communicator over which the data will be scattered.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Op_create(System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Creates an MPI operation that invokes a user-provided function. The MPI operation
            can be used with various reduction operations. MPI.NET provides support for user-defined
            </summary>
            <param name="function">A pointer to the user-defined function.</param>
            <param name="commute">Whether this function is commutative.</param>
            <param name="op">Receives the newly-created MPI operation.</param>
        </member>
        <member name="M:DHI.MPI.MPI.MPI_Op_free(System.Int32@)">
            <summary>
            Frees an MPI operation created via <see cref="M:DHI.MPI.MPI.MPI_Op_create(System.IntPtr,System.Int32,System.Int32@)"/>. 
            </summary>
            <param name="op">The operation to be freed.</param>
        </member>
    </members>
</doc>
