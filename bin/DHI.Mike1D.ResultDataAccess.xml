<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DHI.Mike1D.ResultDataAccess</name>
    </assembly>
    <members>
        <member name="T:DHI.Mike1D.ResultDataAccess.AsciiBridge">
            <summary>
            Common class for ascii bridge data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._resultData">
            <summary> Result data to extract results from </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._resultSpec">
            <summary> Result specification - storing frequence is used </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._data">
            <summary> Ascii output data </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._secondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. WARNING: File flush is a potentially expensive operation. Use with care.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._maximumValue">
            <summary> Maximum value of output quantity </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._minimumValue">
            <summary> Minimum value of output quantity </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._maximumTime">
            <summary> Time of maximum value of output quantity </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._minimumTime">
            <summary> Time of minimum value of output quantity </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._doTruncate">
            <summary> Flag indicating if truncation of string should take place - only when no delimiter is defined </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._columnWidth">
            <summary> Width (minimum) of each column </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._formatDefault">
            <summary> Format string for string outputs </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._formatChainage">
            <summary> Format string for chainage outputs </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._formats">
            <summary> Format strings for dynamic and static outputs </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._culture">
            <summary> Culture to use when outputting. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.SecondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. WARNING: File flush is a potentially expensive operation. Use with care.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.Truncate(System.String)">
            <summary>
            Truncate string to column width, though only if delimiter is not defined
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.Truncate(System.String,System.Int32)">
            <summary>
            Truncate string to length, though only if delimiter is not defined
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.WriteDashLine(System.Int32)">
            <summary>
            Write a line of dashes (-) in the txt file, matching <paramref name="numColumns"/> columns of output data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.GetFormat(DHI.Mike1D.ResultDataAccess.AsciiBridge.DataItemInstance)">
            <summary>
            Get output format of dynamic item
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.DoStore(System.DateTime)">
            <summary>
            Store at this time
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.ResultDataDoStoreOverride(System.DateTime,System.DateTime@,System.Int32@,System.Boolean@)">
            <summary>
            Method to used as the <see cref="F:DHI.Mike1D.ResultDataAccess.ResultData.DoStoreUserFunction"/>, to make
            sure ResultData gets data at every time step (to update statistics)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.Save">
            <summary>
            Writes the content of the _resultDataAccess into file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.Prepare(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.SetupDynamicItems(System.Collections.Generic.List{DHI.Mike1D.Generic.IQuantity},System.Collections.Generic.List{System.Int32})">
            <summary>
            Setup dynamic items
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.WriteHeader">
            <summary>
            Write header, called in end of prepare method
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.WriteTimeSteps(System.Boolean)">
            <summary>
            Write time steps. Called during simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.Finish">
            <summary>
            Finish the file. Write dynamic statistics and static values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.WriteStaticValue(DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes,DHI.Mike1D.ResultDataAccess.IRes1DReach,System.Int32,System.String)">
            <summary>
            Write static value for the <paramref name="staticItem"/> at the reach and grid point index
            </summary>
            <param name="staticItem">Static item type to output</param>
            <param name="res1DReach">Reach</param>
            <param name="gridpointIndex">Index of grid point in reach</param>
            <param name="formatd">Format to use when writing to file</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.WriteValue(System.String,System.Double)">
            <summary>
            Write value. If value is <see cref="F:System.Double.MinValue"/>, a "-" is printed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.IsIncluded(DHI.Mike1D.ResultDataAccess.IRes1DReach,System.Int32)">
            <summary>
            Returns true if grid point on reach is included in the output.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.IsXyStaticItem(DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes)">
            <summary>
            Returns true if the static item is a (x,y) static item and prints
            two outputs.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes">
            <summary>
            Types of static outputs.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.LowestRiverBedLevel">
            <summary> Lowest level of river bed, marker 2 </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.LeftLeveeBankLevelMarker1">
            <summary> Level at left levee bank, marker 1 </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.RightLeveeBankLevelMarker3">
            <summary> Level at right levee bank, marker 3 </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.MinOfLeftAndRightLeveeBankLevel">
            <summary> Minimum of left and right levee bank level </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.LeftLowFlowBankLevelMarker4">
            <summary> Level of low flow bank, marker 4 </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.RightLowFlowBankLevelMarker5">
            <summary> Level of right low flow bank, marker 5 </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.MinOfLeftAndRightLowFlowBankLevel">
            <summary> Minimum of left and right bank level </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.CenterXYCoordinates">
            <summary> Coordinate at center of reach, (x,y) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.LeftXYCoordinates">
            <summary> Coordinate at left end of cross section </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.RightXYCoordinates">
            <summary> Coordinate at right end of cross section </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.StaticItemTypes.UserDefinedMarks">
            <summary> Level of user defined marker - not supported </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data">
            <summary>
            Ascii file format data, defining how and what is put in the ascii file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.ColumnWidth">
            <summary>
            Column width. If no delimiter is defined, strings are truncated to match this width, if delimiter is defined, no truncation takes place.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.Delimiter">
            <summary>
            Delimiter. Can be empty string for no delimiter
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.Minimum">
            <summary>  Flag indiciating if minimum value should be part of the output  </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.Maximum">
            <summary>  Flag indiciating if time of minimum value should be part of the output  </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.TimeMinimum">
            <summary>  Flag indiciating if maximum value should be part of the output  </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.TimeMaximum">
            <summary>  Flag indiciating if time of maximum value should be part of the output  </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.DynamicItems">
            <summary>
            Quantities of dynamic items
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.StaticItems">
            <summary>
            List of static items.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.NumberDecimals">
            <summary>
            Number of decimals for each dynamic and static item.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.UserDefinedNames">
            <summary>
            User defined name for dynamic and static item. Null or empty string if using default predefined names.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.Data.Statistics">
            <summary>
            Returns true if any of the statistics are enabled.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.AsciiBridge.DataItemInstance">
            <summary>
            Class where one dynamic item corresponds to one element value in one data item
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.DataItemInstance.#ctor(DHI.Mike1D.ResultDataAccess.IDataItem,System.Int32)">
            <summary> Constructor </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.DataItemInstance.DataItem">
            <summary> Data item to extract data from </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.DataItemInstance.ElementIndex">
            <summary> Element index to extract </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge.DataItemInstance.AsciiItemIndex">
            <summary> Index of dynamic item into the ascii data tables (formats and names) </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridge.DataItemInstance.GetData(System.Int32)">
            <summary>  Get data for the specified timestepIndex </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._itemPredefinedNames">
            <summary> Default predefined names for static items </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._itemPredefinedNamesYOffset">
            <summary> Offset for Y name of static item, for the XY outputs </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Ascii1Bridge">
            <summary>
            The Ascii1 bridge is a result data write bridge that is capable
            of writing the results of a result data object to a specific ascii file.
            <para>
            The Ascii1 bridge only stores reach data. All other data items
            are ignored.
            </para>
            </summary>
            <remarks>
            The Ascii1 bridge was added to support the M11 time series output.
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Ascii1Bridge._dynamicItems">
            <summary>
            Set of dynamic items to output, each item in its own column
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Ascii1Bridge._numDynamicItems">
            <summary>
            Number of dynamic items
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii1Bridge.#ctor(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Constructor
            </summary>
            <param name="resultData"></param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii1Bridge.SetupDynamicItems(System.Collections.Generic.List{DHI.Mike1D.Generic.IQuantity},System.Collections.Generic.List{System.Int32})">
            <summary>
            Dynamic items are set up in order of quantities (outer loop) and 
            data item entities (nodes / reach+grid points) (inner loop),
            and the order is stored in the <see cref="F:DHI.Mike1D.ResultDataAccess.Ascii1Bridge._dynamicItems"/>
            </summary>
            <param name="quantities">Order of quantities</param>
            <param name="asciiItemIndex">For each quantity, index into ascii data arrays</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii1Bridge.WriteHeader">
            <summary>
            Write header of text file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii1Bridge.Flush(System.Boolean)">
            <summary>
            Write the contained time steps into the file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii1Bridge.Finish">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Ascii2Bridge">
            <summary>
            The Ascii2 bridge is a result data write bridge that is capable
            of writing the results of a result data object to an ascii file.
            <para>
            The Ascii2 bridge only stores reach data. All other data items
            are ignored.
            </para>
            </summary>
            <remarks>
            The Ascii2 bridge was added to support the M11 time series output.
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Ascii2Bridge._quantities">
            <summary>
            Dynamic Quantities to output, in order
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Ascii2Bridge._asciiItemIndex">
            <summary>
            Index of each dynamic item into the ascii item lists in <see cref="F:DHI.Mike1D.ResultDataAccess.AsciiBridge._data"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii2Bridge.#ctor(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii2Bridge.SetupDynamicItems(System.Collections.Generic.List{DHI.Mike1D.Generic.IQuantity},System.Collections.Generic.List{System.Int32})">
            <summary>
            Setup dynamic data: For each output grid point (<see cref="F:DHI.Mike1D.ResultDataAccess.Ascii2Bridge._dynamicRows"/>), store
            a list of dynamic items (columns). The column can be null if that grid point does
            not offer that quantity. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii2Bridge.WriteHeader">
            <summary>
            Write header of text file - empty, there is a header for each time step.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii2Bridge.Flush(System.Boolean)">
            <summary>
            Write the contained time steps into the file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Ascii2Bridge.Finish">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.CrfBridge">
            <summary>
            Bridge for reading MOUSE CRF files.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.CrfBridge.CrfCatchmentConnection">
            <summary>
            Catchment connection information as read from .crf file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.CrfBridge.CrfCatchmentConnection.CatchmentId">
            <summary>
            Id/name of catchment
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.CrfBridge.CrfCatchmentConnection.#ctor(System.String,System.String)">
            <summary>
            Create new catchment connection
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.CrfBridge.CatchmentConnections">
            <summary>
            Catchment connections as read from .crf file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.CrfBridge.#ctor">
            <summary>
            Create CRF bridge for reading CRF eils
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.CrfBridge.#ctor(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Create CRF bridge for reading CRF eils
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.CrfBridge.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.CrfBridge.CatchmentCreated">
            <summary>
            Event triggered when a new catchment is read from the CRF file
            </summary>
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.CrfBridge.CatchmentDataItemCreated">
            <summary>
            Event triggered when a new catchment data item is read from the CRF file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.CrfBridge.ResultTypeToGeometry(System.Int32,DHI.Mike1D.Generic.IQuantity@)">
            <summary>
            ResultTypeToGeometry
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy">
            <summary>
            Data reader that utilizes the <see cref="T:DHI.Mike1D.ResultDataAccess.IResultRandomReadBridge"/>
            and adds lazy reading capabilities. Times for timestep and timesteps
            are only read on request. Filtering on quantities are respected
            if the bridge respects it, though filtering on time steps are disregarded.
            <para>
            At most <see cref="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.BufferSize"/> time steps are stored in the result data
            object, hence if reading more than <see cref="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.BufferSize"/> number of time
            steps, the first read time step are removed again (based on reading, not on
            access).
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReaderLazy._timestepsLoadedIndex">
            <summary>
            For each time step, index 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.BufferSize">
            <summary>
            Size of lazy buffer, maximum number of time steps in memory
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReaderLazy._headerKeepFileOpen">
            <summary> Flag indicating if file was kept open from header call </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyList">
            <summary>
            Lazy list of date-times. The list has the size of the number
            of time steps in the file, but actual datetimes are only
            read from the file, when they are requested the first time.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyList.ListEnumeratorDateTime">
            <summary>
            Enumerator for an <see cref="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyList"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyList.ListEnumeratorDateTime.#ctor(DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyList)">
            <summary>
            Default constructor
            </summary>
            <param name="list">List to enumerate</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepVectorDataLazyList">
            <summary>
            Lazy list of data item values, where data is stored as a list of double arrays 
            Data is stored in a dictionary, key'ed by the time step index
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepVectorDataLazyList.Clear">
            <summary>
            Not supported for lazy reading
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList">
            <summary>
            Lazy list of data item values, where data is stored as a list of doubles
            Data is stored in a dictionary, key'ed by the time step index
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.CreateDefault">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.NumberOfElements">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.GetValue(System.Int32)">
            <summary>
            Get value for the speficied time step and element
            </summary>
            <param name="timestepIndex">Index of time step</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.DHI#Mike1D#Generic#INumericArray#GetValue(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.GetValue(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.SetValue(System.Int32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.SetValue(System.Int32,System.Int32,System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.SetValues(System.Int32,System.Single[])">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.Count">
            <summary>Gets the number of elements in the collection.</summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepSingleDataLazyList.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepDataLazyList`1">
            <summary>
            Lazy list of data item values. 
            Data is stored in a dictionary, key'ed by the time step index
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepDataLazyList`1.RemoveAt(System.Int32)">
            <summary>
            Not supported for lazy reading
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.TimeStepDataLazyList`1.Clear">
            <summary>
            Not supported for lazy reading
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1">
            <summary>
            First-in-First-out queue, implemented as a circular ring buffer.
            The size is preset, and can not be incremented.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1._size">
            <summary>Maximum number of elements in buffer </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1._head">
            <summary>index of the first element in the ring buffer list</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1._tail">
            <summary>index after the last element in the ring buffer list</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1._count">
            <summary>Number of elements in queue</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1._objects">
            <summary>Ring buffer list of elements</summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1.Empty">
            <summary>
            Returns true if the queue is empty
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1.Full">
            <summary>
            Returns true if the queue is full
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1.Count">
            <summary>
            Returns the number of elements in the queue
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1.Add(`0)">
            <summary>
            Add an item to the queue. Throws an excpetion if queue is full.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.RingQueue`1.Pop">
            <summary>
            Return the first element in the queue and remove the element from the queue.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyListReadTimeOnly">
            <summary>
            Lazy list of date-times. The list has the size of the number
            of time steps in the file, but actual datetimes are only
            read from the file, when they are requested the first time.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyListReadTimeOnly.ListEnumeratorDateTime">
            <summary>
            Enumerator for an <see cref="T:DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyList"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyListReadTimeOnly.ListEnumeratorDateTime.#ctor(DHI.Mike1D.ResultDataAccess.DataReaderLazy.DateTimeLazyListReadTimeOnly)">
            <summary>
            Default constructor
            </summary>
            <param name="list">List to enumerate</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DSewerJunction">
            <summary>
            Interface for a Res1D sewer junction.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DStructure">
            <summary>
            Data description of structure
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DStructure.Type">
            <summary>
            Type of structure
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DStructure.Id">
            <summary>
            Id of structure
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DStructures">
            <summary>
            Interface for a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DStructure"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DStructures.Add(DHI.Mike1D.ResultDataAccess.IRes1DStructure)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DStructure"/> to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DStructures.Item(System.Int32)">
            <summary>
            Get or set the <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DStructure"/> at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns><see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DStructure"/> at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DStructures.Count">
            <summary>
            The number of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DStructure"/>'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DStructures.IndexOf(DHI.Mike1D.ResultDataAccess.IRes1DStructure)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DStructures.Contains(DHI.Mike1D.ResultDataAccess.IRes1DStructure)">
            <summary>
            Determines whether the list contains a specific value.
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is found in the list otherwise, false. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DStructures.Find(System.Predicate{DHI.Mike1D.ResultDataAccess.IRes1DStructure})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type IRes1DStructure. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DStructures.Remove(DHI.Mike1D.ResultDataAccess.IRes1DStructure)">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DStructures.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DStructures.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DStructures.ToArray">
            <summary>
            Copies all elements of the list to an array.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultDataHelper">
            <summary>
             Helper class that extend the functionality of ResultData
             <para>
             Required for certain functions related to COM interop.
             </para>
             </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.QuantitiesOnNodes(DHI.Mike1D.ResultDataAccess.ResultData)">
            <summary>
            Return all quantities on nodes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.QuantitiesOnReaches(DHI.Mike1D.ResultDataAccess.ResultData)">
            <summary>
            Return all quantities on reaches
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.QuantitiesOnCatchments(DHI.Mike1D.ResultDataAccess.ResultData)">
            <summary>
            Return all quantities on catchments
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.QuantitiesGlobal(DHI.Mike1D.ResultDataAccess.ResultData)">
            <summary>
            Return all global quantities
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.NetworkDataReachDataToArray(DHI.Mike1D.Generic.INetworkDataDouble)">
            <summary>
            From a network data object, return all reach data objects.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.ReachDataValuesToArray(DHI.Mike1D.Generic.INetworkReachDataDouble)">
            <summary>
            From a reach data object, return all reach location values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.NetworkDataReachData(DHI.Mike1D.Generic.INetworkDataDouble)">
            <summary>
            From a network data object, return all reach data objects as an enumerator
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.ReachDataValues(DHI.Mike1D.Generic.INetworkReachDataDouble)">
            <summary>
            From a reach data object, return all reach location values as an enumerator
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataHelper.CreateSearcher(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Create a result-data searcher
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ITimeData">
            <summary>
            Data container, storing a number of time steps and
            element values.
            <para>
            It has methods for handling as well single valued items (one element)
            and vector items with several elements.
            </para> 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ITimeData.NumberOfTimeSteps">
            <summary>
            Number of time steps. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ITimeData.NumberOfElements">
            <summary>
            Number of elements.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.Add">
            <summary>
            Adds a time step, with empty data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.Add(System.Single)">
            <summary>
            Adds a time step, setting the provided value
            <para>
            calling this method is only valid if <see cref="P:DHI.Mike1D.ResultDataAccess.ITimeData.NumberOfElements"/>
            equals 1.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.Add(System.Single[])">
            <summary>
            Adds a time step, setting the provided values
            <para>
            calling this method is only valid if <see cref="P:DHI.Mike1D.ResultDataAccess.ITimeData.NumberOfElements"/>
            is greater than 1.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.GetValue(System.Int32,System.Int32)">
            <summary>
            Get value for the speficied time step and element
            </summary>
            <param name="timestepIndex">Index of time step</param>
            <param name="elementIndex">Index of element</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.GetValues(System.Int32)">
            <summary>
            Get values for all elements for the speficied time step
            <para>
            calling this method is only valid if <see cref="P:DHI.Mike1D.ResultDataAccess.ITimeData.NumberOfElements"/>
            is greater than 1.
            </para>
            </summary>
            <param name="timestepIndex">Index of time step</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.SetValue(System.Int32,System.Int32,System.Single)">
            <summary>
            Set value at the speficied time step and element
            <para>
            For single valued items, when <see cref="P:DHI.Mike1D.ResultDataAccess.ITimeData.NumberOfElements"/> equals 1,
            set <paramref name="elementIndex"/> to zero.
            </para>
            </summary>
            <param name="timestepIndex">Index of time step</param>
            <param name="elementIndex">Index of element</param>
            <param name="value">Value</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.SetValues(System.Int32,System.Single[])">
            <summary>
            Set values for all elements at the speficied time step
            <para>
            calling this method is only valid if <see cref="P:DHI.Mike1D.ResultDataAccess.ITimeData.NumberOfElements"/>
            is greater than 1.
            </para>
            </summary>
            <param name="timestepIndex">Index of time step</param>
            <param name="values">Array of values</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.RemoveAt(System.Int32)">
            <summary>
            Remove element at specified index.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ITimeData.Clear">
            <summary>
            Remove all values from the object.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.LTSResultTypes">
            <summary> LTS simulation result types </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSResultTypes.Max">
            <summary> Maximum value event </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSResultTypes.Duration">
            <summary> Duration of an event </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSResultTypes.Integrated">
            <summary> Integrated event </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSResultTypes.IntegratedAnnual">
            <summary> Annualy integretad value </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSResultTypes.IntegratedMonthly">
            <summary> Monthly integretad value </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.LTSCalculatorTypes">
            <summary> LTS calculator types </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSCalculatorTypes.Standard">
            <summary> Standard calculator </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSCalculatorTypes.Total">
            <summary> Calculator which sums up all outflows for specified parts of network </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSCalculatorTypes.AllAD">
            <summary> Calculator which includes all AD components </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.LTSCalculatorTypes.TotalAllAD">
            <summary> Total calculator which includes all AD components </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.EventSortType">
            <summary>
            LTS sort type, when writing results to PFS file, whether to sort on time or on value.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.EventSortType.Time">
            <summary> Sort on time </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.EventSortType.Value">
            <summary> Sort on value </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.LTSResultQuantity">
            <summary>
            Result quantity for LTS simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.ResultType">
            <summary> Result type. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.CalculatorType">
            <summary> Calculator type. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.EventLimit">
            <summary> Maximum number of events to consider. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.IntereventTime">
            <summary> Interevent time criterion. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.IntereventLevelCriterion">
            <summary> Interevent level criterion. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.Filter">
            <summary> Positive filter showing which parts of the network to consider for results. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.QuantityForProxy">
            <summary> Quantity used to get result from proxy system. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.PredefinedQuantityForProxyAD">
            <summary> Predefined AD quantity used by LTSCalculatorFromProxyAD. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.PredefinedQuantityLTS">
            <summary> PredefinedQuantityLTS from which LTSResultQuantity was derived. </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.QuantityTime">
            <summary> Time quantity </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.QuantityCount">
            <summary> Event count quantity (number of events) </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.QuantityDuration">
            <summary> Duration of events quantity (number of events) </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.#ctor">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.#ctor(DHI.Mike1D.Generic.Quantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.#ctor(DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.TransferProperties(DHI.Mike1D.ResultDataAccess.LTSResultQuantity,DHI.Mike1D.ResultDataAccess.LTSResultQuantity)">
            <summary>
            Transfer all the LTSResultQuantity related properties from quantityFrom to quantityTo.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.Create(DHI.Mike1D.Generic.PredefinedQuantity,DHI.Mike1D.ResultDataAccess.LTSResultTypes,System.String)">
            <summary> Factory method to create LTSResultQuantity from PredefinedQuantity. </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.Create(DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Generic.PredefinedQuantityAD,DHI.Mike1D.ResultDataAccess.LTSResultTypes,System.String)">
            <summary> Factory method to create LTSResultQuantity from PredefinedQuantity. </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.Create(DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.ResultDataAccess.LTSResultQuantity,System.String)">
            <summary> Factory method to create LTSResultQuantity. </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.Create(DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.ResultDataAccess.LTSResultTypes,System.String)">
            <summary> Factory method to create LTSResultQuantity. </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.Create(DHI.Mike1D.Generic.IQuantity,System.String,DHI.Generic.MikeZero.eumItem)">
            <summary>
            Create a quantity with "extra" string added to Id and description.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.Create(DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS,DHI.Mike1D.ResultDataAccess.LTSResultTypes)">
            <summary> Factory method to create LTSResultQuantity from PredefinedQuantityLTS. </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSResultQuantity.Create(DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS,DHI.Mike1D.ResultDataAccess.LTSResultTypes)">
            <summary> Factory method to create LTSResultQuantity from PredefinedQuantityLTS for given AD component quantity. </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.LTSQuantities">
            <summary>
            Default quantities and result quantities used by LTS module.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSQuantities.CreateResultSpecificationForLTS(System.String,System.String,DHI.Mike1D.ResultDataAccess.ResultTypes,System.String,System.String)">
            <summary>
            Creates a result specification with given id, description, result type, file name, and base path.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.LTSQuantities.CreateResultSpecificationsForLTS(System.String,System.String)">
            <summary>
            Creates a list of default LTS result specifications.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBlockReader">
            <summary>
            Class for reading the generic blocks of the original MIKE 11 file format, 
            that is currently only used by MOUSE. File extensions that indicate a file in 
            MIKE 11 file format:
              .PRF, .CRF,
            <para>
            After connecting to the file, use the <see cref="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.GetNextBlockType"/> to
            quiery the block type, and then any of the ReadBlock methods or the SkipBlock
            to read/skip the next block. At end-of-file, <see cref="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.GetNextBlockType"/>
            returns <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.EndOfFile"/>.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType">
            <summary>
            Type of blocks in MIKE 11 file format
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.Undefined">
            <summary> Not yet set, to be used for un-initialized variables </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.EndOfFile">
            <summary> End of file, no more blocks in file </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ItemBlock0">
            <summary> Item descriptor block </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ChannelBlock1">
            <summary> Channel descriptor block </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.TimeBlock2">
            <summary> Time descriptor block </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ByteBlock3">
            <summary> Data block, byte </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.UShortBlock4">
            <summary> Data block, unsigned short (2 byte) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ShortBlock5">
            <summary> Data block, short (2 byte) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.Real48Block6">
            <summary> Data block, real48 floating point numbers </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.NotAllowedBlock7">
            <summary> Not allowed specification </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.TextBlock8">
            <summary> Data block, text </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.MiscBlock9">
            <summary> Misc block </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.Real48Block10">
            <summary> Data block, real48 floating point numbers </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.DoubleBlock11">
            <summary> Data block, doubles, 8 byte floating point numbers</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.Unknown">
            <summary> Unknown block type, usually an error </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader._blockType">
            <summary> Next block type, <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.Undefined"/> if not read yet.</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader._blockCount">
            <summary> Counting the number of blocks read </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockCount">
            <summary>
            Number of blocks read. The index matches the value of the
            <see cref="T:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType"/>, the last value is the number of 
            unknown and skipped blocks.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.Connect(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.Finish">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.GetNextBlockType">
            <summary>
            Returns the next block type. Can be called several times.
            </summary>
            <remarks>
            It reads the block type value from the file once and stores and returns the value.
            On consequtive calls, the stored values is returned. On any call to one of the
            ReadBlock methods, the stored value is reset.
            </remarks> 
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.SkipBlock">
            <summary>
            Skip next block
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock">
            <summary>
            Read and return the next block as a general object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadExtraBlocks(System.Int32)">
            <summary>
            Read a number of extra blocks, store them in a list
            </summary>
            <param name="nrXRec">Number of extra records to read</param>
            <returns>List of extra blocks and their type</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock0ItemDescriptor">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ItemBlock0"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock1ChannelDescriptor(System.Boolean)">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ChannelBlock1"/>
            </summary>
            <param name="extraBlocks">True if extra blocks is to be read</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock2TimeDescriptor">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.TimeBlock2"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock3Bytes">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ByteBlock3"/>
            It will return an array of 120 bytes.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock3Bytes(System.Byte[])">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ByteBlock3"/>
            the bytes arguement must be 120 bytes long.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock4UShorts">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.UShortBlock4"/>
            It will return an array of 60 unsigned shorts.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock5Shorts">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.ShortBlock5"/>
            It will return an array of 60 shorts.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock6Real48">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.Real48Block6"/>
            It will return an array of 20 doubles.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock7NotAllowed">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.NotAllowedBlock7"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock8Text">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.TextBlock8"/>
            The string is at most 120 characters long, only ASCII characters supported.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock9Misc">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.MiscBlock9"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock10Real48(System.Double[])">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.Real48Block10"/>.
            The <paramref name="values"/> must be an array of 20 doubles.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock10Real48">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.Real48Block10"/>.
            It will return an array of 20 doubles.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock11Doubles(System.Double[])">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.DoubleBlock11"/>
            The values array must have length 15.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadBlock11Doubles">
            <summary>
            Read and return next block, assuming it is a <see cref="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.BlockType.DoubleBlock11"/>
            It will return an array of 15 doubles.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ReadReal48(System.IO.BinaryReader)">
            <summary>
            Read a 6 byte real number from the stream
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.Real48ToDouble(System.Byte[])">
            <summary>
            Convert a 6 byte/48 bit real number to a 8 byte double value
            </summary>
            <param name="real48">Array of 6 bytes</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.Real48ToDouble(System.Byte[],System.Int32)">
            <summary>
            Convert a 6 byte/48 bit real number to a 8 byte double value
            </summary>
            <param name="real48">Array of 6 bytes</param>
            <param name="index">Start index of 6 byte/48 bit real number</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.Real48ToDouble2(System.Byte[])">
            <summary>
            Reference implementation for conversion
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ToString(System.Byte[],System.Int32)">
            <summary>
            Converts an integer array of char values, null-terminated 
            (the integer value after the last value is zero) into
            a string.
            </summary>
            <param name="strArray">Array of char values</param>
            <param name="length">Maximum length of string</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor">
            <summary>
            Item Descriptor block
            <para>
            The ITEM descripter part contains one ITEM descripter record for each type 
            of data channel. Examples of ITEMs are "water level" and "flow". If data 
            channels with values for water level as a funtion of time is to be devided 
            into groups e.g. "water level in nodes" and "water level in pipes" then there 
            must exist an ITEM descripter record for each of the groups.
            </para><para>
            Each item descripter record may represent several data channels of the 
            described ITEM.
            </para><para>
            In this part of the file no extra records are allowed. Note in particular 
            that ITEM descripter records for data channels with time values must be 
            defined too
            </para>
            <para>
            ONE item descirptor record for each type of data channel.
            </para>
            <para>
            No extra records allowed in this part
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor.RecType">
            <summary> Code number describing the type of data in the channels represented by this
            item descriptor. </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor.TypeText">
            <summary> Text describing the item. Max 80 characters (ASCII) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor.Antal">
            <summary> Number of data channels of this item type </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor.Text1">
            <summary> Text 1, max 8 characters (ASCII) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor.Text2">
            <summary> Text 2, max 8 characters (ASCII) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor.Text3">
            <summary> Text 3, max 8 characters (ASCII) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor.Text4">
            <summary> Text 4, max 8 characters (ASCII) </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor">
            <summary> 
            Channel descriptor block 
            <para>
            In the CHANNEL descripter part information is stored about each 
            specific data series in the data part of the file. In the ITEM
             descripter part there could as an example be one record describing 
            "water level in nodes". In the CHANNEL description part there must 
            be one record for each node. The record can hold individual 
            information about the node shuch as top and bottom level.
            </para>
            <para>
            Additional information about each CHANNEL may be placed in a number 
            of extra records just after the CHANNEL descripter record.
            </para>
            <para>
            ONE channel descriptor record must exist for each channel.
            </para>
            <para>
            CHANNEL descripter records MUST appear in the same order as 
            the data they represent appears in the logical data record.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.RecType">
            <summary> Code number describing the type of data in the channel. Must match an Item Descriptor RecType</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.UnitType">
            <summary> Cude number for the unit in which the data in the channel is measured </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.ChannelStr">
            <summary> Name of channel, max 40 characters (ASCII) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.Min">
            <summary> Minimum value in the data channel </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.TMin">
            <summary> Time that the minimum value was recorded (in hours) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.Max">
            <summary> Maximum value in the data channel </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.TMax">
            <summary> Time that the maximum value was recorded (in hours) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.NrXRec">
            <summary> Number of extra records belonging to this channel descriptor </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.DivInts">
            <summary> Misc integers </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.DivReal">
            <summary> Misc reals </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.Bool1">
            <summary> Bool 1 </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.Bool2">
            <summary> Bool 2 </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.Test">
            <summary> Test </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor.ExtraBlocks">
            <summary> Extra blocks, belonging to the Channel Descriptor </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.TimeDescriptor">
            <summary> 
            Time descriptor block 
            <para>
            The TIME descripter part must start with one and only one TIME descripter record. 
            This record contains information about the type of time data in the file. 
            The type of time data ranges from information about an offset time and a constant 
            time step which applies for all data channels, to individual time data for each 
            data value in each data channel.
            </para>
            <para>
            The individual information is added in a number of extra records after the TIME 
            descripter record. The number of extra records must be specified in the TIME 
            descripter record in variable NR_XREC. If there are no extra records, 
            NR_XREC is defined as zero.
            </para>
            <para>
            For rectype 1 and 2, the following values are present
            <code>
            DivReal[0] : Number of time steps/values in each data channel
            DivReal[1] : Time between first and last value, time span of file
            </code>
            </para>
            <para>
            For constant time steps, the time step size can be calculated by:
            <code>
            double timestepSize = DivReal[1] / (DivReal[0]-1.0);
            </code>
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.TimeDescriptor.RecType">
            <summary> Type of time definition. 1 = constant time step. 2 = one time channel stored in the file </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.TimeDescriptor.CreationTime">
            <summary> Time the file was created </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.TimeDescriptor.StartTime">
            <summary> Start time of channel data </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.TimeDescriptor.NrXRec">
            <summary> Number of extra blocks belonging to the time descroptor block </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.TimeDescriptor.DivInts">
            <summary> Misc integers. [0] =  </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.TimeDescriptor.DivReal">
            <summary> Misc reals. [0] = number of time steps. [1] = Simulation time span in hours. </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.TimeDescriptor.ExtraBlocks">
            <summary> Extra blocks, belonging to the Channel Descriptor </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.MiscDescriptor">
            <summary>
            Misc descriptor block
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.MiscDescriptor.Time1">
            <summary> Time 1. Used as simulation start time (wall clock) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.MiscDescriptor.Time2">
            <summary> Time 2. Used as simulation end time (wall clock) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.MiscDescriptor.Text1">
            <summary> Text 1. Max 20 characters (ASCII)</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.MiscDescriptor.Text2">
            <summary> Text 2. Max 20 characters (ASCII)</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.MiscDescriptor.Bool1">
            <summary> Bool 1</summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBlockReader.MiscDescriptor.Bool2">
            <summary> Bool 2</summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase">
            <summary>
            Base class for a bridge reading files in the old MIKE 11 File Format
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._connection">
            <summary> File name and path </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._blockReader">
            <summary> Block reader </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._resultData">
            <summary> Result data </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._unitProvider">
            <summary> Unit provider, null if not enabled </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._timeChannelIndex">
            <summary> Index of time channel </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._timeDescriptor">
            <summary> Time channel descriptor </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._numTimeSteps">
            <summary> Number of time steps in file </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._timeStep">
            <summary> Size of time step </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._simTimeSpan">
            <summary> Span of simulation </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._timeUnitSeconds">
            <summary> Seconds in one unit of time. Default is 3600 (hour time unit) </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._channelDataItemIndices">
            <summary>
            List as long as the number of channels in the prf file. For each
            channel it specifies which data item and index that the channel
            values should be stored in. Null if channel is to be disregarded.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.UnitConversionFactors.Default">
            <summary>  Default (no conversion ) factors </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase._channelUnitConversion">
            <summary>
            List as long as the number of channels in the prf file.
            Unit conversion factors for each of them
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.Connection">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.Filter">
            <summary>
            Specifies what data to load
            </summary>
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.TimeStepReadEvent">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ResultData">
            <summary>
            Result data that values are read into
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.Connect(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.Read(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ReadData(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ReadDoubles(System.Collections.Generic.List{System.Int32},System.Double[])">
            <summary>
            Fills up the <paramref name="channels"/> buffer with values from 
            the file, i.e. reads as many values from files as the number of
            elements in the buffer.
            </summary>
            <param name="channelsToLoad"></param>
            <param name="channels">Array to read data into</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.Finish">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.HandleGlobalUnknownChannel(DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor,DHI.Mike1D.Generic.IQuantity,System.Int32,DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.UnitConversionFactors)">
            <summary>
            Handle a global unknown type of channel in a generic way
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.CreateItemTypeData(DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ItemDescriptor)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ItemTypeData"/> from descriptor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.SkipBlock">
            <summary>
            Skip reading the current block
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.HRecType">
            <summary> HRecType </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.NodeRecType">
            <summary> NodeRecType </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.QRecType">
            <summary> QRecType </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.PumpRecType">
            <summary> PumpRecType </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.WeirRecType">
            <summary> WeirRecType </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.OrificeRecTypeOld">
            <summary> OrificeRecTypeOld </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.OrificeRecType">
            <summary> OrificeRecType </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ValveRecType">
            <summary> ValveRecType </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.CurbRecType">
            <summary> CurbRecType </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.VRecType">
            <summary> VRecType </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ResultTypeToGeometry(System.Int32,DHI.Mike1D.Generic.IQuantity@)">
            <summary>
            Translating all PRF result type numbers to a quantity and
            a geometry that it belongs to. For unknown types, "None" 
            is returned.
            </summary>
            <param name="resNum">PRF result type number</param>
            <param name="quantity">Quantity mathcing result type number</param>
            <returns>Geometry matching result type number</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType">
            <summary>
            Type of geometry
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Undefined">
            <summary> Undefined </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.None">
            <summary> None </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Time">
            <summary> Time </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Pipe">
            <summary> Pipe </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Node">
            <summary> Node </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Pump">
            <summary> Pump </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Valve">
            <summary> Valve </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Curb">
            <summary> Curb </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Weir">
            <summary>Weir  </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.AllWeirs">
            <summary> AllWeirs </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.GeometryType.Orifice">
            <summary> Orifice </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ItemTypeData">
            <summary>
            Item type data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ItemTypeData.Quantity">
            <summary> Quantity </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ItemTypeData.GeometryType">
            <summary> Type of geometry </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ItemTypeData.UnitConversionFactors">
            <summary> Type of geometry </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.DataItemIndex">
            <summary>
            For a channel, holds the data item and the index where to store channel values.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.DataItemIndex.DataItem">
            <summary> Data item </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.DataItemIndex.Index">
            <summary> Index in data item </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS">
            <summary>
            Enumeration of predefined quantities for LTS module.
            </summary>
            <remarks>
            Remember to add an entry to the <see cref="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityTableLTS"/> whenever
            a new <see cref="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS"/> is created.
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.Undefined">
             <summary>
            
             </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.TotalOutflow">
            <summary>
            Total water outflow out of the system
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.TotalEmission">
            <summary>
            Total emission out of the system
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.OutletsOutflow">
            <summary>
            Total water outflow out of the system through outlets
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.PumpsOutflow">
            <summary>
            Total water outflow out of the system through pumps
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.WeirsOutflow">
            <summary>
            Total water outflow out of the system through weirs
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.OrificesOutflow">
            <summary>
            Total water outflow out of the system through orifices
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.ValvesOutflow">
            <summary>
            Total water outflow out of the system through valves
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS.SpillOutflow">
            <summary>
            Total water outflow out of the system through spilling nodes
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityTableLTS">
            <summary>
            Dictionary from <see cref="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTS"/> to PredefinedQuantityLTSProperties used by LTSResultQuantity.Create()
            to create various Quantities for LTS module.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.PredefinedQuantityTableLTS.#ctor">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTSProperties">
            <summary>
            Properties for PredefinedQuantityLTS.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTSProperties.Extra">
            <summary> Extra string added to the end of the quantity id and description </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTSProperties.PredefinedQuantity">
            <summary> Extra string added to the end of the quantity id and description </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTSProperties.PredefinedQuantityAD">
            <summary> Extra string added to the end of the quantity id and description </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTSProperties.CalculatorType">
            <summary> LTS calculator type to use. </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.PredefinedQuantityLTSProperties.#ctor(System.String,DHI.Mike1D.Generic.PredefinedQuantity,DHI.Mike1D.Generic.PredefinedQuantityAD,DHI.Mike1D.ResultDataAccess.LTSCalculatorTypes)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityDataLTS">
            <summary>
            Static class containing the <see cref="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityTableLTS"/>.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PredefinedQuantityDataLTS.Table">
            <summary>
            Instance of <see cref="T:DHI.Mike1D.ResultDataAccess.PredefinedQuantityTableLTS"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.PrfBridge">
            <summary>
            Bridge for reading MOUSE PRF files. 
            <para>
            The bridge can also handle other type of MOUSE result files that has the same 
            structure as PRF file. Some of these PRF-like files are missing the full 
            network definition, and if loaded as a stand-alone file, network is not complete.
            To get complete network, data must be added to an existing "primary" file, by
            merging in the data items. Different types  of MOUSE results that are 
            supported, are listed below:
            <list type="bullet">
            <item>PRF: HD primary result output.</item>
            <item>PRF: HD result selection output. Must be added to primary PRF file</item>
            <item>XRF: HD additional output. Must be added to primary PRF file</item>
            <item>TRF: AD data. Should be added to primary PRF file, can load standalone with some definitions missing</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PrfBridge._reachNameIndices">
            <summary> Dictionary, key is reach name, value is index of reach in list </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PrfBridge._nodeNameIndices">
            <summary> Dictionary, key is node id, value is index of node in list </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.PrfBridge.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.PrfBridge.#ctor(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Constructor. Storing values in provided resultdata object.
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.PrfBridge.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.PrfBridge.HandleGridpointChannel(DHI.Mike1D.ResultDataAccess.M11FfBlockReader.ChannelDescriptor,System.Int32,System.Collections.Generic.List{DHI.Mike1D.ResultDataAccess.PrfBridge.ReachData})">
            <summary>
            Handle a grid point channel, adds the grid point to the list of grid points in the reach
            and also creates the reach, if not already existing.
            <para>
            It is assumed that the first channel descriptor for a grid point on a reach contains sufficient
            information to connect the reach to the network (start/end node, length etc.) 
            </para>
            <para>
            The reach and grid points are not actually created here (since there may be duplicate channels
            for the same grid point), so datastructures are stored in order to be able to do it correctly
            in the <see cref="M:DHI.Mike1D.ResultDataAccess.PrfBridge.CreateReaches(System.Collections.Generic.List{DHI.Mike1D.ResultDataAccess.PrfBridge.ReachData},System.Collections.Generic.Dictionary{System.Int16,DHI.Mike1D.ResultDataAccess.M11FfBridgeBase.ItemTypeData},DHI.Mike1D.Generic.IDiagnostics)"/> method.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.PrfBridge.ResultTypeToGeometry(System.Int32,DHI.Mike1D.Generic.IQuantity@)">
            <summary>
            Translating all PRF result type numbers to a quantity and
            a geometry that it belongs to. For unknown types, "None" 
            is returned.
            </summary>
            <param name="resNum">PRF result type number</param>
            <param name="quantity">Quantity mathcing result type number</param>
            <returns>Geometry matching result type number</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.PrfBridge.ReachData">
            <summary>
            Helper class used when building up reach and grid points
            from ChannelDescriptors, which each describe a grid point.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PrfBridge.ReachData.GridPoints">
            <summary> Grid points in reach </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.PrfBridge.GridPointData">
            <summary>
            Grid point data, also including which result data types exist on the grid point, 
            and where data for the result data type is found in the prf file (channel index)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PrfBridge.GridPointData.GridPoint">
            <summary> Actual grid point </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PrfBridge.GridPointData.ResultTypes">
            <summary> List of result data type numbers that are present on this grid point </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.PrfBridge.GridPointData.ChannelIndex">
            <summary> Channel index of each result data type in <see cref="F:DHI.Mike1D.ResultDataAccess.PrfBridge.GridPointData.ResultTypes"/> list </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DerivedProperties">
            <summary>
            Container class for derived properties. Derived properties are data access properties used for
            convenient access directly from ResultData as compared to accessing the same data deeper in the 
            ResultData structures. 
            
            The canonical example is ResultData.Quantities which collects all available quantities in
            ResultData.Nodes and ResultData.Reaches etc.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DerivedProperties.Generate(DHI.Mike1D.ResultDataAccess.ResultData)">
            <summary>
            Generate derived data
            </summary>
            <param name="resultData"></param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Dfs0Bridge">
            <summary>
            The Dfs0 bridge is a result data write bridge that is capable
            of writing the results of a result data object to a dfs0 file.
            <para>
            The Dfs0 bridge only stores reach data. All other data items
            are ignored.
            </para>
            </summary>
            <remarks>
            The Dfs0 bridge was added to support the M11 time series output.
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Dfs0Bridge._dynamicItems">
            <summary>
            List of same size as the dynamic items in the dfs file.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Dfs0Bridge._secondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. WARNING: File flush is a potentially expensive operation. Use with care.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.#ctor(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.SecondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. WARNING: File flush is a potentially expensive operation. Use with care.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.Save">
            <summary>
            Writes the content of the _resultDataAccess into a Dfs0 file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.Write">
            <summary>
            write everything in a file, closing and finalizing file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.Prepare(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.Flush(System.Boolean)">
            <summary>
            Write the contained time steps into the file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.WriteTimeSteps">
            <summary>
            Write all timesteps of the current result data to the file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.Finish">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Dfs0Bridge.DataItemInstance">
            <summary>
            Class where one dynamic item corresponds to one element value in one data item
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter">
            <summary>
            A filter interface that specifies whether a specified
            Res1D data structure is included or not.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter.IsIncluded(DHI.Mike1D.Generic.INetworkNode)">
            <summary>
            Returns true if the node is included by the filter
            </summary>
            <param name="node">Node</param>
            <returns>True if included</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter.IsIncluded(DHI.Mike1D.Generic.INetworkReach)">
            <summary>
            Returns true if the entire reach is included by the filter
            </summary>
            <param name="reach">Reach</param>
            <returns>True if included</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter.IsIncluded(DHI.Mike1D.Generic.INetworkReach,DHI.Mike1D.Generic.INetworkGridPoint)">
            <summary>
            Returns true if the gridpoint is included by the filter
            </summary>
            <param name="reach">Reach</param>
            <param name="gridPoint">Gridpoint in reach</param>
            <returns>True if included</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter.IsIncluded(DHI.Mike1D.Generic.INetworkCatchment)">
            <summary>
            Returns true if the catchment is included by the filter
            </summary>
            <param name="catchment">Reach</param>
            <returns>True if included</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter.IsIncludedGlobal">
            <summary>
            Returns true if the global quantity is included by the filter
            </summary>
            <returns>True if included</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAll">
            <summary>
            A filter that includes all or none of a certain type.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAll.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAll.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAll.IsIncluded(DHI.Mike1D.Generic.INetworkNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAll.IsIncluded(DHI.Mike1D.Generic.INetworkReach)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAll.IsIncluded(DHI.Mike1D.Generic.INetworkReach,DHI.Mike1D.Generic.INetworkGridPoint)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAll.IsIncluded(DHI.Mike1D.Generic.INetworkCatchment)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAll.IsIncludedGlobal">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAllQPoints">
            <summary>
            An <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter"/> that includes all
            Q grid points and excludes anything else
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAllQPoints.IsIncluded(DHI.Mike1D.Generic.INetworkNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAllQPoints.IsIncluded(DHI.Mike1D.Generic.INetworkReach)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAllQPoints.IsIncluded(DHI.Mike1D.Generic.INetworkReach,DHI.Mike1D.Generic.INetworkGridPoint)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAllQPoints.IsIncluded(DHI.Mike1D.Generic.INetworkCatchment)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterAllQPoints.IsIncludedGlobal">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet">
            <summary>
             An implementation of the <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter"/>
             containing a positive list of ids of different types that
             the filter includes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet.Nodes">
            <summary>
            The set of nodes that is included by the filter
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet.Reaches">
            <summary>
            The set of reaches (by id) that is included by the filter
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet.Catchments">
            <summary>
            The set of reaches (by id) that is included by the filter
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet.IsIncluded(DHI.Mike1D.Generic.INetworkNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet.IsIncluded(DHI.Mike1D.Generic.INetworkReach)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet.IsIncluded(DHI.Mike1D.Generic.INetworkReach,DHI.Mike1D.Generic.INetworkGridPoint)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet.IsIncluded(DHI.Mike1D.Generic.INetworkCatchment)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterSet.IsIncludedGlobal">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterTypeEnum">
            <summary>
            Type enum used in <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter"/> to specify which grid points
            on a reach to include in the filter.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterTypeEnum.None">
            <summary>
            Not included
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterTypeEnum.First">
            <summary>
            First of spatial type (grid point)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterTypeEnum.Last">
            <summary>
            Last of spatial type (grid point)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterTypeEnum.All">
            <summary>
            All of spatial type (grid point and others)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter">
            <summary>
             An implementation of the <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter"/>
             containing a positive list of ids of different types that
             the filter includes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.CheckGridpointType(DHI.Mike1D.Generic.INetworkGridPoint)">
            <summary>
            Method that may further limit the grid points to accept.
            To be overridden in 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.AddValue(DHI.Mike1D.Generic.ILocation,System.Boolean)">
            <summary>
            Add location to filter
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.AddValue(System.String,System.Boolean)">
            <summary>
            Add node to filter
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.AddGlobalReachValue(System.String,System.Boolean)">
            <summary>
            Add reach to filter, short of
            <see cref="M:DHI.Mike1D.Generic.NetworkData`1.AddGlobalReachValue(System.String,`0)"/>
            with value All (true) or None (false)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.IsIncluded(DHI.Mike1D.Generic.INetworkNode)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.IsIncluded(DHI.Mike1D.Generic.INetworkReach)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.IsReachIncluded(System.String)">
            <summary>
            Check if reach is included.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.IsIncluded(DHI.Mike1D.Generic.INetworkReach,DHI.Mike1D.Generic.INetworkGridPoint)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.IsIncluded(DHI.Mike1D.Generic.INetworkCatchment)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.IsIncludedGlobal">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter.HasValue(DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterTypeEnum,DHI.Mike1D.ResultDataAccess.Res1DSpatialFilterTypeEnum)">
            <summary>
            Method to check if the compositValue contains the value flag
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkHFilter">
            <summary>
            An <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter"/> that one reaches 
            only includes H grid points, otherwise it behaves
            as the <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkHFilter.IsReachIncluded(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkHFilter.IsIncluded(DHI.Mike1D.Generic.INetworkReach,DHI.Mike1D.Generic.INetworkGridPoint)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkHFilter.CheckGridpointType(DHI.Mike1D.Generic.INetworkGridPoint)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkQFilter">
            <summary>
            An <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter"/> that one reaches 
            only includes Q grid points, otherwise it behaves
            as the <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkQFilter.IsReachIncluded(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkQFilter.IsIncluded(DHI.Mike1D.Generic.INetworkReach,DHI.Mike1D.Generic.INetworkGridPoint)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkQFilter.CheckGridpointType(DHI.Mike1D.Generic.INetworkGridPoint)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilterAllNodes">
            <summary>
            An <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilter"/> that includes all nodes
            and only user-specified reaches and grid points.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkFilterAllNodes.IsIncluded(DHI.Mike1D.Generic.INetworkNode)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultBridgeFactory">
            <summary>
            Interface for a result bridge factory
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultBridgeFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Creates a new factory
            </summary>
            <param name="resultData">Result data object that the bridge is attached to</param>
            <returns>A new result data factory</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultBridgeFactories">
            <summary>
            Contains a number of <see cref="T:DHI.Mike1D.ResultDataAccess.IResultBridgeFactory"/>'s keyed on the bridge name
            <para>
            By default the following bridges are available:
            <list type="bullet">
            <item>res1d</item>
            <item>dfs0 - only write support</item>
            <item>res11 - only read support</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultBridgeFactories.GetFactory(System.String)">
            <summary>
            Get a factory that can create a bridge supporting the specified bridge name
            </summary>
            <param name="bridgeName">Name of bridge to get factory for</param>
            <returns>A new bridge factory. Null if no bridge factory exist for the specified bridge name.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultBridgeFactories.AddFactory(System.String,DHI.Mike1D.ResultDataAccess.IResultBridgeFactory)">
            <summary>
            Add a custom factory to the set of available factories
            </summary>
            <param name="bridgeName">Name of bridge that the factory can create</param>
            <param name="factory">Factory that can create new bridges</param>
            <returns>True if added, false if the set of bridges already contains a name equal to the one specified.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultBridgeFactories.RemoveFactory(System.String)">
            <summary>
            Remove the bridge factory with the given name from the list of available factories.
            </summary>
            <param name="bridgeName">Name of bridge factory</param>
            <returns>True if removed, false if not part of the set of factories.</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeFactory">
            <summary>
            Factory for creating Res1dBridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeLazyFactory">
            <summary>
            Factory for creating Res1d lazy Bridge reader
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeLazyFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeAppendFactory">
            <summary>
            Factory for creating Res1d append Bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeAppendFactory.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="startTime"></param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeAppendFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res11BridgeFactory">
            <summary>
            Factory for creating Res11 Bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11BridgeFactory.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="res11Dfs0">True for reading dfs0 file which was originally a res11 RR file</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11BridgeFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.PrfBridgeFactory">
            <summary>
            Factory for creating PRF Bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.PrfBridgeFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.CrfBridgeFactory">
            <summary>
            Factory for creating CRF Bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.CrfBridgeFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res11BridgeLazyFactory">
            <summary>
            Factory for creating Res11 lazy Bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11BridgeLazyFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeOldFactory">
            <summary>
            Factory for creating Res1d old format Bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOldFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Dfs0BridgeFactory">
            <summary>
            Factory for creating dfs0 Bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Dfs0BridgeFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.AsciiBridgeFactory">
            <summary>
            Factory for creating Ascii Bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.AsciiBridgeFactory.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DAppendBridge.Prepare(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Prepare the append bridge.
            <para>
            The ordinary bridge creates the file, this bridge connects to
            an existing file.
            </para>
            </summary>
            <remarks>
            The prepare methods sets up the _dynamicItems array,
            matching the data items in ResultData to the dynamic items in the file.
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DStructure">
            <summary>
            Data description of structure
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DStructure.Type">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DStructure.Id">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DStructures">
            <summary>
            Class implementing a list of IRes1DStructure's
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DStructures.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DStructures.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DStructures.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.ResultDataAccess.IRes1DStructure})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultDataExtensions">
            <summary>
            Extension class with various extension methods
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.SaveHD(DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Returns true if result is HD type
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.SaveRR(DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Returns true if result is rainfall-runoff type
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.HasVolume(DHI.Mike1D.ResultDataAccess.IRes1DNode)">
            <summary>
            Returns true if node has volume
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.Quantities(DHI.Mike1D.ResultDataAccess.IResultData,System.Boolean)">
            <summary>
            Extract all quantities of a result data object.
            </summary>
            <param name="resultData">Result data object</param>
            <param name="descriptionUnique">True if quantities are unique when description differs, or false if they are alike when description differs.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.Quantities(DHI.Mike1D.ResultDataAccess.IResultData,System.Boolean,DHI.Mike1D.Generic.IQuantities)">
            <summary>
            Extract all quantities of a result data object.
            </summary>
            <param name="resultData">Result data object</param>
            <param name="descriptionUnique">True if quantities are unique when description differs, or false if they are alike when description differs.</param>
            <param name="quantities">List to add to</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.Quantities(DHI.Mike1D.ResultDataAccess.IResultData,System.Collections.Generic.IEqualityComparer{DHI.Mike1D.Generic.IQuantity},DHI.Mike1D.Generic.IQuantities)">
            <summary>
            Extract all quantities of a result data object.
            </summary>
            <param name="resultData">Result data object</param>
            <param name="comparer">Comparer defining when quantities differs</param>
            <param name="quantities">List to add to</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.QuantityDataItems(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Extract all quantities and dataitems of a result data object, grouped by their quantity
            </summary>
            <param name="resultData">Result data object</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.RemoveTimestep(DHI.Mike1D.ResultDataAccess.IResultData,System.Int32)">
            <summary>
            Extract all quantities of a result data object.
            </summary>
            <param name="resultData">Result data object</param>
            <param name="timestepIndex">Index of timestep to remove</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.GetValue(DHI.Mike1D.ResultDataAccess.ITimeData,System.Int32,System.Double,System.Int32)">
            <summary>
            Interplate a value in <paramref name="interval"/>, with <paramref name="fraction"/>,
            for the specified <paramref name="elementIndex"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataExtensions.GetUnitProvider(DHI.Mike1D.ResultDataAccess.IResultDataParameters,DHI.Mike1D.Generic.UnitSystem)">
            <summary>
            Create unit provider from <paramref name="resultDataParameters"/>, using
            <paramref name="automaticUnitSystem"/> if <see cref="P:DHI.Mike1D.ResultDataAccess.ResultDataParameters.UnitSystem"/>
            is set to <see cref="F:DHI.Mike1D.Generic.UnitSystem.Automatic"/>.
            </summary>
            <returns>Unit provider, or null if not relevant.</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.TimeDataValueGetter">
            <summary>
            Class providing temporal interpolation of values in an <see cref="T:DHI.Mike1D.ResultDataAccess.ITimeData"/>,
            using an <see cref="T:DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator"/> for doing the interpolation.
            <para>
            The <see cref="T:DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator"/> can be used by several instances of this
            class, in case temporal interpolation is required by more than one data item at
            the same times.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValueGetter.#ctor(DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator,DHI.Mike1D.ResultDataAccess.ITimeData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValueGetter.GetValue(System.DateTime)">
            <summary>
            Interpolate a value in time.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DDataSetTimeProxy">
            <summary>
            Class wrapping an <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DDataSet"/> into the <see cref="T:DHI.Mike1D.Generic.IDoubleTimeProxy"/>.
            It requires a <see cref="T:DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator"/> for doing temporal interplation.
            <para>
            When <see cref="M:DHI.Mike1D.ResultDataAccess.Res1DDataSetTimeProxy.TimeValueGetter(System.Int32)"/> is called,
            a <see cref="T:DHI.Mike1D.ResultDataAccess.TimeDataValueGetter"/> is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DDataSetTimeProxy.#ctor(DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator,DHI.Mike1D.ResultDataAccess.IRes1DDataSet)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DDataSetTimeProxy.TimeOffers">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DDataSetTimeProxy.TimeValueGetter(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultDataHelper">
            <summary>
             Helper class that extend the functionality of ResultData
             <para>
             Required for certain functions related to COM interop.
             </para>
             </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.QuantitiesOnNodes(DHI.Mike1D.ResultDataAccess.ResultData)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.QuantitiesOnReaches(DHI.Mike1D.ResultDataAccess.ResultData)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.QuantitiesOnCatchments(DHI.Mike1D.ResultDataAccess.ResultData)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.QuantitiesGlobal(DHI.Mike1D.ResultDataAccess.ResultData)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.NetworkDataReachDataToArray(DHI.Mike1D.Generic.INetworkDataDouble)">
            <summary>
            Extract array of reaches that the network data includes
            <para>
            COM support method, since COM does not support generics.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.ReachDataValuesToArray(DHI.Mike1D.Generic.INetworkReachDataDouble)">
            <summary>
            Extract array of values that the reach data includes
            <para>
            COM support method, since COM does not support generics.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.NetworkDataReachData(DHI.Mike1D.Generic.INetworkDataDouble)">
            <summary>
            Extract ReachData as IEnumerable instead of IEnumerable{T}
            <para>
            COM support method, since COM does not support generics.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.ReachDataValues(DHI.Mike1D.Generic.INetworkReachDataDouble)">
            <summary>
            Extract values as IEnumerable instead of IEnumerable{double}
            <para>
            COM support method, since COM does not support generics.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataHelper.CreateSearcher(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Create a new <see cref="T:DHI.Mike1D.ResultDataAccess.IResultDataSearch"/> object for
            fast searching in nodes, reaches and catchments.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultDataSearch">
            <summary>
            Utility interface for searching in reaches, nodes,
            grid points and catchments in the result data object.
            <para>
            Provided for COM interop.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultDataSearch.ResultData">
            <summary>
            <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/> object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataSearch.FindNode(System.String)">
            <summary>
            Find all nodes with the provided id
            </summary>
            <param name="nodeId">Id of node</param>
            <returns>Node, null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataSearch.FindReaches(System.String)">
            <summary>
            Find all reaches with the provided name
            </summary>
            <param name="reachName">Name of reach </param>
            <returns>A list of reaches with that id, an empty list if id was not found</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataSearch.FindReach(System.String,System.Double)">
            <summary>
            Find reach at the provided location.
            <para>
            In case two reaches cover the same location
            (when one reach has been split into two at exactly
            that location), the first one (smallest start-chainage) is returned
            </para>
            </summary>
            <param name="reachName">Name of reach </param>
            <param name="chainage">Chainage within reach </param>
            <returns>Reach at location, null if not found.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataSearch.FindReach(System.String,System.Double,System.Boolean)">
            <summary>
            Find reach at the provided location.
            <para>
            In case two reaches cover the same location
            (when one reach has been split into two at exactly
            that location), you must select whether you want
            the upstream or the downstream reach.
            </para>
            </summary>
            <param name="reachName">Name of reach </param>
            <param name="chainage">Chainage within reach </param>
            <param name="downstream">Bool indicating whether you want the upstream (false) or the downstream (true) one</param>
            <returns>Reach at location, null if not found.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataSearch.FindCatchment(System.String)">
            <summary>
            Find catchment with the provided id
            </summary>
            <param name="catchmentName">Name of catchment</param>
            <returns>Catchment, null if not found</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultDataSearch">
            <summary>
            Class for fast searching in list of nodes, reaches and catchments.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataSearch.#ctor(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Create new object
            </summary>
            <param name="resultData"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultDataSearch.ResultData">
            <summary>
            <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/> object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataSearch.FindNode(System.String)">
            <summary>
            Find node with the provided id
            </summary>
            <param name="nodeId">Id of node</param>
            <returns>Node, null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataSearch.FindNodeIndex(System.String)">
            <summary>
            Find index of node with the provided id
            </summary>
            <param name="nodeId">Id of node</param>
            <returns>Node, -1 if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataSearch.FindReaches(System.String)">
            <summary>
            Find all reaches with the provided name
            </summary>
            <param name="reachName">Name of reach </param>
            <returns>A list of reaches with that id, an empty list if id was not found</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataSearch.FindReach(System.String,System.Double)">
            <summary>
            Find reach at the provided location.
            <para>
            In case two reaches cover the same location
            (when one reach has been split into two at exactly
            that location), the first one (smallest start-chainage) is returned
            </para>
            </summary>
            <param name="reachName">Name of reach </param>
            <param name="chainage">Chainage within reach </param>
            <returns>Reach at location, null if not found.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataSearch.FindReach(System.String,System.Double,System.Boolean)">
            <summary>
            Find reach at the provided location.
            <para>
            In case two reaches cover the same location
            (when one reach has been split into two at exactly
            that location), you must select whether you want
            the upstream or the downstream reach.
            </para>
            </summary>
            <param name="reachName">Name of reach </param>
            <param name="chainage">Chainage within reach </param>
            <param name="downstream">Bool indicating whether you want the upstream (false) or the downstream (true) one</param>
            <returns>Reach at location, null if not found.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataSearch.FindCatchment(System.String)">
            <summary>
            Find catchment with the provided id
            </summary>
            <param name="catchmentName">Name of catchment</param>
            <returns>Catchment, null if not found</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld">
            <summary>
            Old bridge, for reading result files before Release 2012.
            This is only included in order to read old regression test 
            results. When all regression tests have been updated to use
            latest res1d file format, this can be deleted.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType">
            <summary>
            DHI enum for file control tags and data types. From ufs.h. Also superset
            of TSobject, TimeSeries.idl (see comments on enum members)
            </summary>
            TODO : To be deleted
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_BAD">
            <summary>
            file control tag: bad
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_MIN_VALUE">
            <summary>
            file control tag: For internal use only
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_BLOCK">
            <summary>
            file control tag: For internal use only
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_TERMINATOR">
            <summary>
            file control tag: For internal use only
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_EOF">
            <summary>
            file control tag: end-of-file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_FLOAT">
            <summary>
            data type: float, in TSObject: Type_Float
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_DOUBLE">
            <summary>
            data type: double, in TSObject: Type_Double
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_CHAR">
            <summary>
            data type: char, in TSObject: Type_Char
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_INT">
            <summary>
            data type: int, in TSObject: Type_Int
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_UNSIGNED">
            <summary>
            data type: uint, in TSObject: Type_Unsigned
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_SHORT">
            <summary>
            data type: short, in TSObject: Type_Short
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_USHORT">
            <summary>
            data type: ushort, in TSObject: Type_Unsigned_Short
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType.UFS_MAX_VALUE">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Connection">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Filter">
            <summary>
            Specifies what data to load
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.SecondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. WARNING: File flush is a potentially expensive operation. Use with care.
            </summary>
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.TimeStepReadEvent">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Read(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads in the data specified by _specification and _filePath and populates the _resultData.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Save">
            <summary>
            Writes the content of the _resultDataAccess into a Res1d file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Flush(System.Boolean)">
            <summary>
            Write the contained time steps into the res11 file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.ReadFileInfo">
            <summary>
            Read up to the file info only. Properly disposes any existing FileInfo
            before reading a new one.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.ReadStaticData">
            <summary>
            read the static data. 
            for the Reaches..
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.ReadStaticDataArrayNew(System.Int32,System.Type)">
            <summary>
            Utility: Return an array of static data for the current position of the file
            pointer. Exception if failure.
            </summary>
            <param name="nData">array dimension, -1 if unknown. Ignored if next argument 
            is string</param>
            <param name="expectedType">the type of the data expected, Type.Missing.GetType
            if nothing expected. Char is not allowed, use string instead (will return a 
            string array with 1 element then). Error if discovered type differs.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Write">
            <summary>
            write everything in a file, closing and finalizing file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.WriteDynamicDataHeader">
            <summary>
            Create all dynamic items in file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.WriteDynamicDataHeaderSetItemInfo(System.Int32,DHI.Mike1D.ResultDataAccess.IDataItem,DHI.Mike1D.ResultDataAccess.ItemTypeGroup,System.Int32)">
            <summary>
            Creates a new dynamic item in the file, based on the dataitem
            </summary>
            <param name="itemIndex"></param>
            <param name="dataItem"></param>
            <param name="itemTypeGroup">Indication of what result group the data belongs to</param>
            <param name="numberWithinType">If itemTypeGroup is Global the value should be 0, 
            if itemTypeGroup is node it shold be the node number (0-based) if itemTypeGroup is reach it shold be the reach number</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Dispose">
            <summary>
            Release file memory 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType">
            <summary>
            Enums of static data types used in the static items of the DFS file.
            </summary>
            <remarks>
            The associated integers are not to be changed since the enumerations are
            casted into integers which are then persisted in the res1d file
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.MajorVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.MinorVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NumberOfUserMarkers">
            <summary>
            
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.UserMarkTitle">
            <summary>
            
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NumberOfNodes">
            <summary>
            
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NodeType">
            <summary>
            Node Type. Data follows the values of the NodeTypes enum
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NodeID">
            <summary>
            Node identification string
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NodeX">
            <summary>
            Node x-coordinate
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NodeY">
            <summary>
            Node y-coordinate
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.BottomLevel">
            <summary>
            Bottom level of Manhole, Basin or outlet
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CriticalLevel">
            <summary>
            Critical level of Manhole, Basin or outlet
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.GroundLevel">
            <summary>
            Ground level of Manhole, Basin or outlet
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.ManholeDiameter">
            <summary>
            Manhole diameter
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NumberOfReaches">
            <summary>
            Number of nodes included in the setup
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.ReachName">
            <summary>
            Name of the reach
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.TopoID">
            <summary>
            Topology specifier
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.StartNodeNumber">
            <summary>
            Number of the start node. 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.EndNodeNumber">
            <summary>
            Number of the end node
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.Direction">
            <summary>
            Direction indicator. 1 is positive -1 is negative 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NumberOfDigiPoints">
            <summary>
            Nymber of Digipoints in a given branch
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.DigiPointChainage">
            <summary>
            Chainage in the digi point
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.DigiPointXCoordinate">
            <summary>
            X-coordinate for the digi point
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.DigiPointYCoordinate">
            <summary>
            Y_coordinate for the digi point
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NumberOfGridPoints">
            <summary>
            Number of grid points within the reach
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.PointType">
            <summary>
            Grid point type, i.e. H-Point, Q-Point or ...
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.Chainage">
            <summary>
            Chainage of the point within the reach
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.GridPointX">
            <summary>
            Gridpoint x-coordinate
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.GridPointY">
            <summary>
            Gridpoint y-coordinate
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.GridPointZ">
            <summary>
            Gridpoint z-coordinate
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.UserMarkerArray">
            <summary>
            Values for each of the defined user markers
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CrossSectionID">
            <summary>
            Cross section identification string
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CrossSectionType">
            <summary>
            Cross section type (Open, Circular ... int number referes to CrossSectionTypes enum)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CrossSectionMarkerArray">
            <summary>
            Open cross sections have marker values (int array of dim 8)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CrossSectionXArray">
            <summary>
            X values for tabulated cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CrossSectionZArray">
            <summary>
            Z values for tabulated cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CrossSectionCenterLevel">
            <summary>
            Center level for circular cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CrossSectionDiameter">
            <summary>
            Diameter for circular cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CrossSectionHeightWidth">
            <summary>
            Height and width for rectangular cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.NumberOfCatchments">
            <summary>
            Number of catchments included in the setup
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CatchmentArea">
            <summary>
            Catchment area
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType.CatchmentID">
            <summary>
            Catchment ID
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeRecord">
            <summary>
            
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeRecord.#ctor(System.String,DHI.Generic.MikeZero.eumItem,DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.UfsSimpleType)">
            <summary>
            
            </summary>
            <param name="description"></param>
            <param name="eumItemKey"></param>
            <param name="ufsSimpleType"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeRecord.Description">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeRecord.EumItemKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeRecord.UfsSimpleType">
            <summary>
            
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeTable">
            <summary>
            
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeTable.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeTable.Count">
            <summary>
            Return number of data types defined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeTable.Item(DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataType)">
            <summary>
            Get a data rcord from the type
            </summary>
            <param name="Res1DStaticDataType"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeRecordMap">
            <summary>
            
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridgeOld.Res1DStaticDataTypeRecordMap.Table">
            <summary>
            
            </summary>
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.Res1DBridge.TimeStepReadEvent">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.Read(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads in the data specified by _specification and _filePath and populates _resultData.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ReadFileInfo(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read and check file info. Set start time, number of time steps, and delete value.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._lastReadItem">
            <summary>
            Used when <see cref="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ReadStaticItemNext(System.String,DHI.Mike1D.Generic.IDiagnostics,System.Boolean)"/> is to store the last read item
            and use it again next time called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.PeakStaticItemNext(System.String)">
            <summary>
            Peak the next static item.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.PeakStaticItemNameNext">
            <summary>
            Peak the next static item.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ReadStaticItemNext(System.String,DHI.Mike1D.Generic.IDiagnostics,System.Boolean)">
            <summary>
            Reads the next static item, depending on the <see cref="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._readMode"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ReadStaticData(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            read the static data. 
            for the Reaches..
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._contained">
            <summary>
            Table to indicate which items to read. Determined by the filter in ReadDynamicDataHeader()
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._predefItemData">
            <summary>
            Predefined DFS item data, used when reading, for performance.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._predefItemData0TimestepIndex">
            <summary>
            Timestep index of the predefined item data stored in <see cref="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._predefItemData"/>
            for the first item (0 index). This is required to avoid that the first item
            is read both in <see cref="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ReadTimeForTimeStep(System.Int32)"/> and in <see cref="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ReadTimeStep(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.UpdateContained">
            <summary>
            Updates the <see cref="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._contained"/> array and also
            <see cref="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.DataItemCollection.Contained"/> arrays
            for dynamic items with data for more than one data item.
            If called before header is loaded, the method has no
            effect. It must be called before 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ReadTimeForTimeStep(System.Int32)">
            <summary>
            Read the first item of the provided time step, and return the time.
            </summary>
            <param name="timestepIndex">Time step index to get time for</param>
            <returns>Date time of time step</returns>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.Res1DReadModes.ReadAndProcessAllItems">
            <summary>
            If the file version is identical to the bridge version, then
            we expect all known items to be present in the file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.Res1DReadModes.SkipReadingUnknownItems">
            <summary>
            If the file version is newer than the bridge version, then 
            we will skip unknown items in the file.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.Res1DReadModes.SkipProcessingMissingItems">
            <summary>
            If the file version is older than the bridge version, then
            we will skip processing items if they are missing in the file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.RES1D_VERSION">
            <summary>
            Version of the MIKE 1D file format 
            <para>
            The integer part is the major version number and the 
            fractional part is the minor version number.
            </para>
            <para>
            If only the minor version number differs, bridge should be
            backward and forward compatible, forward compatible meaning 
            that older bridge can read newer files, though it will usually 
            miss the new functionality 
            </para>
            <para>
            If the major version number differs, bridge will only be backward 
            compatible.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._useUbgUnits">
            <summary> Flag indicating whether file is being read in Ubg user units. Not used when writing </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._numberOfTimeSteps">
            <summary>
            Number of time step initialized during LoadHeader()
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._dynamicItems">
            <summary>
            List of same size as the dynamic items in the dfs file.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._dynamicItemsGroupTypes">
            <summary>
            When reading file, storing the item group types and number in group 
            (loaded as static data, used when reading dynamic header data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._secondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. WARNING: File flush is a potentially expensive operation. Use with care.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge._stringItemSplitOldVer2">
            <summary>
            Seperator used to split strings.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridge.Connection">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridge.Filter">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridge.SecondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. 
            <para>
            Set to zero to disable file flushing.
            </para>
            <para>
            Default value is 10 seconds.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.Save">
            <summary>
            Writes the content of the _resultDataAccess into a Res1d file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.Write">
            <summary>
            write everything in a file, closing and finalizing file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.Flush(System.Boolean)">
            <summary>
            Write the contained time steps into the res11 file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.WriteTimeSteps">
            <summary>
            Write all timesteps of the current result data to the file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.GetCoords(DHI.Mike1D.ResultDataAccess.IRes1DReach,System.Int32[])">
            <summary>
            Retrieves coordinates from data points in reach dataitem
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.GetInt(DHI.Generic.MikeZero.DFS.IDfsStaticItem,System.Int32)">
            <summary>
            Get a int from the static item at the given index
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.GetByte(DHI.Generic.MikeZero.DFS.IDfsStaticItem,System.Int32)">
            <summary>
            Get a int from the static item at the given index
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.GetInts(DHI.Generic.MikeZero.DFS.IDfsStaticItem,System.Int32,System.Int32)">
            <summary>
            Get an array of ints from the static item at the given index and length forward.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.GetDouble(DHI.Generic.MikeZero.DFS.IDfsStaticItem,System.Int32)">
            <summary>
            Get a double from the static item at the given index
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.GetFloat(DHI.Generic.MikeZero.DFS.IDfsStaticItem,System.Int32)">
            <summary>
            Get a float from the static item at the given index
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.HasNotAllZeros(DHI.Generic.MikeZero.DFS.IDfsStaticItem)">
            <summary>
            Returns true if the static int item has not all zeros.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ContainsIntValue(DHI.Generic.MikeZero.DFS.IDfsStaticItem,System.Int32)">
            <summary>
            Returns true if the static int item contains the given intValue
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.ContainsValueWithBitSet(DHI.Generic.MikeZero.DFS.IDfsStaticItem,System.Int32)">
            <summary>
            Returns true if the static int item contains a value with the given bit set
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.StringAdd(System.Text.StringBuilder@,System.String)">
            <summary>
            Call first time with null basestring, to avoid having ";" as the first character in the string.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.IDynamicItem">
            <summary>
            Interface for getting and adding data
            between a dynamic item and a (set of) data item(s)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.IDynamicItem.GetData(System.Int32,System.Single[])">
            <summary>
            Get data from ResultData and return it in array
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.IDynamicItem.AddData(System.Int32,System.Single[])">
            <summary> Add data to ResultData at the specified time step, overwrite if existing </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DBridge.IDynamicItem.UserUnit">
            <summary> User unit of DFS dynamic item. </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.DataItemInstance">
            <summary>
            Class where one dynamic item corresponds to one data item
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.DataItemCollectionBase">
            <summary>
            Base class for DataItemCollection's
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.DataItemCollection">
            <summary>
            Class where one dynamic item corresponds to
            a set of data items, all having just one value (nodes or catchments).
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.DataItemReachCollection">
            <summary>
            Class where one dynamic item corresponds to
            a set of reach data items, each having many values.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.DataItemCollectionInfo">
            <summary>
            Helper class for storing information on a node-dynamic item
            before the builder is created.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes">
            <summary>
            Type of cross section.
            <para>
            The values from 1024 and above are used for different flags, 
            describing the cross section. 
            </para>
            <para>
            Negative values specify either an undefined or a not set cross section type, which
            will not be stored in the result file
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.NotSet">
            <summary>
            Cross section data not set
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.Unknown">
            <summary>
            Unknown cross section type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.Open">
            <summary>
            Open cross section with XZ points and markers (lists can be empty, i.e., no points/markers)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.ClosedPolygon">
            <summary>
            Closed cross section with XZ points (lists can be empty, i.e., no points)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.Circular">
            <summary>
            Circular cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.EggShaped">
            <summary>
            Circular egg-shaped cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.OShaped">
            <summary>
            Circular o-shaped cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.Rectangular">
            <summary>
            Rectangular cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.Interpolated">
            <summary>
            Interpolated cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.XzPointFlag">
            <summary>
            Flag defining if cross section has XZ points. Uses 2^10 bit.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.MarkersFlag">
            <summary>
            Flag defining if cross section has markers. Uses 2^11 bit.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.CircularFlag">
            <summary>
            Flag defining if cross section has centerlevel + diameter. Uses 2^12 bit.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DBridge.CrossSectionTypes.RectangularFlag">
            <summary>
            Flag defining if cross section has width+height. Uses 2^13 bit.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg">
            <summary>
            Converter class for converting item data and item units to UBG (Unit Base Group)
            <para>
            This will convert the data and update the unit of the item quantity (but NOT the spatial axis).
            </para>
            <para>
            Be carefull when using this converter, and updating the item quantity: The underlying
            data is stored in the new unit, but and it is still assumed that the outgoing/incoming data
            is in UBG units.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.Initialize(DHI.Generic.MikeZero.DFS.IDfsFile)">
            <summary>
            Initialise this data converter for working on the given <paramref name="dfsFile"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.Convert(DHI.Generic.MikeZero.DFS.IDfsDynamicItemInfo)">
            <summary>
            Convert the dynamic item information, <see cref="T:DHI.Generic.MikeZero.DFS.IDfsDynamicItemInfo"/>.
            It sets the unit and axis unit conversion to <see cref="F:DHI.Generic.MikeZero.DFS.UnitConversionType.UbgConversion"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.Convert(DHI.Generic.MikeZero.DFS.IDfsItemData)">
            <summary>
            Convert the dynamic item data, <see cref="T:DHI.Generic.MikeZero.DFS.IDfsItemData"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.Revert(System.Int32,System.Array)">
            <summary>
            Revert the dynamic item data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.Convert(DHI.Generic.MikeZero.DFS.IDfsStaticItem)">
            <summary>
            Convert a static item, including its data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.Revert(DHI.Generic.MikeZero.DFS.IDfsStaticItem@,System.Array@)">
            <summary>
            Revert the static item data.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.MyDynamicItemInfo">
            <summary>
            Private helper class that updates the units to UBG (Unit Base Group),
            in the <see cref="P:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.MyDynamicItemInfo.Quantity"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.MyStaticItem">
            <summary>
            Private helper class that updates the units to UBG (Unit Base Group),
            in the <see cref="P:DHI.Mike1D.ResultDataAccess.Res1DBridge.DfsConverterToUbg.MyStaticItem.Quantity"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DStructureReach">
            <summary>
            Data desription and time step data for a reach that only contains a structure
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultDataParameters">
            <summary>
            Parameters to use when loading data into an <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.Filter">
            <summary>
            Filter to use when loading
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.UseSIUnits">
            <summary>
            Flag specifying whether to load data in SI units or
            in stored unit (SI for res1d, misc for res11).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.UseUbgUnits">
            <summary>
            Flag specifying whether to load data in UBG (Unit Base Group) units. or
            in stored unit (SI for res1d, misc for res11).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.UnitSystem">
            <summary>
            Unit system to use when loading the file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.UnitProvider">
            <summary>
            User defined unit provider
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.ConvertGeometry">
            <summary>
            Flag specifying whether to convert planar geometry
            values, i.e. those that goes on a map, being x, y and chainage values.
            <para>
            Z values (height) are always converted
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultDataParameters">
            <summary>
            Base implementation of <see cref="T:DHI.Mike1D.ResultDataAccess.IResultDataParameters"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultDataParameters.Filter">
            <summary>
            Filter to use when loading
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultDataParameters.UseSIUnits">
            <summary>
            Flag specifying whether to load data in SI units or
            in stored unit (SI for res1d, misc for res11).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultDataParameters.UseUbgUnits">
            <summary>
            Flag specifying whether to load data in UBG (Unit Base Group) units. or
            in stored unit (SI for res1d, misc for res11).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultDataParameters.UnitSystem">
            <summary>
            Unit system to use when loading the file.
            <para>
            This will not update the value of the <see cref="P:DHI.Mike1D.ResultDataAccess.IResultData.UnitSystem"/>,
            when a result data object is loaded from storage.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultDataParameters.UnitProvider">
            <summary>
            User defined unit provider
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultDataParameters.ConvertGeometry">
            <summary>
            Flag specifying whether to convert planar geometry
            values, i.e. those that goes on a map, being x, y and chainage values.
            <para>
            Z values (height) are always converted
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DExtensions">
            <summary>
            Class containing extension methods for Res1D classes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.LocationSpan(DHI.Mike1D.ResultDataAccess.IRes1DReach)">
            <summary>
             Extension method to create a LocationSpan from a reach.
            </summary>
            <param name="reach"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.StartChaiange(DHI.Mike1D.ResultDataAccess.IRes1DReach)">
            <summary>
             Extension method return the start chainage of a reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.StartChainage(DHI.Mike1D.ResultDataAccess.IRes1DReach)">
            <summary>
             Extension method return the start chainage of a reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.EndChainage(DHI.Mike1D.ResultDataAccess.IRes1DReach)">
            <summary>
             Extension method return the end chainage of a reach
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.GridpointSearch(DHI.Mike1D.ResultDataAccess.IRes1DReach,System.Double)">
            <summary>
             Extension method searching within the grid points of a reach, using
             a binary search routine.
            </summary>
             <returns>The zero-based index of grid point, if an exact match is found; 
             otherwise, a negative number that is the bitwise complement 
             of the index of the next grid point with chainage that is larger or, 
             if there is no larger element, the bitwise complement of Count.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.Coordinate(DHI.Mike1D.ResultDataAccess.IRes1DGridPoint)">
            <summary>
            Create coordinate of grid point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.GetLeftRightCoordinates(DHI.Mike1D.ResultDataAccess.IRes1DReach,System.Int32,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate@,DHI.Mike1D.Generic.Spatial.Geometry.Coordinate@)">
            <summary>
            Get coordinates left/right of grid point, based on cross section data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.Include(DHI.Mike1D.ResultDataAccess.IPeriods,System.DateTime)">
            <summary>
            Checks whether the datetime parameter is included in at least
            one of the periods.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.RemoveUnusedDataItems(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Remove unused data items from resultData object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DExtensions.HasUserUnit(DHI.Generic.MikeZero.eumQuantity@)">
            <summary>
            Check if a user unit can be found for the <paramref name="eumquantity"/>, 
            and if the user unit is different from the current unit. If both are true,
            a new eumquantity is returned having the new unit.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DStructureGridPoint">
            <summary>
            Specialized Q gridpoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DStructureGridPoint.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DStructureGridPoint.PointType">
            <summary>
            Point type for the gridpoint. HPoint, QPoint, ..
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DStructureGridPoint.Structures">
            <summary>
            List of structures on this grid point. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DStructureGridPoint.StructureTypes">
            <summary>
            List of string with structure types on this grid point. 
            The list contains one string for each structure.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DStructureGridPoint.ListStringWrapper">
            <summary>
            Class for wrapping the <see cref="P:DHI.Mike1D.ResultDataAccess.Res1DStructureGridPoint.Structures"/> into <see cref="P:DHI.Mike1D.ResultDataAccess.Res1DStructureGridPoint.StructureTypes"/> without copying the list
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DStructureGridPoint">
            <summary>
            Data description of the Q grid point
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DStructureGridPoint.Structures">
            <summary>
            List of structures on this grid point. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DStructureGridPoint.StructureTypes">
            <summary>
            Return a list with the types of structures on this structure grid point.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DCatchment">
            <summary>
            Data desription and time step data for a catchment.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCatchment.Shape">
            <summary>
            Shape of catchment. The <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/> will have only one element
            with a <see cref="F:DHI.Mike1D.Generic.ElementGeometry.Polygon"/> type element. This Shape <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/>
            will be referenced from all the catchment data items.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCatchment.Area">
            <summary>
            Area of catchment.
            Unit: [m2]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCatchment.CenterPoint">
            <summary>
            Center point of catchment
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DCatchments">
            <summary>
            Interface for a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCatchment"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.Add(DHI.Mike1D.ResultDataAccess.IRes1DCatchment)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCatchment"/> to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.Item(System.Int32)">
            <summary>
            Get or set the <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCatchment"/> at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns><see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCatchment"/> at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.Count">
            <summary>
            The number of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCatchment"/>'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.IndexOf(DHI.Mike1D.ResultDataAccess.IRes1DCatchment)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.Find(System.Predicate{DHI.Mike1D.ResultDataAccess.IRes1DCatchment})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type IRes1DCatchment. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.Remove(DHI.Mike1D.ResultDataAccess.IRes1DCatchment)">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCatchments.ToArray">
            <summary>
            Copies all elements of the list to an array.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DClosedCrossSection">
            <summary>
            Base interface for closed cross sections in the result data access. Basically it 
            simply defines that all closed cross sections must have a height.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DClosedCrossSection.Height">
            <summary>
            Height of the cross section
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DEggshapedCrossSection">
            <summary>
            Result meta data for describing egg-shaped circular cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DEggshapedCrossSection.Diameter">
            <summary>
            Inner diameter of the circular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DEggshapedCrossSection.CenterLevel">
            <summary>
            Level for the center of the circular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DClosedPolygonCrossSection">
            <summary>
            Interface for a closed cross section defined as a polygon in x-z plane
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DClosedPolygonCrossSection.Points">
            <summary>
            List for the points defining the cross section
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DFactory">
            <summary>
            A factory interface (abstract factory pattern) for creating Res1D objects
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateFilter">
             <summary>
             Create a new IFilter (Filter)
             </summary>
            <returns>An empty IFilter</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateGlobalData">
             <summary>
             Create a new IGlobal (Global)
             </summary>
            <returns>An empty IGlobal</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreatePeriod">
             <summary>
             Create a new IPeriod (Period)
             </summary>
            <returns>An empty IPeriod</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DBasin">
             <summary>
             Create a new IRes1DBasin (Res1DBasin)
             </summary>
            <returns>An empty IRes1DBasin</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DCircularCrossSection">
             <summary>
             Create a new IRes1DCircularCrossSection (Res1DCircularCrossSection)
             </summary>
            <returns>An empty IRes1DCircularCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DClosedPolygonCrossSection">
             <summary>
             Create a new IRes1DClosedPolygonCrossSection (Res1DClosedPolygonCrossSection)
             </summary>
            <returns>An empty IRes1DClosedPolygonCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DCrossSectionPoint">
             <summary>
             Create a new IRes1DCrossSectionPoint (Res1DCrossSectionPoint)
             </summary>
            <returns>An empty IRes1DCrossSectionPoint</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DEggshapedCrossSectio">
             <summary>
             Create a new IRes1DEggshapedCrossSection (Res1DEggshapedCrossSection)
             </summary>
            <returns>An empty IRes1DEggshapedCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DHGridPoint">
             <summary>
             Create a new IRes1DHGridPoint (Res1DHGridPoint)
             </summary>
            <returns>An empty IRes1DHGridPoint</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DManhole">
             <summary>
             Create a new IRes1DManhole (Res1DManhole)
             </summary>
            <returns>An empty IRes1DManhole</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DNode">
             <summary>
             Create a new I (Res1DNode)
             </summary>
            <returns>An empty IRes1DNode</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DOpenCrossSection">
             <summary>
             Create a new IRes1DOpenCrossSection (Res1DOpenCrossSection)
             </summary>
            <returns>An empty IRes1DOpenCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DOutlet">
             <summary>
             Create a new IRes1DOutlet (Res1DOutlet)
             </summary>
            <returns>An empty IRes1DOpenCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DQGridPoint">
             <summary>
             Create a new IRes1DQGridPoint (Res1DQGridPoint)
             </summary>
            <returns>An empty IRes1DQGridPoint</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DReach">
             <summary>
             Create a new IRes1DReach (Res1DReach)
             </summary>
            <returns>An empty IRes1DReach</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DRectangularCrossSection">
             <summary>
             Create a new IRes1DRectangularCrossSection (Res1DRectangularCrossSection)
             </summary>
            <returns>An empty IRes1DRectangularCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DSewerNode">
             <summary>
             Create a new IRes1DSewerNode (Res1DSewerNode)
             </summary>
            <returns>An empty IRes1DSewerNode</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateRes1DSewerJunction">
             <summary>
             Create a new IRes1DSewerJunction (Res1DSewerJunction)
             </summary>
            <returns>An empty IRes1DSewerJunction</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DFactory.CreateResultData">
             <summary>
             Create a new IResultData (ResultData)
             </summary>
            <returns>An empty IResultData</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DInterpolatedCrossSection">
            <summary>
            Base interface for interpolated cross sections.
            
            An interpolated cross section
            only contains processed data, and needs other data from elsewhere
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DInterpolatedCrossSection">
            <summary>
             Class for an interpolated cross section. An interpolated cross section
             only contains processed data, and needs other data from elsewhere
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DInterpolatedCrossSection.ID">
            <summary>
            ID for the cross section
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DDataSet">
            <summary>
            Interface for a general dataset, containing timestep data.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DDataSet.Id">
            <summary>
            Identification string 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DDataSet.DataItems">
            <summary>
            List of data items used for accessing the data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DDataSet.GetDataItem(DHI.Mike1D.Generic.IQuantity)">
            <summary>
             Return data item of specified type if present, otherwise null
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DAbstractDataSet">
            <summary>
             Abstract class holding the basic constituents for a Res1D data set
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DAbstractDataSet._dataItems">
            <summary>
            List of data items
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DAbstractDataSet._id">
            <summary>
            Identification string 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DAbstractDataSet.Id">
            <summary>
            Identification string 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DAbstractDataSet.DataItems">
            <summary>
            List of data items used for accessing the data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DAbstractDataSet.GetDataItem(DHI.Mike1D.Generic.IQuantity)">
            <summary>
             Return data item of specified type if present, otherwise null
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DCatchment">
            <summary>
            Data desription and time step data for a catchment.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCatchment.Shape">
            <summary>
            Shape of catchment. The <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/> will have only one element
            with a <see cref="F:DHI.Mike1D.Generic.ElementGeometry.Polygon"/> type element. This Shape <see cref="T:DHI.Mike1D.Generic.IElementSetDefinition"/>
            will be referenced from all the catchment data items.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCatchment.Area">
            <summary>
            Area of catchment.
            Unit: [m2]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCatchment.CenterPoint">
            <summary>
            Center of the catchment
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DCatchments">
            <summary>
            Class implementing a list of IRes1DCatchment's
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCatchments.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCatchments.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCatchments.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.ResultDataAccess.IRes1DCatchment})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DClosedPolygonCrossSection">
            <summary>
            Interface for a closed cross section defined as a polygon in x-z plane
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DClosedPolygonCrossSection.ID">
            <summary>
            ID for the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DClosedPolygonCrossSection.Points">
            <summary>
            List for the points defining the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DClosedPolygonCrossSection.Height">
            <summary>
            Height of the cross section
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DEggshapedCrossSection">
            <summary>
             Result meta data for describing egg-shaped circular cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DEggshapedCrossSection.ID">
            <summary>
            ID for the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DEggshapedCrossSection.Diameter">
            <summary>
            Inner diameter of the circular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DEggshapedCrossSection.CenterLevel">
            <summary>
            Level for the center of the circular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DEggshapedCrossSection.Height">
            <summary>
            Height of the cross section
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DFactory">
            <summary>
            A factory class (abstract factory pattern) for creating Res1D objects
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.#ctor">
            <summary>
            Default contstructor, required for COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateFilter">
             <summary>
             Create a new IFilter (Filter)
             </summary>
            <returns>An empty IFilter</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateGlobalData">
             <summary>
             Create a new IGlobal (Global)
             </summary>
            <returns>An empty IGlobal</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreatePeriod">
             <summary>
             Create a new IPeriod (Period)
             </summary>
            <returns>An empty IPeriod</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DBasin">
             <summary>
             Create a new IRes1DBasin (Res1DBasin)
             </summary>
            <returns>An empty IRes1DBasin</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DCircularCrossSection">
             <summary>
             Create a new IRes1DCircularCrossSection (Res1DCircularCrossSection)
             </summary>
            <returns>An empty IRes1DCircularCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DClosedPolygonCrossSection">
             <summary>
             Create a new IRes1DClosedPolygonCrossSection (Res1DClosedPolygonCrossSection)
             </summary>
            <returns>An empty IRes1DClosedPolygonCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DCrossSectionPoint">
             <summary>
             Create a new IRes1DCrossSectionPoint (Res1DCrossSectionPoint)
             </summary>
            <returns>An empty IRes1DCrossSectionPoint</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DEggshapedCrossSectio">
             <summary>
             Create a new IRes1DEggshapedCrossSection (Res1DEggshapedCrossSection)
             </summary>
            <returns>An empty IRes1DEggshapedCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DHGridPoint">
             <summary>
             Create a new IRes1DHGridPoint (Res1DHGridPoint)
             </summary>
            <returns>An empty IRes1DHGridPoint</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DManhole">
             <summary>
             Create a new IRes1DManhole (Res1DManhole)
             </summary>
            <returns>An empty IRes1DManhole</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DNode">
             <summary>
             Create a new I (Res1DNode)
             </summary>
            <returns>An empty IRes1DNode</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DOpenCrossSection">
             <summary>
             Create a new IRes1DOpenCrossSection (Res1DOpenCrossSection)
             </summary>
            <returns>An empty IRes1DOpenCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DOutlet">
            <summary>
            Create a new IRes1DOutlet (Res1DOutlet)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DSewerJunction">
            <summary>
            Create a new IRes1DOutlet (Res1DOutlet)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DQGridPoint">
             <summary>
             Create a new IRes1DQGridPoint (Res1DQGridPoint)
             </summary>
            <returns>An empty IRes1DQGridPoint</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DReach">
             <summary>
             Create a new IRes1DReach (Res1DReach)
             </summary>
            <returns>An empty IRes1DReach</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DRectangularCrossSection">
             <summary>
             Create a new IRes1DRectangularCrossSection (Res1DRectangularCrossSection)
             </summary>
            <returns>An empty IRes1DRectangularCrossSection</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateRes1DSewerNode">
             <summary>
             Create a new IRes1DSewerNode (Res1DSewerNode)
             </summary>
            <returns>An empty IRes1DSewerNode</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DFactory.CreateResultData">
             <summary>
             Create a new IResultData (ResultData)
             </summary>
            <returns>An empty IResultData</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper">
            <summary>
            Network value set for a Res1D file
            The <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper"/> provides temporal
            and spatial interpolation of data from a <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper.ExtrapolationDistance">
            <summary>
            Distance from gridpoint where extrapolation takes place, i.e., if location chainage
            is outside the network value chainage span, but less than <see cref="P:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper.ExtrapolationDistance"/> from the span,
            then the nearest value is extrapolated. Set to 0 to disable. Default is <see cref="F:DHI.Mike1D.Generic.Constants.LOCATION_EQUAL_TOLERANCE"/>. Can not be negative.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper.Create(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Create a <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper"/> based on the <paramref name="results"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper.StartTime">
            <summary>
            First time in network value
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper.EndTime">
            <summary>
            Last time in network value. Must be equal or after <see cref="P:DHI.Mike1D.Generic.INetworkDataInterpolatorTimeSet`1.StartTime"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper.Offers">
            <summary>
            List of data types that is offered
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper.NetworkData(System.DateTime,System.Int32)">
            <summary>
            Return an <see cref="T:DHI.Mike1D.Generic.INetworkDataInterpolator`1"/> for the specified time and quantity.
            An exception is thrown if <paramref name="time"/> is not within <see cref="P:DHI.Mike1D.Generic.INetworkDataInterpolatorTimeSet`1.StartTime"/>
            and <see cref="P:DHI.Mike1D.Generic.INetworkDataInterpolatorTimeSet`1.EndTime"/>. 
            </summary>
            <param name="time">Time</param>
            <param name="quantityIndex">Index into <see cref="M:DHI.Mike1D.Generic.INetworkDataInterpolatorTimeSet`1.Offers"/></param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataTimeSetWrapper.NetworkData(System.DateTime,DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Return an <see cref="T:DHI.Mike1D.Generic.INetworkDataInterpolator`1"/> for the specified time and quantity.
            An exception is thrown if <paramref name="time"/> is not within <see cref="P:DHI.Mike1D.Generic.INetworkDataInterpolatorTimeSet`1.StartTime"/>
            and <see cref="P:DHI.Mike1D.Generic.INetworkDataInterpolatorTimeSet`1.EndTime"/>. 
            </summary>
            <param name="time">Time</param>
            <param name="quantity">Quantity to get interpolator for.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper">
            <summary>
            Network value set for a Res1D file, based on a given time
            in the file.
            <para>
            The <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper"/> provides temporal
            and spatial interpolation of data from a <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/>.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper.ExtrapolationDistance">
            <summary>
            Distance from gridpoint where extrapolation takes place, i.e., if location chainage
            is outside the network value chainage span, but less than <see cref="P:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper.ExtrapolationDistance"/> from the span,
            then the nearest value is extrapolated. Set to 0 to disable. Default is <see cref="F:DHI.Mike1D.Generic.Constants.LOCATION_EQUAL_TOLERANCE"/>. Can not be negative.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper.Create(DHI.Mike1D.ResultDataAccess.IResultData,System.DateTime)">
            <summary>
            Create a <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper"/> based on the <paramref name="results"/>
            and used the specified <paramref name="time"/> when retrieving values.
            <para>
            If <paramref name="time"/> is not within the time span of the <paramref name="results"/>
            null is returned
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper.Offers">
            <summary>
            List of data types that is offered
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataSetWrapper.NetworkData(System.Int32)">
            <summary>
            Return an <see cref="T:DHI.Mike1D.Generic.INetworkDataInterpolator`1"/> for the specified quantity.
            </summary>
            <param name="quantityIndex">Index into <see cref="M:DHI.Mike1D.Generic.INetworkDataInterpolatorSet`1.Offers"/></param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper">
            <summary>
            A <see cref="T:DHI.Mike1D.Generic.INetworkDataInterpolator`1"/> for a given <see cref="T:DHI.Mike1D.Generic.IQuantity"/>, 
            that extracts data from an <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/> at a given time.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper.ExtrapolationDistance">
            <summary>
            Distance from gridpoint where extrapolation takes place, i.e., if location chainage
            is outside the network value chainage span, but less than <see cref="P:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper.ExtrapolationDistance"/> from the span,
            then the nearest value is extrapolated. Set to 0 to disable. Default is <see cref="F:DHI.Mike1D.Generic.Constants.LOCATION_EQUAL_TOLERANCE"/>. Can not be negative.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper.#ctor(DHI.Mike1D.ResultDataAccess.IResultData,DHI.Mike1D.Generic.IQuantity,System.Int32,System.Double)">
            <summary>
            Create a <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper"/> for the given <paramref name="quantity"/>.
            </summary>
            <param name="results">Results that data is retrieved from</param>
            <param name="quantity">Quantity to base network value on</param>
            <param name="timeInterval">Used for time interpolation</param>
            <param name="timeFraction">Used for time interpolation</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper.GetValue(DHI.Mike1D.Generic.ILocation,System.Double@)">
            <summary>
            Get value for the specified location. Returns false if no value is
            defined for the location.
            <para>
            If more than one value is to be retrieved for the same reach, use
            the <see cref="M:DHI.Mike1D.Generic.INetworkDataInterpolator`1.GetReachData(System.String)"/> first and use that one to 
            get the values (for performance).
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper.GetValue(System.String,System.Double@)">
            <summary>
            Get value for the specified node. Returns false if no value is
            defined for the node id.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper.GetGlobalValue(System.Double@)">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper.GetGlobalValue(System.String,System.Double@)">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper.GetReachData(System.String)">
            <summary>
            Get a <see cref="T:DHI.Mike1D.Generic.IReachDataInterpolator`1"/> for the specified link/reachId.
            Returns null if no valueset exist for the link/reachId.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkReachIdValue">
            <summary>
             A <see cref="T:DHI.Mike1D.Generic.IReachDataInterpolator`1"/>, spanning several <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkSingleReachValue"/>.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DNetworkReachIdValue._reachValues">
            <summary>
            List of <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkSingleReachValue"/> to search in.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkSingleReachValue">
            <summary>
            An <see cref="T:DHI.Mike1D.Generic.IReachDataInterpolator`1"/> that spans a single reach.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNetworkSingleReachValue.#ctor(DHI.Mike1D.ResultDataAccess.IDataItem,DHI.Mike1D.ResultDataAccess.IRes1DReach,System.Int32,System.Double,DHI.Mike1D.ResultDataAccess.Res1DNetworkDataInterpolatorWrapper)">
            <summary>
            Constructor
            </summary>
            <param name="dataItem"></param>
            <param name="reach"></param>
            <param name="timeInterval">Used for time interpolation</param>
            <param name="timeFraction">USed for time interpolation</param>
            <param name="res1DNetworkDataInterpolatorWrapper"></param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNetworkSingleReachValue.IndexListSearcher">
            Helper class for using MathUtil for interpolating in chainages using the indexList
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DRectangularCrossSection">
            <summary>
            Simple implemtation of a rectangular cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DRectangularCrossSection.#ctor">
            <summary>
             Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DRectangularCrossSection.#ctor(System.Double,System.Double)">
            <summary>
            Constructor initializing height and width
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DRectangularCrossSection.Height">
            <summary>
            Height of the rectangular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DRectangularCrossSection.Width">
            <summary>
            Width of the rectangular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DRectangularCrossSection.ID">
            <summary>
            ID for the cross section
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IPeriod">
            <summary>
            Describes a period in time. The period id described through Start- and End- Time.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IPeriod.StartTime">
            <summary>
            Start time 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IPeriod.EndTime">
            <summary>
            EndTime
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriod.Contains(System.DateTime)">
            <summary>
            Decides whether a time is contained in the period
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IPeriods">
            <summary>
            Interface for a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IPeriod"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriods.Add(DHI.Mike1D.ResultDataAccess.IPeriod)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.ResultDataAccess.IPeriod"/> to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IPeriods.Item(System.Int32)">
            <summary>
            Get or set the <see cref="T:DHI.Mike1D.ResultDataAccess.IPeriod"/> at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns><see cref="T:DHI.Mike1D.ResultDataAccess.IPeriod"/> at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IPeriods.Count">
            <summary>
            The number of <see cref="T:DHI.Mike1D.ResultDataAccess.IPeriod"/>'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriods.IndexOf(DHI.Mike1D.ResultDataAccess.IPeriod)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriods.Find(System.Predicate{DHI.Mike1D.ResultDataAccess.IPeriod})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type IPeriod. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriods.Remove(DHI.Mike1D.ResultDataAccess.IPeriod)">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriods.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriods.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriods.ToArray">
            <summary>
            Copies all elements of the list to an array.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IPeriods.Contains(System.DateTime)">
            <summary>
            Decides whether a time is contained in the period
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DRectangularCrossSection">
            <summary>
            Interface for a rectangular cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DRectangularCrossSection.Width">
            <summary>
            Width of the rectangular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Period">
            <summary>
            Describes a period in time. The period is described through Start- and End- Time.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Period.StartTime">
            <summary>
            Start time 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Period.EndTime">
            <summary>
            EndTime
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Period.#ctor">
            <summary>
            Default constructor. Initialises as the largest possible period
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Period.#ctor(System.DateTime,System.DateTime)">
            <summary>
            Full constructor. Sets all fields
            </summary>
            <param name="startTime"></param>
            <param name="endTime"></param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Period.Contains(System.DateTime)">
            <summary>
            Decides whether a time is contained in the period
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Periods">
            <summary>
            Class implementing a list of IPeriod's
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Periods.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Periods.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Periods.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.ResultDataAccess.IPeriod})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Periods.Contains(System.DateTime)">
            <summary>
            Decides whether a time is contained in the period
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DManhole">
            <summary>
             Access to ManHole data from Res1D data access.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DManhole.diameter">
            <summary>
            Manhole diameter. 
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DManhole.Diameter">
            <summary>
            Manhole diameter. 
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DSewerNode">
            <summary>
             Sewernode is the base class for nodes used in the sewers.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DSewerNode._bottomLevel">
            <summary>
            Bottom level of SewerNode (Manhole/Basin).
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DSewerNode._groundLevel">
            <summary>
            Top level of SewerNode (Manhole/Basin)
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DSewerNode._criticalLevel">
            <summary>
            Cristcal level.
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DSewerNode.BottomLevel">
            <summary>
            Bottom level of SewerNode (Manhole/Basin).
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DSewerNode.GroundLevel">
            <summary>
            Top level of SewerNode (Manhole/Basin)
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DSewerNode.CriticalLevel">
            <summary>
            Critical level. Used to mark when a level is critical, not used in the simulation.
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DOutlet">
            <summary>
            Outlet node
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DOutlet._bottomLevel">
            <summary>
            Bottom level of SewerNode (Manhole/Basin).
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DOutlet._groundLevel">
            <summary>
            Top level of SewerNode (Manhole/Basin)
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOutlet.BottomLevel">
            <summary>
            Bottom level of SewerNode (Manhole/Basin).
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOutlet.GroundLevel">
            <summary>
            Top level of SewerNode (Manhole/Basin)
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DStructureOutlet">
            <summary>
            Special kind of outlet: When a structure is discharging directly out
            of the system, and no outlet has been explicitly specified,
            the engine will put in a StuctureOutlet downstream of the structure. 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DBasin">
            <summary>
            Basin node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DSewerJunction">
            <summary>
            Sewer Junction node
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DStructureReach">
            <summary>
            Default implementation of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DStructureReach"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DStructureReach.IsStructureReach">
            <summary>
            Returns true if the reach is a structure reach (special reach with just one structure q-points
            and two h-grid points. The h-grid points have very large (unused) cross sections.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DToTimeSeries">
            <summary>
            Contains static functions to extract time series from result data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DToTimeSeries.CreateTsCollection(DHI.Mike1D.ResultDataAccess.IResultData,System.String,System.String,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create a time series collection with a single time series from a catchment in resultdata. The values where quantity id == quantityId 
            are extracted from the catchment results.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultDataBuffer">
            <summary>
            <para>
            Class that contains a number of resultdata files. In case of more than
            one component needing access to the same result data file, it should
            only be opened once (performance/ressource issues). Hence, each component using a 
            result data file should ask this buffer for the file
            and if it already exist in the buffer, the existing file will be used.
            </para>
            <para>
            Each result data file is idenfitied by its full filepath name.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultDataBuffer._registeredResultDataFiles">
            <summary>
            Dictionary holding key lower case file names and value ResultData
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataBuffer.RegisteredFilePaths">
            <summary>
             Return a list of all the filepaths registered in this buffer
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataBuffer.Register(System.String,DHI.Mike1D.ResultDataAccess.ResultData)">
            <summary>
            Manually register a result data object to the buffer
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataBuffer.RegisterInternal(System.String,DHI.Mike1D.ResultDataAccess.ResultData)">
            <summary>
            Manually register a result data object to the buffer
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataBuffer.FindOrCreateResultData(DHI.Mike1D.Generic.IFilePath,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Registers a ResultData in the buffer.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataBuffer.FindOrCreateResultDataSearch(DHI.Mike1D.Generic.IFilePath,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Registers a ResultData in the buffer.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataBuffer.FindOrCreateResultData(DHI.Mike1D.Generic.IFilePath,System.String,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Registers a ResultData in the buffer.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataBuffer.FindOrCreateResultDataSearch(DHI.Mike1D.Generic.IFilePath,System.String,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Registers a ResultData in the buffer.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataBuffer.DisposeResults">
            <summary>
            Delete references to result data
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultDataFactory">
            <summary>
            Class to ease reading and writing of result data files.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataFactory.Read(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read from file specified by connection and return a data access component.
            </summary>
            <param name="connection">Connection specifying filename, bridgename etc.</param>
            <param name="diagnostics"></param>
            <returns>A populated data access component</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataFactory.Read(DHI.Mike1D.Generic.IConnection,System.Boolean,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read from file specified by connection and return a data access component.
            </summary>
            <param name="connection">Connection specifying filename, bridgename etc.</param>
            <param name="useSIUnits">Convert data to SI units</param>
            <param name="diagnostics"></param>
            <returns>A populated data access component</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataFactory.Write(DHI.Mike1D.ResultDataAccess.ResultData)">
            <summary>
            Write the data to file, using the data.Connection to 
            specify filename etc.
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DCircularCrossSection">
            <summary>
            Data model for circular cross section. To be able draw circular sections a postprocessing tool 
            (for instance MIKE VIEW) needs to know ID, Centerlevel and Diameter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCircularCrossSection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCircularCrossSection.#ctor(System.String,System.Double,System.Double)">
            <summary>
            Full Constructor. Sets all fields.
            </summary>
            <param name="id">Identification string</param>
            <param name="diameter">Inner diameter of the circular cross section</param>
            <param name="centerLevel">Level for the center of the circular cross section</param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCircularCrossSection.Diameter">
            <summary>
            Inner diameter of the circular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCircularCrossSection.CenterLevel">
            <summary>
            Level for the center of the circular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCircularCrossSection.ID">
            <summary>
            Identification string
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCircularCrossSection.Height">
            <summary>
            Height of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCircularCrossSection.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DGlobalData">
            <summary>
            Global data. Global data are data that is not specific to the topology or parts
            of the topology (network, catchments ..).
            Global data could be time step used in model, wind field valid for entire domain
            etc.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DGlobalData.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultReadWriteBridge">
            <summary>
            Interface that is to be implemted for a bridge that can read and write between the 
            ResultData access and persistant storage. For detail, see the <see cref="T:DHI.Mike1D.ResultDataAccess.IResultReadBridge"/>
            and <see cref="T:DHI.Mike1D.ResultDataAccess.IResultWriteBridge"/>.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultWriteBridge">
            <summary>
            Interface that is to be implemted for a bridge that can write data from the 
            ResultData access to persistant storage.
            <para>
            The <see cref="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Save"/> method is used for storing the entire content of the
            result data object to persistant storage.
            When <see cref="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Save"/> is called, the bridge should initialize and open
            the persistant storage, write data to the storage and finalise and close
            the storage.
            </para>
            <para>
            The methods <see cref="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Prepare(DHI.Mike1D.Generic.IDiagnostics)"/>, <see cref="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Flush(System.Boolean)"/> and
            <see cref="M:DHI.Mike1D.ResultDataAccess.IResultBridge.Finish"/> are used for storing data from 
            the result data into persistent storage during a simulation. 
            </para>
            <para>
            The <see cref="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Prepare(DHI.Mike1D.Generic.IDiagnostics)"/> is called during the prepare phase of the 
            simulation, where all static data is available. The method
            must initialise the storage, open it for writing and write any 
            required static data (not time dependent data) to the storage.
            </para>
            <para>
            The <see cref="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Flush(System.Boolean)"/> method is called regurlarly during the simulation,
            depending on the <see cref="P:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.SecondsBetweenFileFlush"/> parameter.
            There can be data for more than one time step in the result data object.
            The method must store all data present in the result data object.
            After the flush method, the current data in the result data object is
            removed. A final call to flush is issued when the simulation is done.
            </para>
            <para>
            The <see cref="M:DHI.Mike1D.ResultDataAccess.IResultBridge.Finish"/> method will be called when the simulation
            is done and after the last flush call. 
            It must finalize and close down the persistant storage.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Save">
            <summary>
            Writes the entire content of the result data into a persistent storage
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Prepare(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Prepare the persistant storage for flush operations.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.Flush(System.Boolean)">
            <summary>
            Flush must store data from result data (memory) and into persistant storage (file or database)
            </summary>
            <param name="fullFlush">Force a full flush, to make sure buffers are emptied and all content is written to disc.</param>
            <remarks>
            The <paramref name="fullFlush"/> can be used by file system, to force a flush of file write buffers within
            the operating system.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultWriteBridge.SecondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. 
            <para>
            Set to zero to disable file flushing.
            </para>
            <para>
            WARNING: File flush is a potentially expensive operation. Use with care.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DBasin">
            <summary>
            Data model for a Basin. The basin is a specialisation of a sewer node.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataItem">
            <summary>
            See <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItem._vectorData">
            <summary>
            Flag indicating if data item contains vector data or single value data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItem._quantity">
            <summary>
            Data quantity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItem._itemTypeGroup">
            <summary>
            Item type group
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItem._itemId">
            <summary>
            Item Id
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItem._numberWithinGroup">
            <summary>
            Index within group
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItem._timeData">
            <summary>
            Data at time steps in vector case
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItem._indexList">
            <summary>
            List with indexes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItem.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="vectorItem"></param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItem.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItem.Update(System.DateTime,System.Int32)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.VectorData">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.Quantity">
            <summary>
            Quantity description
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.ItemTypeGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.ItemId">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.NumberWithinGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItem.Clear">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItem.IndexList">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItem.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItem.CreateTimeSeriesData(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItem.CreateDataArray">
            <summary>
            The property exposes the contained data as a two dimensional array. The array 
            is [number of time steps, number of points]. 
            
            The array is constructed every time called as a copy of Data, and not updated 
            if the underlying Data is updated.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataItemTimeSingleProxySource">
            <summary>
            A <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> that can update itself based on an <see cref="T:DHI.Mike1D.Generic.IDoubleTimeVectorGetter"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItemTimeSingleProxySource._source">
            <summary>
            Double getter used to access sources as a function of time
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItemTimeSingleProxySource.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItemTimeSingleProxySource.Source">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.ResultDataAccess.DataItemTimeSingleProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItemTimeSingleProxySource.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataItems">
            <summary>
            Class implementing a list of IDataItem's
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItems.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItems.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItems.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.ResultDataAccess.IDataItem})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess.Bridge">
            <summary>
              Looks up a localized string similar to Bridge:.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess.CannotReadFile">
            <summary>
              Looks up a localized string similar to Cannot read file..
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess.unknown">
            <summary>
              Looks up a localized string similar to  unknown.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess.WrongFileType">
            <summary>
              Looks up a localized string similar to Wrong file type..
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess.WrongTimeAxisType">
            <summary>
              Looks up a localized string similar to Wrong time axis type. .
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DHI_Mike1D_ResultDataAccess.WrongTimeUnit">
            <summary>
              Looks up a localized string similar to Wrong time unit. .
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Filter">
            <summary>
            Filter allowing user to specify a subset of the data set.
            It contains a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItemFilter"/>
            that must all accept a dataitem before it is accepted
            by this filter.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Filter.Periods">
            <summary>
            List of time periods in selection
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Filter.LoadStep">
            <summary>
            Indicate the step value for time steps when loading data from filein the file for loading time steps.
            <para>
            A value of 10 means that only time step with indices that divide with 10 are loaded, i.e. 0, 10, 20,...
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Filter.DataItemFilters">
            <summary>
            List of data item filters
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Filter.AddDataItemFilter(DHI.Mike1D.ResultDataAccess.IDataItemFilter)">
            <summary>
            Method for explicitly adding a filter
            <para>
            Provides COM interop support for adding filters to list.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Filter.TimeFilter">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Filter.Include(System.DateTime,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Filter.Include(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Filter.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IDataItemFilterQuantity">
            <summary>
            Interface for <see cref="T:DHI.Mike1D.ResultDataAccess.DataItemFilterQuantity"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItemFilterQuantity.Quantities">
            <summary>
            List of quantities in selection
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataItemFilterQuantity">
            <summary>
            A class that can filter on quantities
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItemFilterQuantity.Quantities">
            <summary>
            List of quantities in selection
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItemFilterQuantity.Include(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataItemFilterName">
            <summary>
            A class that can filter on names
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItemFilterName.#ctor(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItemFilterName.Nodes">
            <summary>
            Set of Nodes that are included by the filter
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItemFilterName.Reaches">
            <summary>
            Set of reaches/links/branches that are included by
            the filter
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.DataItemFilterName.Catchments">
            <summary>
            Set of catchments that are included by
            the filter
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItemFilterName.Include(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DCircularCrossSection">
            <summary>
            Result meta data for describing circular cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCircularCrossSection.Diameter">
            <summary>
            Inner diameter of the circular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCircularCrossSection.CenterLevel">
            <summary>
            Level for the center of the circular cross section
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ItemTypeGroup">
            <summary>
            Enumeration that is used to describe whether a certain item is associated with global data, a node or a reach
            </summary>
            <remarks>Do not edit the integer values, they are written to result files</remarks>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.Undefined">
            <summary>
            undefined/unknown
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.GlobalItem">
            <summary>
            Associates with global data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.NodeItem">
            <summary>
            Associates with node data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.ReachItem">
            <summary>
            Associates with reach data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.CatchmentItem">
            <summary>
            Associates with reach data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.ReachStructureItem">
            <summary>
            Associates with structures on a reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IDataItem">
            <summary>
            <para>
            An <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>  contains data for one quantity and for a number 
            of time steps and elements. For each set of time data
            there is an array of data element values.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.VectorData">
            <summary>
            Flag indicating if data item contains vector data or single value data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.Quantity">
            <summary>
            Quantity description
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.NumberOfElements">
            <summary>
            Number of elements.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.NumberOfTimeSteps">
            <summary>
            Number of time steps in data item. 
            <para>
            Matches <see cref="P:DHI.Mike1D.ResultDataAccess.IResultData.NumberOfTimeSteps"/>,
            unless data for DataItem is not loaded, in which case it is zero
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData">
            <summary>
            List of time step data. Each list member contains data for one time step, 
            The list has <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.NumberOfTimeSteps"/> elements.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItem.Clear">
            <summary>
            Clear data item for time dependent data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.ItemTypeGroup">
            <summary>
            Describes what data group the data belongs to
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.NumberWithinGroup">
            <summary>
            Number within the group of <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.ItemTypeGroup"/>. Zero based.
            <para>
            If the number is -1, then the data belongs to all items within the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.ItemTypeGroup"/>,
            i.e. if the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.ItemTypeGroup"/> is <see cref="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.NodeItem"/>,
            then there is data for all nodes in the network.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.ItemId">
            <summary>
            Id of item that this quantity belongs to. Null if not relevant.
            <para>
            Used e.g. to store the Id of the structure that the data belongs to.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItem.IndexList">
            <summary>
             <para>
             For each element this can specify an index into another list 
             where the data "belongs" to. 
             </para>
             <para>
             This can be null (if no reasonable correspondance exists or if the correspondance 
             is trivial and therefor not needed ([0,1,2,3,...])).
             </para>
             <para>
             For data on a reach, the element at index i in the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.IndexList"/> having IndexList[i] = j 
             is used to specify that the value belongs to GridPoint number j in a list of GridPoint's.
             </para>
             </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItem.GetValue(System.Int32,System.Int32)">
            <summary>
            Returns the value for the element at the given element index and  
            time index. Short-cut for <see cref="M:DHI.Mike1D.ResultDataAccess.ITimeData.GetValue(System.Int32,System.Int32)"/>
            </summary>
            <param name="elementIndex">Index of element, in the range [0,<see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.NumberOfElements"/>-1]</param>
            <param name="timestepIndex">Index of timestep, in the range [0,<see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.NumberOfTimeSteps"/>-1]</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItem.CreateTimeSeriesData(System.Int32)">
            <summary>
            Create an array of values for a given point with the given index,
            each element in the array corresponding the a given time. 
            <para>
            Values are returned for the point at Chainages[pointIndex].
            </para>
            <para>
            The result is an array having NumberOfTimeSteps elements. 
            </para>
            <para>
            The array is constructed every time called as a copy of the
            data in the data item.
            </para>
            </summary>
            <param name="elementIndex">Index of point to get value for</param>
            <returns>Array having <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.NumberOfTimeSteps"/> elements</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItem.CreateDataArray">
            <summary>
            <para>
            The method exposes the contained data as a two dimensional array. The array 
            is [number of time steps, number of points]. 
            </para>
            <para>
            The array is constructed every time called as a copy of Data, and not updated 
            if the underlying Data is updated.
            </para>para>
            </summary>
            <remarks>
            For accessing the data without making a copy, you may as well use
            <see cref="M:DHI.Mike1D.ResultDataAccess.IDataItem.GetValue(System.Int32,System.Int32)"/>(timestepIndex,elementIndex) or 
            <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/>[timestepIndex][elementIndex]
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItem.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItem.Update(System.DateTime,System.Int32)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IDataItems">
            <summary>
            Interface for a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItems.Add(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItems.Item(System.Int32)">
            <summary>
            Get or set the <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns><see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IDataItems.Count">
            <summary>
            The number of <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItems.IndexOf(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItems.Find(System.Predicate{DHI.Mike1D.ResultDataAccess.IDataItem})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type IDataItem. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItems.Remove(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItems.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItems.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IFilter">
            <summary>
            Filter allowing user to specify a subset of the data set.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IFilter.TimeFilter">
            <summary>
            Bool indicating if this filter will filter in time
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IFilter.Include(System.DateTime,System.Int32)">
            <summary>
            Returns true if the timestep matching provided dateTime 
            and timestepIndex is to be included by the filter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IFilter.Include(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            Returns true if the provided data item is to be included
            by the filter.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IFilter.Periods">
            <summary>
            List of time periods in selection
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IFilter.LoadStep">
            <summary>
            Indicate the step value for time steps when loading data from filein the file for loading time steps.
            <para>
            A value of 10 means that only time step with indices that divide with 10 are loaded, i.e. 0, 10, 20,...
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IFilter.AddDataItemFilter(DHI.Mike1D.ResultDataAccess.IDataItemFilter)">
            <summary>
            Method for explicitly adding a filter
            <para>
            Provides COM interop support for adding filters to list.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IDataItemFilter">
            <summary>
            Interface for implementing filtering of data items.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IDataItemFilter.Include(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            Returns true if the provided data item is to be included
            by the filter.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DGlobalData">
            <summary>
            Global data. Global data are data that is not specific to the topology or parts
            of the topology (network, catchments ..).
            Global data could be time step used in model, wind filed valid for entire domain
            etc.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection">
            <summary>
            Interface to an open cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.LeftLeveeBank">
            <summary>
            The left levee bank (marker 1) - index into <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Points"/>, negative if undefined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.LowestPoint">
            <summary>
            The lowest point in the channel (marker 2) - index into <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Points"/>, negative if undefined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.RightLeveeBank">
            <summary>
            The right levee bank (marker 3) - index into <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Points"/>, negative if undefined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.LeftLowFlowBank">
            <summary>
            The left low flow bank (marker 4) - index into <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Points"/>, negative if undefined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.RightLowFlowBank">
            <summary>
            The right low flow bank (marker 5) - index into <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Points"/>, negative if undefined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.LeftCoordinateMarker">
            <summary>
            The point corresponding to the left coordinate of the cross section (marker 6) - index into <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Points"/>, negative if undefined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.RightCoordinateMarker">
            <summary>
            The point corresponding to the right coordinate of the cross section (marker 7) - index into <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Points"/>, negative if undefined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Points">
            <summary>
            List for the points defining the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOpenCrossSection.Coordinates">
            <summary>
            List of coordinates. Can be null
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint">
            <summary>
            X-Z point in tabulated cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint.X">
            <summary>
            X-coordinate of the cross section point
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint.Z">
            <summary>
            Z-coordinate of the cross section point
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint.UserMarker">
            <summary>
            User marker. 0 to disable. Larger than 8 when used in M11 type setups.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints">
            <summary>
            Interface for a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints.Add(DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint"/> to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints.Item(System.Int32)">
            <summary>
            Get or set the <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint"/> at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns><see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint"/> at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints.Count">
            <summary>
            The number of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint"/>'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints.IndexOf(DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints.Find(System.Predicate{DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type IRes1DCrossSectionPoint. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints.Remove(DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint)">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoints.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DHGridPoint">
            <summary>
            Data description of the H grid point. A H grid point is a grid point with a cross section.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DHGridPoint.CrossSection">
            <summary>
            Cross section. Can be null (Routing points and in some HPoints (in older data files )).
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DRoutingGridPoint">
            <summary>
            Data description of a routing grid point. A routing grid point is a Q point that can also
            have a cross section and a water level
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DReach">
            <summary>
            Data desription and time step data for a reach (also sometimes called a branch or a link)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.Name">
            <summary>
            Name of branch
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.StartNodeIndex">
            <summary>
            Index of the reach start node in the node list
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.EndNodeIndex">
            <summary>
            Index of the reach end node in the node list
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.Length">
            <summary>
            Return length of reach, chainage-length
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.DirectionType">
            <summary>
            Direction of positive flow in the reach.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.TopoID">
            <summary>
            Id for the cross section topologi that is to be used for the Link / Branch
            If TopoID is not used, set to empty string (null will be handled as the empty string).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.GridPoints">
            <summary>
            List of grid points
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.DigiPoints">
            <summary>
            List of digi points
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReach.IsStructureReach">
            <summary>
            Returns true if the reach is a structure reach (special reach with just one structure q-points
            and two h-grid points. The h-grid points have very large (unused) cross sections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReach.GridPointIndexForChainage(System.Double)">
            <summary>
            Return index in list of gridpoints for given chainage.
            
            Chainage must be within Constants.LOCATION_EQUAL_TOLERANCE
            of gridpoint chainage, otherwise no grid point is found.
            </summary>
            <param name="chainage">Chainage</param>
            <returns>Index for gridpoint in list, -1 if not found.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReach.GetChainages(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            <para>
            Returns the chainages for the elements in the dataitem.
            </para>
            <para>
            The <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> must be a <see cref="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.ReachItem"/>
            and having one vertex per element.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReach.GetChainages(System.Int32)">
            <summary>
            <para>
            Returns the chainages for the elements in the dataitem.
            </para>
            <para>
            The <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> must be a <see cref="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.ReachItem"/>
            and have one vertex per element only.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReach.GetLowerLimitChainages(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            <para>
            Returns the lower limit chainages for each elements in the dataitem. This is the
            smallest vertex chainage coordinate for each element.
            </para>
            <para>
            If an element only has one vertex coordinate, the chainage of the gridpoint 
            before the element gridpoint is returned (lower chainage). At the first 
            gridpoint the chainage of the gridpoint itself is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReach.GetLowerLimitChainages(System.Int32)">
            <summary>
            <para>
            Returns the lower limit chainages for each elements in the dataitem. This is the
            smallest vertex chainage coordinate for each element.
            </para>
            <para>
            If an element only has one vertex coordinate, the chainage of the gridpoint 
            after the element gridpoint is returned(lower chainage). At the first 
            gridpoint the chainage of the gridpoint itself is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReach.GetUpperLimitChainages(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            <para>
            Returns the upper limit chainages for each elements in the dataitem. This is the
            largest vertex chainage coordinate for each element.
            </para>
            <para>
            If an element only has one vertex coordinate, the chainage of the gridpoint 
            after the element gridpoint is returned (higher chainage). At the last 
            gridpoint the chainage of the gridpoint itself is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReach.GetUpperLimitChainages(System.Int32)">
            <summary>
            <para>
            Returns the upper limit chainages for each elements in the dataitem. This is the
            largest vertex chainage coordinate for each element.
            </para>
            <para>
            If an element only has one vertex coordinate, the chainage of the gridpoint 
            after the element gridpoint is returned (higher chainage). At the last 
            gridpoint the chainage of the gridpoint itself is returned.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DReaches">
            <summary>
            Interface for a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DReach"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReaches.Add(DHI.Mike1D.ResultDataAccess.IRes1DReach)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DReach"/> to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReaches.Item(System.Int32)">
            <summary>
            Get or set the <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DReach"/> at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns><see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DReach"/> at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DReaches.Count">
            <summary>
            The number of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DReach"/>'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReaches.IndexOf(DHI.Mike1D.ResultDataAccess.IRes1DReach)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReaches.Find(System.Predicate{DHI.Mike1D.ResultDataAccess.IRes1DReach})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type IRes1DReach. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReaches.Remove(DHI.Mike1D.ResultDataAccess.IRes1DReach)">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReaches.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DReaches.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DQGridPoint">
            <summary>
            Data description of the Q grid point
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DCrossSection">
            <summary>
            Base interface for cross sections in the result data access. Basically it 
            simply defines that all cross sections must have an identification string.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DCrossSection.ID">
            <summary>
            ID for the cross section
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint">
            <summary>
            Data model for the generalized gridpoint. Actual grid points are specilizations of IRes1dGridPoint
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint.Chainage">
            <summary>
            Chainage of the gridpoint
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint.X">
            <summary>
            X coordinate of the gridpoint at marker 2 of the cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint.Y">
            <summary>
            Y coordinate of the gridpoint at marker 2 of the cross section
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint.Z">
            <summary>
            Z coordinate of the bottom point at marker 2 of the cross section in the gridpoint
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints">
            <summary>
            Interface for a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints.Add(DHI.Mike1D.ResultDataAccess.IRes1DGridPoint)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint"/> to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints.Item(System.Int32)">
            <summary>
            Get or set the <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint"/> at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns><see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint"/> at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints.Count">
            <summary>
            The number of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DGridPoint"/>'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints.IndexOf(DHI.Mike1D.ResultDataAccess.IRes1DGridPoint)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints.Find(System.Predicate{DHI.Mike1D.ResultDataAccess.IRes1DGridPoint})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type IRes1DGridPoint. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints.Remove(DHI.Mike1D.ResultDataAccess.IRes1DGridPoint)">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DGridPoints.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DManhole">
            <summary>
            The circular manhole is a vertical circular cylinder. The cylinder is bounded vertically by
            invert level and ground level.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DManhole.Diameter">
            <summary>
            Manhole diameter. 
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DNode">
            <summary>
            Interface to a Res1D Node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DNode.XCoordinate">
            <summary>
            X-coordinate of the node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DNode.YCoordinate">
            <summary>
            Y-coordinate of the node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DNode.Reaches">
            <summary>
            Reaches connected to node.
            </summary>
            <remarks>
            When creating a new <see cref="T:DHI.Mike1D.ResultDataAccess.ResultData"/> object, or modifying an existing,
            this is not automatically updated.
            Calling <see cref="M:DHI.Mike1D.ResultDataAccess.ResultData.ReconnectNetwork"/> to have it updated.
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DNodes">
            <summary>
            Interface for a list of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DNode"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DNodes.Add(DHI.Mike1D.ResultDataAccess.IRes1DNode)">
            <summary>
            Add a <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DNode"/> to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DNodes.Item(System.Int32)">
            <summary>
            Get or set the <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DNode"/> at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns><see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DNode"/> at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DNodes.Count">
            <summary>
            The number of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DNode"/>'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DNodes.IndexOf(DHI.Mike1D.ResultDataAccess.IRes1DNode)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DNodes.Find(System.Predicate{DHI.Mike1D.ResultDataAccess.IRes1DNode})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type IRes1DNode. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DNodes.Remove(DHI.Mike1D.ResultDataAccess.IRes1DNode)">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DNodes.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IRes1DNodes.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DOutlet">
            <summary>
            Interface for a Res1D outlet
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOutlet.BottomLevel">
            <summary>
            Bottom level of outlet.
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DOutlet.GroundLevel">
            <summary>
            Top level of outlet
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DStructureOutlet">
            <summary>
            Interface for a Res1D structure outlet which is a pecial kind of outlet:
            When a structure is discharging directly out
            of the system, and no outlet has been explicitly specified,
            the engine will put in a StuctureOutlet downstream of the structure. 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DSewerNode">
            <summary>
            Interface for a Res1D sewer node. This is usually specialized further.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DSewerNode.BottomLevel">
            <summary>
            Bottom level of SewerNode (Manhole/Basin).
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DSewerNode.GroundLevel">
            <summary>
            Top level of SewerNode (Manhole/Basin)
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DSewerNode.CriticalLevel">
            <summary>
            Cristcal level. TODO: What is this used for?
            Unit: [m]
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultData">
            <summary>
            The result data access is the class that all producers or users of MIKE 1D 
            results should use.
            The class is used for recording the results, reading results, hotstarting the 
            Mike1D engine and extracting specific results.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.Connection">
            <summary>
            Holder of read/write info
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.Parameters">
            <summary>
            Parameters to use when loading results
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.ProjectionString">
            <summary>
            A WKT string defining the spatial reference system. See 
            <see cref="T:DHI.Generic.MikeZero.DFS.IDfsProjection"/>
            for details.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.UnitSystem">
            <summary>
            Unit system of the simulation that produced the result data object.
            <para>
            When creating a result data object and storing:
            Properties of ResultData objects (coordinates, bottom levels etc.) must always be set in SI units. 
            </para>
            <para>
            When loading a result data object from storage:
            The <see cref="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.UnitSystem"/>
            and <see cref="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.ConvertGeometry"/>
            can be used to change units of data and properties in the Result Data object.
            This property will maintain the original value and will not be changed by
            updating the <see cref="T:DHI.Mike1D.ResultDataAccess.IResultDataParameters"/>
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.StartTime">
            <summary>
            Data coverage start
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.EndTime">
            <summary>
            Data coverage start
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.NumberOfTimeSteps">
            <summary>
            Number of time steps
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.TimesList">
            <summary>
            TimeStamp list data. List of DateTimes.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.GetTimesAsArray">
            <summary>
            Gettter for the time stamps contained. The time stamps are returned in a 
            [NumerOfTimeSteps, 7] array. A row contains 
            year, month, day, hour, minute, second, millisecond.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.Quantities">
            <summary>
            List of the contained quantities
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.ResultType">
            <summary>
            Result type
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.GetNumberOfDataItems">
            <summary>
            Total number of data items.
            </summary>
            <returns>Total number of data items.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.GetNumberOfElements">
            <summary>
            Total number of elements.
            </summary>
            <returns>Total number of elements.</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.DataItems">
            <summary>
             This can be used to iterate over all data items.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.DataSets">
            <summary>
             This can be used to iterate over all data sets.
             It will iterate the nodes, reaches, catchment and
             global data, but could be extended in the future.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.Reaches">
            <summary>
            List of reaches
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.Nodes">
            <summary>
            List of nodes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.Catchments">
            <summary>
            List of nodes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.GlobalData">
            <summary>
            Global time series date
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.NetworkDataSet">
            <summary>
            Static data on the network.
            <para>
            Also used for user defined markers from MIKE 11
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.NetworkDatas">
            <summary>
            Static data on the network.
            <para>
            Used for user defined markers from MIKE 11 and Critical Levels in MU.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.DeleteValue">
            <summary>
            Delete value for variables. Any double data value with this value will be 
            treated as a missing value.
            </summary>
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.IResultData.TimeStepEvent">
            <summary>
            Event triggered everytime a time step has been read
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.TriggerTimeStepEvent(System.Int32)">
            <summary>
            Trigger the time step event, e.g. in case a time step has been added, updated or before writing to file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.Load">
            <summary>
            Loads results from a persistent media into memory. Load uses the connection object to 
            decide what and how it should load the data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.Load(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Loads results from a persistent media into memory. Load uses the connection object to 
            decide what and how it should load the data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.LoadHeader(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Loads the header information of the results from a persistent media into memory. Load uses the connection 
            object to decide what and how it should load the data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.LoadHeader(System.Boolean,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Loads the header information of the results from a persistent media into memory. Load uses the connection 
            object to decide what and how it should load the data.
            
            Using the filter argument the user may choose to load only a sub-selection of the entire data.
            </summary>
            <param name="keepStorageOpen">Flag indicating if to keep storage (file) open. Storage (file) will be closed at end of <see cref="M:DHI.Mike1D.ResultDataAccess.IResultData.LoadData(DHI.Mike1D.Generic.IDiagnostics)"/>.</param>
            <param name="diagnostics">Errors and warnings object</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.LoadData(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Loads the dynamic data of the results from a persistent media into memory. The <see cref="M:DHI.Mike1D.ResultDataAccess.IResultData.LoadHeader(DHI.Mike1D.Generic.IDiagnostics)"/>
            must already have been called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.Save">
            <summary>
            Saves the contents of the class using the defined connection.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.Flush(System.Boolean)">
            <summary>
            Saves the contents of the class using the defined connection.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.MaxBufferSize">
            <summary>
            The MaxBufferSize is the limit for how many time steps that may be 
            held in memory during file generation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.Prepare(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Prepare the result data for new data. After this is called, the
            result data should be ready to handle calls to <see cref="M:DHI.Mike1D.ResultDataAccess.IResultData.Update(System.DateTime)"/>
            and <see cref="M:DHI.Mike1D.ResultDataAccess.IResultData.UpdateAndFlushIfNeeded(System.DateTime)"/>.
            
            This will usually open the file on the disc, making it ready to
            write to the file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.Update(System.DateTime)">
            <summary>
            The method pulls data into the result data access module and passes the data
            to the dataItems.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.Update(System.DateTime,System.Int32)">
            <summary>
            The method pulls data into the result data access module and passes the data
            to the dataItems, storing it at the specifed <paramref name="updateIndex"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.UpdateAndFlushIfNeeded(System.DateTime)">
            <summary>
            The methods checks if an update is needed for this time (time step). If so, 
            data is pulled into the result data object and passes the data to the dataItems. 
            After this it is tested whether the number of time steps kept in the DataItems are 
            larger or equal to MaxBufferSize. In case it is the data is flushed to persistant storage.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.Dispose">
            <summary>
            Dispose of ressources
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.GenerateDerivedProperties">
            <summary>
            Generate derived properties: ResultData.Quantities and ResultData.StructureTypes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.StructureTypes">
            <summary>
            List of the contained quantities. Note: This is a derived property
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultData.GridPointsWithStructure(System.String)">
            <summary>
            List of gridpoints that contain a specific structure. Note: This is a derived property
            </summary>
            <param name="structureType"></param>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultData.Bridge">
            <summary>
            Get the bridge that was used for loading/saving
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultDataIO">
            <summary>
            TODO: Interface for working the the data in the underlying file format, on
            a file based manner.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.ReadTimestep(System.Int32)">
            <summary>
            Read all items of the specified time step. Data is loaded into each seperate data item
            within the Res1D data structure
            </summary>
            <param name="timestepIndex">Index of the time step</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.WriteTimestep(System.Int32)">
            <summary>
            Write all items of the specified time step. Data is taken from each seperate data item
            within the Res1D data structure. It is assumed that these data are available everywhere.
            </summary>
            <param name="timestepIndex">Index of the time step</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.ReadItemTimestepNext">
            <summary>
            Read the item and timestep from the file. Data is not loaded into the
            Res1D data structures.
            </summary>
            <returns>The dynamic item-timestep as specified.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.ReadItemTimestep(DHI.Mike1D.ResultDataAccess.IDataItem,System.Int32)">
            <summary>
            Read the item and timestep from the file. Data is not loaded into the
            Res1D data structures.
            </summary>
            <returns>The dynamic item-timestep as specified.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.ReadItemTimestep(DHI.Mike1D.ResultDataAccess.IRes1DItemData,System.Int32)">
            <summary>
            Read the item and timestep from the file. Data is not loaded into the
            Res1D data structures.
            </summary>
            <param name="itemData">The dynamic item-timestep as specified.</param>
            <param name="timestepIndex">Index of timestep to load</param>
            <returns>bool on success</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.WriteItemTimestepNext(System.Double,System.Array)">
            <summary>
            <para>
            Writes the next dynamic item-timestep data to the underlying storage
            </para>
            </summary>
            <param name="time">Time of timestep</param>
            <param name="data">Data to write</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.WriteItemTimestep(DHI.Mike1D.ResultDataAccess.IDataItem,System.Int32,System.Double,System.Array)">
            <summary>
            <para>
            Writes the specified dynamic item-timestep data to the underlying storage. 
            </para>
            </summary>
            <param name="dataItem">Data item to write (item number)</param>
            <param name="timestepIndex">Time step index to write</param>
            <param name="time">Time of timestep</param>
            <param name="data">Data to write</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.Reset">
            <summary>
            Resets the storage pointer to point on the first dynamic item time step in the file.
            <para>
            Can also be used if it is required to restart reading the static items.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataIO.Close">
            <summary>
            Close the file and release all ressources associated with it. The header information
            is still valid (for reading) even though the file has been closed.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DItemData">
            <summary>
            Data for one data item and one timestep. 
            <para>
            Depending on the type of data in the file, 
            this can be cast to a similar <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DItemData`1"/>
            and the <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DItemData.Data"/> can be cast to its raw
            array data type.
            </para>
            <para>
            This interface is never implemented directly.
            </para>
            </summary>
            <remarks>
            This differs from <see cref="T:DHI.Generic.MikeZero.DFS.IDfsItemData"/> in that
            the <see cref="P:DHI.Mike1D.ResultDataAccess.IRes1DItemData.DataItem"/> is returned as an ItemNumber (integer).
            This could be reused, if the data item enumerator was made into a list.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DItemData.DataItem">
            <summary>
            Data item that the data belongs to.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DItemData.TimeStepIndex">
            <summary>
            Index of time step that data belongs to (zero-based)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DItemData.Time">
            <summary>
            Time of the data. Unit for the time equals the temporal axis. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DItemData.Data">
            <summary>
            Data in the file. The data can be cast to one of the basic array
            types, as for example double[], depending on the type of data stored in the item
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IRes1DItemData`1">
            <summary>
            Data for one item and timestep. This is the generic extension 
            of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DItemData"/> 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IRes1DItemData`1.Data">
            <summary>
            Data in the file in its basic type. 
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IListTimeStepData">
            <summary>
            Interface for a list of <see cref="T:System.Double"/>'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IListTimeStepData.Add(System.Double[])">
            <summary>
            Add a double[] to the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IListTimeStepData.Item(System.Int32)">
            <summary>
            Get or set the double[] at the specified index in the list
            </summary>
            <param name="index">Index in list</param>
            <returns>double[] at the index</returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IListTimeStepData.Count">
            <summary>
            The number of double[]'s in the list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IListTimeStepData.IndexOf(System.Double[])">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire List. 
            </summary>
            <param name="item">The object to locate in the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>The zero-based index of the first occurrence of item within the entire List, if found; otherwise, â€“1. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IListTimeStepData.Find(System.Predicate{System.Double[]})">
            <summary>
            Searches for an element that matches the conditions defined by 
            the specified predicate, and returns the first occurrence within 
            the entire List. 
            </summary>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type double[]. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IListTimeStepData.Remove(System.Double[])">
            <summary>
            Removes the first occurrence of a specific object from the List. 
            </summary>
            <param name="item">The object to remove from the List. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
            <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List. </returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IListTimeStepData.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the List. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>This method is an O(n) operation</remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IListTimeStepData.Clear">
            <summary>
            Removes all elements from the List.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoints">
            <summary>
            Class implementing a list of IRes1DCrossSectionPoint's
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoints.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoints.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoints.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.ResultDataAccess.IRes1DCrossSectionPoint})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DReaches">
            <summary>
            Class implementing a list of IRes1DReach's
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReaches.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReaches.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReaches.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.ResultDataAccess.IRes1DReach})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.GridPointTypes">
            <summary>
             Types of gridpoints
            </summary>
            <remarks> 
            <para>
            The bits above 1024 are reserved for flags. 
            The 1024 bit defines whether the gridpoint contains a cross section. 
            </para>
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.GridPointTypes.Undefined">
            <summary>
            Undefined grid point
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.GridPointTypes.HPoint">
            <summary>
            H point, with a cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.GridPointTypes.InterpolatedHPoint">
            <summary>
            H point, interpolated in processed data (no cross section)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.GridPointTypes.QPoint">
            <summary>
            Q point
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.GridPointTypes.StructurePoint">
            <summary>
            Structure point
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.GridPointTypes.RoutingPoint">
            <summary>
            Coinsiding H and Q point, with a cross section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.GridPointTypes.PointWithCrossSectionFlag">
            <summary>
            All points with a cross section must have the 10th bit set
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DGridPoint">
            <summary>
            Abstract base class for gridpoints.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DGridPoint.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DGridPoint._chainage">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DGridPoint.Chainage">
            <summary>
            Chainage of the gridpoint
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DGridPoint._x">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DGridPoint.X">
            <summary>
            X coordinate of the gridpoint at marker 2 of the cross section
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DGridPoint._y">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DGridPoint.Y">
            <summary>
            Y coordinate of the gridpoint at marker 2 of the cross section
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DGridPoint._z">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DGridPoint.Z">
            <summary>
            Z coordinate of the bottom point at marker 2 of the cross section in the gridpoint
            Unit: [m]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DGridPoint._pointType">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DGridPoint.PointType">
            <summary>
            Point type for the gridpoint. HPoint, QPoint, ..
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DGridPoint.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DGridPoints">
            <summary>
            Class implementing a list of IRes1DGridPoint's
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DGridPoints.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DGridPoints.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DGridPoints.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.ResultDataAccess.IRes1DGridPoint})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DReachEnd">
            <summary>
            Enumeration specifying an end of the reach.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DReachEnd.Start">
            <summary>
            Start of reach (low chainage end)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DReachEnd.End">
            <summary>
            End of reach (high chainage end)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DReachConnection">
            <summary>
            Structure containing reach and which end that it is 
            connected to (start or end)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReachConnection.ReachEnd">
            <summary>
            End of reach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReachConnection.Reach">
            <summary>
            Reach
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNode">
            <summary>
             Provides access to node data via Res1D data access.  
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNode.XCoordinate">
            <summary>
            X coordinate of node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNode.YCoordinate">
            <summary>
            Y coordinate of node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNode.ID">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DNode.Reaches">
            <summary>
            List of reaches connected to this node.
            </summary>
            <remarks>
            When creating a new <see cref="T:DHI.Mike1D.ResultDataAccess.ResultData"/> object, or modifying an existing,
            this is not automatically updated.
            Calling <see cref="M:DHI.Mike1D.ResultDataAccess.ResultData.ReconnectNetwork"/> to have it updated.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNode.ToString">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DNodes">
            <summary>
            Class implementing a list of IRes1DNode's
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNodes.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNodes.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DNodes.#ctor(System.Collections.Generic.IEnumerable{DHI.Mike1D.ResultDataAccess.IRes1DNode})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DQGridPoint">
            <summary>
            Specialized Q gridpoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DQGridPoint.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DQGridPoint.PointType">
            <summary>
            Point type for the gridpoint. HPoint, QPoint, ..
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DRoutingGridPoint">
            <summary>
            Specialized routing gridpoint
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DRoutingGridPoint.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DRoutingGridPoint.PointType">
            <summary>
            Point type for the gridpoint. HPoint, QPoint, ..
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultDataXmlBridge">
            <summary>
            Bridge that writes ResultData to XML file using DataContracts
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultDataXmlBridge.FilePath">
            <summary>
            Filepath specification of persistent storage
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataXmlBridge.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultTypes">
            <summary>
             Enum specifying unit type of storing frequency
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultTypes.Unknown">
            <summary>
            Unknown result
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultTypes.HD">
            <summary>
            Hydrodynamic (HD) simulation result
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultTypes.RR">
            <summary>
            Rainfall runoff (RR) result
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultTypes.HDRR">
            <summary>
            Both HD and RR result
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultTypes.LTSEvents">
            <summary>
            Long Term Statistics (LTS) result for extreme values
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultTypes.LTSAnnual">
            <summary>
            LTS annual result
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultTypes.LTSMonthly">
            <summary>
            LTS monthly result
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes">
            <summary>
             Enum specifying unit type of storing frequency
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.PerTimeStep">
            <summary>
            Storing frequence unit in timesteps
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.Days">
            <summary>
            Storing frequence unit in days
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.Hours">
            <summary>
            Storing frequence unit in hours
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.Minutes">
            <summary>
            Storing frequence unit in minutes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.Seconds">
            <summary>
            Storing frequence unit in seconds
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultSpecification">
            <summary>
             Specification for writing results: 
             File to output to, time to output, 
             what to output (quantities), and where (spatially) to include output.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.Interpolate">
            <summary>
            Flag specifying if to interpolate when result storing frequence does not match time steps of the simulation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultSpecification.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultSpecification.FileMode">
            <summary>
            How to handle creation of files
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultSpecification.FileMode.Create">
            <summary>
            Create new file. Do not overwrite existing file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultSpecification.FileMode.Overwrite">
            <summary>
            Create new file. Overwrite if file exists
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultSpecification.FileMode.Append">
            <summary>
            Append to existing file, otherwise create new.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.ID">
            <summary>
            ID of specification
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.Description">
            <summary>
             Description of specification
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.Connection">
            <summary>
            Connection of where and how to store the file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultSpecification.ResultType">
            <summary>
            Result type
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.__saveHD">
            <summary>
            If true, then HD data is saved in ResultData
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.__saveRR">
            <summary>
            If true, then rainfall runoff data is saved in ResultData
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.Mode">
            <summary>
            Mode of which to open file. If file does not exist, 
            the file will always be created. Default is to overwrite
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.StoringFrequency">
            <summary>
             Storing frequence.
             Default value: 1
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.StartTime">
            <summary>
             Start Time for user result selection
             <para>
             Set to <see cref="F:System.DateTime.MinValue"/> to disable
             </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.EndTime">
            <summary>
             End Time for user result selection
             <para>
             Set to <see cref="F:System.DateTime.MinValue"/> to disable
             </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.StoringFrequencyType">
            <summary>
             Storing frequence type
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultSpecification.GetStoringFrequencySpan">
            <summary>
            Calculate a storingFrequency TimeSpan based on <see cref="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.StoringFrequencyType"/>
            and <see cref="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.StoringFrequency"/>
            </summary>
            <remarks>
            Can not be used for <see cref="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.PerTimeStep"/>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultSpecification.CalculateStoringFrequencySpan(DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes,System.Int32)">
            <summary>
            Calculate a storingFrequency TimeSpan based on <see cref="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.StoringFrequencyType"/>
            and <see cref="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.StoringFrequency"/>
            </summary>
            <remarks>
            Can not be used for <see cref="F:DHI.Mike1D.ResultDataAccess.StoringFrequencyUnitTypes.PerTimeStep"/>
            </remarks>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.What">
            <summary>
             List of what to store - which datatypes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultSpecification.DefaultFilter">
            <summary>
            Default filter
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultSpecification.GetFilter(DHI.Mike1D.Generic.IQuantity)">
            <summary>
            Getting IRes1DSpatialFilter 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultSpecification.SetFilter(DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter)">
            <summary>
            Setting IRes1DSpatialFilter
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultSpecification.ToString">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.SerializerCoordsHandler">
            <summary>
            Class handling Coords, using a SerializerCoordsSurrogate for (de)serialization
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.SerializerCoordsSurrogate">
            <summary>
            Surrogated class for DHI.Generic.MikeZero.DFS.Coords
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.SerializerCoordsSurrogate.X">
            <summary>
            X coordinate
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.SerializerCoordsSurrogate.Y">
            <summary>
            Y coordinate
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.SerializerCoordsSurrogate.Z">
            <summary>
            Z coordinate
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.SerializerCoordsSurrogate.#ctor(DHI.Generic.MikeZero.DFS.Coords)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.TimeDataValue">
            <summary>
            Implementation of ITimeData for a single valued item
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DHI.Mike1D.ResultDataAccess.TimeDataValue"/> class that is empty and has the default initial time step capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:DHI.Mike1D.ResultDataAccess.TimeDataValue"/> class that is empty and has the specified initial time step capacity.
            </summary>
            <param name="capacity">The number of time steps that the new object initially allocates.</param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataValue.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataValue.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.Add">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.Add(System.Single[])">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.GetValue(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.GetValues(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.SetValue(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.SetValue(System.Int32,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataValue.SetValues(System.Int32,System.Single[])">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue">
            <summary>
            Implementation of ITimeData for a single valued item
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DHI.Mike1D.ResultDataAccess.TimeDataValue"/> class that is empty and has the default initial time step capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:DHI.Mike1D.ResultDataAccess.TimeDataValue"/> class that is empty and has the specified initial time step capacity.
            </summary>
            <param name="capacity">The number of time steps that the new object initially allocates.</param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.Add">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.Add(System.Single[])">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.GetValue(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.GetValues(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.SetValue(System.Int32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.SetValue(System.Int32,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularValue.SetValues(System.Int32,System.Single[])">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.TimeDataVector">
            <summary>
            Implementation of ITimeData for a vector item
            <para>
            It stores an array of element values for each time step.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVector.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the TimeDataVectorTS class that is empty and has the default initial time step capacity.
            </summary>
            <param name="numberOfElements">Number of elements </param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVector.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the TimeDataVectorTS class that is empty and has the specified initial time step capacity.
            </summary>
            <param name="numberOfElements">Number of elements </param>
            <param name="capacity">The number of time steps that the new object initially allocates.</param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataVector.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataVector.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVector.Add">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVector.Add(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVector.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVector.GetValues(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVector.SetValue(System.Int32,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVector.SetValues(System.Int32,System.Single[])">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector">
            <summary>
            Implementation of ITimeData for a vector item
            <para>
            It stores an array of element values for each time step.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the TimeDataVectorTS class that is empty and has the default initial time step capacity.
            </summary>
            <param name="numberOfElements">Number of elements </param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the TimeDataVectorTS class that is empty and has the specified initial time step capacity.
            </summary>
            <param name="numberOfElements">Number of elements </param>
            <param name="capacity">The number of time steps that the new object initially allocates.</param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.Add">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.Add(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.GetValues(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.SetValue(System.Int32,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataCircularVector.SetValues(System.Int32,System.Single[])">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS">
            <summary>
            Implementation of ITimeData for a vector item.
            <para>
            For each element it stores a list of time steps.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the TimeDataVectorTS class that is empty and has the default initial time step capacity.
            </summary>
            <param name="numberOfElements">Number of elements </param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the TimeDataVectorTS class that is empty and has the specified initial time step capacity.
            </summary>
            <param name="numberOfElements">Number of elements </param>
            <param name="capacity">The number of time steps that the new object initially allocates.</param>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.Add">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.Add(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.Add(System.Single[])">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.GetValues(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.SetValue(System.Int32,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.SetValues(System.Int32,System.Single[])">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.TimeDataVectorTS.Clear">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ListTimeStepData">
            <summary>
            Class implementing a list of double[]'s
            Required for generic list COM interop
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ListTimeStepData.#ctor">
            <summary>
            Initializes a new instance of the List class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ListTimeStepData.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the List class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ListTimeStepData.#ctor(System.Collections.Generic.IEnumerable{System.Double[]})">
            <summary>
            Initializes a new instance of the List class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultTimeStepEvent">
            <summary>
            Delegate type for hooking up time step notifications
            </summary>
            <param name="sender">The result data object that the timestep is stored in</param>
            <param name="timestepIndex">The timestep index in the result data object for the time step data.</param>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultBridge">
            <summary>
            Interface that is to be implemted by any MIKE 1D result bridge. The interface standardizes 
            the communication between ResultData access and persistant storage.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultBridge.Finish">
            <summary>
            Used to disconnect from/close persistant storage and free resources if needed.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultReadBridge">
            <summary>
            Interface that is to be implemted for a bridge that can read data from persistant
            storage into the ResultData access.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultReadBridge.Connection">
            <summary>
            Connection specifying the file to read from
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultReadBridge.NumberOfTimeSteps">
            <summary> Return the number of time steps in the storage</summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.IResultReadBridge.Filter">
            <summary>
            Specifies what data to load. Must be set before 
            any call to the open and read methods.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultReadBridge.Connect(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Connects to storage
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultReadBridge.Read(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads the header and data from persistant storage and populates the associated resultData object.
            This is the same as calling <see cref="M:DHI.Mike1D.ResultDataAccess.IResultReadBridge.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)"/> and <see cref="M:DHI.Mike1D.ResultDataAccess.IResultReadBridge.ReadData(DHI.Mike1D.Generic.IDiagnostics)"/> in that order.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultReadBridge.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads in the header data from persistant storage and populates the associated resultdata object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultReadBridge.ReadData(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads in the data from persistant storage and populates the associated resultdata object.
            <para>
            You can not load the data without having loaded the header, hence it can be assumed 
            that <see cref="M:DHI.Mike1D.ResultDataAccess.IResultReadBridge.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)"/> has already been called.
            </para>
            </summary>
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.IResultReadBridge.TimeStepReadEvent">
            <summary>
            Event triggered everytime a time step has been read
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultRandomReadBridge">
            <summary>
            A read bridge that is able to access time step data in random order from a 
            result storage.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultRandomReadBridge.ReadTimeForTimeStep(System.Int32)">
            <summary> Return the time for the given time step </summary>
            <param name="timestepIndex">Index of time step</param>
            <returns>Time for time step</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultRandomReadBridge.ReadTimeStep(System.Int32,System.Int32)">
            <summary> Read and populate result data with data for the given time step </summary>
            <param name="timestepIndex">Index of time step in data source</param>
            <param name="resultTimestepIndex">Index of time step to store values in resultdata</param>
            <returns>true on success</returns>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DReach">
            <summary>
            Default implementation of <see cref="T:DHI.Mike1D.ResultDataAccess.IRes1DReach"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.Name">
            <summary>
            Name of branch
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.StartNodeIndex">
            <summary>
            Reference to the start node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.EndNodeIndex">
            <summary>
            Reference to the end node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.Length">
            <summary>
            Return length of reach, chainage-length
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DReach._directionType">
            <summary>
            
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.DirectionType">
            <summary>
            Direction for the gridpoint. ???
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.TopoID">
            <summary>
            TotoID of this reach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.GridPoints">
            <summary>
            List of grid points
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.DigiPoints">
            <summary>
            List of digi points
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GetGridPointCoords">
            <summary>
            
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GetDigiPointCoords">
            <summary>
            Returns an array of digi point coordinates.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GridPointIndexForChainage(System.Double)">
            <summary>
            Return index in list of gridpoints for given chainage.
            
            Chainage must be within Constants.LOCATION_EQUAL_TOLERANCE
            of gridpoint chainage, otherwise no grid point is found.
            </summary>
            <param name="chainage">Chainage</param>
            <returns>Index for gridpoint in list, -1 if not found.</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GetChainages(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            <para>
            Returns the chainages for the elements in the dataitem.
            </para>
            <para>
            The <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> must be a <see cref="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.ReachItem"/>
            and having one vertex per element.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GetChainages(System.Int32)">
            <summary>
            <para>
            Returns the chainages for the elements in the dataitem.
            </para>
            <para>
            The <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> must be a <see cref="F:DHI.Mike1D.ResultDataAccess.ItemTypeGroup.ReachItem"/>
            and have one vertex per element only.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GetLowerLimitChainages(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            <para>
            Returns the lower limit chainages for each elements in the dataitem. This is the
            smallest vertex chainage coordinate for each element.
            </para>
            <para>
            If an element only has one vertex coordinate, the chainage of the previous gridpoint 
            is returned(lower chainage). At the first 
            gridpoint the chainage of the gridpoint itself is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GetLowerLimitChainages(System.Int32)">
            <summary>
            <para>
            Returns the lower limit chainages for each elements in the dataitem. This is the
            smallest vertex chainage coordinate for each element.
            </para>
            <para>
            If an element only has one vertex coordinate, the chainage of the prev gridpoint 
            is returned (lower chainage). At the first 
            gridpoint the chainage of the gridpoint itself is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GetUpperLimitChainages(DHI.Mike1D.ResultDataAccess.IDataItem)">
            <summary>
            <para>
            Returns the upper limit chainages for each elements in the dataitem. This is the
            largest vertex chainage coordinate for each element.
            </para>
            <para>
            If an element only has one vertex coordinate, the chainage of the next gridpoint 
            returned (higher chainage). At the last 
            gridpoint the chainage of the gridpoint itself is returned.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.GetUpperLimitChainages(System.Int32)">
            <summary>
            <para>
            Returns the upper limit chainages for each elements in the dataitem. This is the
            largest vertex chainage coordinate for each element.
            </para>
            <para>
            If an element only has one vertex coordinate, the chainage of the gridpoint 
            after the element gridpoint is returned (higher chainage). At the last 
            gridpoint the chainage of the gridpoint itself is returned.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DReach.IsStructureReach">
            <summary>
            Returns true if the reach is a structure reach (special reach with just one structure q-points
            and two h-grid points. The h-grid points have very large (unused) cross sections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DReach.ToString">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DirectionTypes">
            <summary>
            Direction of data on an axis. 
            <example>
            For velocity data, <see cref="F:DHI.Mike1D.ResultDataAccess.DirectionTypes.Positive"/> means that
            positive velocity value is in positive axis direction, 
            while <see cref="F:DHI.Mike1D.ResultDataAccess.DirectionTypes.Negative"/> means that positive velocity
            value is in the negative axis direction.
            </example>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DirectionTypes.Positive">
            <summary>
            Positive flow is in direction of increasing chainage.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DirectionTypes.Negative">
            <summary>
            Positive flow is in direction of decreasing chainage.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res11Bridge._useUbgUnits">
            <summary> Flag indicating whether file is being read in Ubg user units. Not used when writing </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res11Bridge._dfs0File">
            <summary> Flag indicating whether the file is a dfs0 file, without static items, only containing RR data</summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res11Bridge.Connection">
            <inheritdoc/>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res11Bridge.Filter">
            <summary>
            Specifies what data to load
            </summary>
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.Res11Bridge.TimeStepReadEvent">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11Bridge.Read(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads in the data specified by _specification and _filePath and populates the _resultData.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11Bridge.ReadFileInfo(System.String,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read up to the file info only. Properly disposes any existing FileInfo
            before reading a new one.
            </summary>
            <param name="sFileName">>full path to dfs file</param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11Bridge.ReadStaticData">
            <summary>
            read the static data. 
            for the Reaches..
            <para>
            All static data in res11 files are stored with proper EUM definitions,
            usually with eum item undefined and often also with unit undefined.
            Ubg converter in dfs does not do any conversion for undefined items.
            All Ubg conversion is therefore done manually here.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11Bridge.FindOrCreateNode(System.Int32,System.Boolean,System.Collections.Generic.List{System.Int32})">
            <summary>
            Find a node for the given reach at the given end of the reach.
            </summary>
            <param name="reachIndex">Reach</param>
            <param name="startConnection">End of reach to find node for, true for start node, false for end node</param>
            <param name="sourceReachIndices">List of reaches, used to stop recursion</param>
            <returns>Index of node</returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11Bridge.ReadStaticDataArrayNext(System.Int32,System.Type,DHI.Generic.MikeZero.eumItem,DHI.Generic.MikeZero.eumUnit,System.Boolean)">
            <summary>
            Utility: Return an array of static data for the current position of the file
            pointer. Exception if failure.
            <para>
            Handles conversion to user unit, if UBG units are enabled.
            </para>
            </summary>
            <param name="nData">array dimension, -1 if unknown. Ignored if next argument 
            is string</param>
            <param name="expectedType">the type of the data expected, Type.Missing.GetType
            if nothing expected. Char is not allowed, use string instead (will return a 
            string array with 1 element then). Error if discovered type differs.</param>
            <param name="itemType">Type of item</param>
            <param name="itemUnit">Unit of item</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res11Bridge.ReadStaticDataArrayNext(System.Int32,System.Type)">
            <summary>
            Utility: Return an array of static data for the current position of the file
            pointer. Exception if failure.
            </summary>
            <param name="nData">array dimension, -1 if unknown. Ignored if next argument 
            is string</param>
            <param name="expectedType">the type of the data expected, Type.Missing.GetType
            if nothing expected. Char is not allowed, use string instead (will return a 
            string array with 1 element then). Error if discovered type differs.</param>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res11Bridge._dataItems">
            <summary>
            List of data items matching the number of dynamic items in the file.
            Null if data item is not loaded (disregarded by filter during LoadHeader).
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res11Bridge._contained">
            <summary>
            List matching the number of dynamic items in the file.
            false if data item is not loaded (disregarded by filter during LoadHeader or LoadData).
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res11Bridge._userUnit">
            <summary>
            List matching the number of dynamic items in the file.
            <see cref="F:DHI.Generic.MikeZero.eumUnit.eumUUnitUndefined"/> if no unit conversion for this item.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res11Bridge._predefItemData">
            <summary>
            Predefined DFS item data, used when reading, for performance.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res11Bridge._predefItemData0TimestepIndex">
            <summary>
            Timestep index of the predefined item data stored in <see cref="F:DHI.Mike1D.ResultDataAccess.Res11Bridge._predefItemData"/>
            for the first item (0 index). This is required to avoid that the first item
            is read both in <see cref="M:DHI.Mike1D.ResultDataAccess.Res11Bridge.ReadTimeForTimeStep(System.Int32)"/> and in <see cref="M:DHI.Mike1D.ResultDataAccess.Res11Bridge.ReadTimeStep(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoint">
            <summary>
            X-Z Point in a tabulated cross section.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoint.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoint.#ctor(System.Double,System.Double)">
            <summary>
            Constructor with xz value
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoint.X">
            <summary>
            X-coordinate of the cross section point
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoint.Z">
            <summary>
            Z-coordinate of the cross section point
            Unit: [m]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoint.UserMarker">
            <summary>
            Type of user marker on this point
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoint.ToString">
            <summary>
            ToString overridden for debug purposes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DCrossSectionPoint.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection">
            <summary>
            Class implementing a simple open cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.ID">
            <summary>
            ID for the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.LeftLeveeBank">
            <summary>
            Index of LeftLeveeBank
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.LowestPoint">
            <summary>
            Index of LowestPoint
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.RightLeveeBank">
            <summary>
            Index of RightLeveeBank
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.LeftLowFlowBank">
            <summary>
            Index of LeftLowFlowBank
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.RightLowFlowBank">
            <summary>
            Index of RightLowFlowBank
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.LeftCoordinateMarker">
            <summary>
            Index of LeftCoordinateMarker
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.RightCoordinateMarker">
            <summary>
            Index of RightCoordinateMarker
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.Points">
            <summary>
            List for the points defining the cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.GetPointCoords">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DOpenCrossSection.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.Res1DHGridPoint">
            <summary>
            Specialized H gridpoint class extending <see cref="T:DHI.Mike1D.ResultDataAccess.Res1DGridPoint"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.Res1DHGridPoint.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.Res1DHGridPoint._crossSection">
            <summary>
            Cross section at H point
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DHGridPoint.CrossSection">
            <summary>
            Cross section at gridpoint. Null in some HPoints (in older data files at least).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.Res1DHGridPoint.PointType">
            <summary>
            Point type for the gridpoint. HPoint, QPoint, ..
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultData">
            <summary>
            The result data access is the class that all producers or users of MIKE 1D results should use.
            The class is used for recording the results, reading results, hot-starting the Mike1D engine and 
            extracting specific results.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.Bridge">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.Reader">
            <summary>
            Reader used for reading the result file.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.ClearDataItemsOnFlush">
            <summary>
            Flag indicating whether data items are cleared when flushing to file
            <para>
            Default is false.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultData._endTime">
            <summary> A value of DateTime.MinValue means that the end time is defined
            by the last time in the <see cref="F:DHI.Mike1D.ResultDataAccess.ResultData._times"/> list. </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultData.DoStoreDelegate">
            <summary>
            Delegate type used to override the build in functionality of when to store results
            in the result data object.
            </summary>
            <param name="time">Simulation time</param>
            <param name="updateTime">Time where data should be extracted. 
            Default is the simulation time. For HD simulations, the engine can interpolate between the previous and current time step, 
            so any time in between the previous time and the current simulation time is valid</param>
            <param name="updateIndex">Index into result data time list where data should be stored.</param>
            <param name="doFlush">Flag indicating if flushing (writing to file) should be performed.</param>
            <returns>True if data should be stored to the result data object.</returns>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultData.DoStoreUserFunction">
            <summary>
            Function used to override the build in functionality of when to store results
            in the result data object. See <see cref="T:DHI.Mike1D.ResultDataAccess.ResultData.DoStoreDelegate"/> for details.
            <para>
            This is currently not supported for standalone RR simulations.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.Parameters">
            <summary>
            Parameters to use when loading results
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.ProjectionString">
            <summary>
            A WKT string for a spatial reference system.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.UnitSystem">
            <summary>
            Unit system of the simulation that produced the result data object.
            <para>
            When creating a result data object and storing:
            Properties of ResultData objects (coordinates, bottom levels etc.) must always be set in SI units. 
            </para>
            <para>
            When loading a result data object from storage:
            The <see cref="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.UnitSystem"/>
            and <see cref="P:DHI.Mike1D.ResultDataAccess.IResultDataParameters.ConvertGeometry"/>
            can be used to change units of data and properties in the Result Data object.
            This property will maintain the original value and will not be changed by
            updating the <see cref="T:DHI.Mike1D.ResultDataAccess.IResultDataParameters"/>
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.StartTime">
            <summary>
            Data coverage start
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.EndTime">
            <summary>
            Data coverage end
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.NumberOfTimeSteps">
            <summary>
            Number of time steps 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.TimesList">
            <summary>
            Time axis for the data. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.ResultType">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.GetNumberOfDataItems">
            <summary>
            Total number of data items. This will iterate over all types
            of data sets and sum up the data items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.GetNumberOfElements">
            <summary>
            Total number of elements in all data items. This will iterate over all types
            of data sets and sum up the number of elements.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.Quantities">
            <summary>
            List of the contained quantities. Note: This is a derived property
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.StructureTypes">
            <summary>
            List of the contained quantities. Note: This is a derived property
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.GridPointsWithStructure(System.String)">
            <summary>
            List of gridpoints that contain a specific structure. Note: This is a derived property
            </summary>
            <param name="structureType"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.GenerateDerivedProperties">
            <summary>
            Generate derived properties
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.ReconnectNetwork">
            <summary>
            If network is changed (node/reach moved or reconnected), this
            will regenerate the network attributes in the ResultData object.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.DataItems">
            <summary>
            Get an iterator that iterates over all data items
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.DataSets">
            <summary>
            Get an iterator that iterates over all data sets
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.Nodes">
            <summary>
            List of nodes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.Reaches">
            <summary>
            List of branches
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.Catchments">
            <summary>
            List of catchments
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.GlobalData">
            <summary>
            Global data. Valid for entire network
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.NetworkDatas">
            <summary>
            Static data on the network.
            <para>
            Used for user defined markers from MIKE 11 and Critical Levels in MU.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.NetworkDataSet">
            <summary>
            Static data on the network.
            <para>
            Also used for user defined markers from MIKE 11
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.DeleteValue">
            <summary>
            Delete value for double variables. Any double data value with this value should be 
            treated as a missing value.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.MaxBufferSize">
            <summary>
            The MaxBufferSize is the limit for how many time steps that may be 
            held in memory during file generation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.TimeBetweenUpdates">
            <summary>
            Resultdata subscribes to the TimeStepPerformed(DateTime) event. Set this to non-zero to
            control how often data are stored. For non-zero values there will be AT LEAST TimeBetweenUpdates
            between store times in ResultData
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Save">
            <summary>
            Saves the contents of the resultdata using the specified connection properties.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Prepare(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Prepare the result data for new data. After this is called, the
            result data should be ready to handle calls to <see cref="M:DHI.Mike1D.ResultDataAccess.IResultData.Update(System.DateTime)"/>
            and <see cref="M:DHI.Mike1D.ResultDataAccess.IResultData.UpdateAndFlushIfNeeded(System.DateTime)"/>.
            
            This will usually open the file on the disc, making it ready to
            write to the file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.ContainsAtLeastOneDataItem">
            <summary>
            Returns true if there is at least one data item
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.SecondsBetweenFileFlush">
            <summary>
            Seconds between flush to file. Set this lower if you need to read the result file while your
            calculations are running. WARNING: File flush is a potentially expensive operation. Use with care.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Flush(System.Boolean)">
            <summary>
            Saves the contents of the class using the defined connection.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Finish">
            <summary>
            Closes persistant storage and frees related data structures.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.ResultSpecs">
            <summary>
            Result specification
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.UpdateAndFlushIfNeeded(System.DateTime)">
            <summary>
            The method pulls data into the result data access module using the result items and passes the data
            to the dataItems. After this it is tested whether the number of time steps kept in the DataItems are 
            larger or equal to MaxBufferSize. In case it is the data is flushed to persistant storage.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Update(System.DateTime)">
            <summary>
            The method pulls data into the result data access module using the result items and passes the data
            to the dataItems.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Update(System.DateTime,System.Int32)">
            <summary>
            The method pulls data into the result data access module using the result items and passes the data
            to the dataItems.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.TimeOfNextUpdate">
            <summary>
            Time of next update
            </summary>
        </member>
        <member name="E:DHI.Mike1D.ResultDataAccess.ResultData.TimeStepEvent">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.TriggerTimeStepEvent(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Load">
            <summary>
            Loads results from a persistent media into memory. Load uses the connection object to 
            decide what and how it should load the data.
            
            Load is similar to a LoadHeader followed by LoadData
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Load(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Loads results from a persistent media into memory. Load uses the connection object to 
            decide what and how it should load the data.
            
            Load is similar to a LoadHeader followed by LoadData
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.LoadHeader(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Loads the header information of the results from a persistent media into memory. Load uses the connection 
            object to decide what and how it should load the data.
            
            Using the filter argument the user may choose to load only a sub-selection of the entire data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.LoadHeader(System.Boolean,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Loads the header information of the results from a persistent media into memory. Load uses the connection 
            object to decide what and how it should load the data.
            
            Using the filter argument the user may choose to load only a sub-selection of the entire data.
            </summary>
            <param name="keepStorageOpen">Flag indicating if to keep storage (file) open. Storage (file) will be closed at end of <see cref="M:DHI.Mike1D.ResultDataAccess.ResultData.LoadData(DHI.Mike1D.Generic.IDiagnostics)"/>.</param>
            <param name="diagnostics">Errors and warnings object</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.LoadData(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Loads the header information of the results from a persistent media into memory. Load uses the connection 
            object to decide what and how it should load the data.
            
            Using the filter argument the user may choose to load only a sub-selection of the entire data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.Dispose">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultData.PrepareLoad(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Prepare load call. This will setup bridge and reader, and
            make access to the bridge and the reader avaialable before
            actual loading of data starts, i.e. for progress bar implementation
            <para>
            If not called explicitly, it will be called automatically 
            by the load methods. 
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.TimingFlush">
            <summary>
             Timers used for flushing
            </summary>
        </member>
        <member name="P:DHI.Mike1D.ResultDataAccess.ResultData.TimingUpdate">
            <summary>
             Timers used for flushing
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultData.DataSetEnumerable">
            <summary>
            Helper class for iterating over all datasets in the <see cref="T:DHI.Mike1D.ResultDataAccess.ResultData"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultData.DataItemEnumerable">
            <summary>
            Helper class for iterating over all dataitems in the <see cref="T:DHI.Mike1D.ResultDataAccess.ResultData"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultData.DataItemEnumerator">
            <summary>
            Helper class for iterating over all dataitems in the <see cref="T:DHI.Mike1D.ResultDataAccess.ResultData"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.IResultDataReader">
            <summary>
            Interface to connect the <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/> with an
            <see cref="T:DHI.Mike1D.ResultDataAccess.IResultReadBridge"/>. 
            <para>
            Special kind of read functionality can be required in different scenaries.
            Examples of read functionality include lazy reading (read only when required), 
            time-filtered reading etc. The data reader implements this special read functionality
            for the <see cref="T:DHI.Mike1D.ResultDataAccess.IResultRandomReadBridge"/> bridges.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.Read(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads the header and data from persistant storage and populates the associated resultData object.
            This is the same as calling <see cref="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)"/> and <see cref="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.ReadData(DHI.Mike1D.Generic.IDiagnostics)"/> in that order.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads in the header data from persistant storage and populates the associated resultdata object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.ReadHeader(System.Boolean,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads in the header data from persistant storage and populates the associated resultdata object.
            </summary>
            <param name="keepStorageConnection">Flag indicating if to keep file open. File will be closed at end of <see cref="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.ReadData(DHI.Mike1D.Generic.IDiagnostics)"/>.</param>
            <param name="diagnostics">Errors and warnings object</param>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.ReadData(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Reads in the data from persistant storage and populates the associated resultdata object.
            <para>
            You can not load the data without having loaded the header, hence it can be assumed 
            that <see cref="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.ReadHeader(DHI.Mike1D.Generic.IDiagnostics)"/> has already been called.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.IResultDataReader.Close">
            <summary>
            Close storage
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReader">
            <summary>
            Simple data reader that works on the simple <see cref="T:DHI.Mike1D.ResultDataAccess.IResultReadBridge"/>.
            In case filtering or similar is required, this must 
            be implemented in the bridge.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReader._headerKeepFileOpen">
            <summary> Flag indicating if file was kept open from header call </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataReaderRandom">
            <summary>
            Data reader that utilizes the <see cref="T:DHI.Mike1D.ResultDataAccess.IResultRandomReadBridge"/>
            and adds filtering capabilities, so the bridge does not need to do that
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataReaderRandom._headerKeepFileOpen">
            <summary> Flag indicating if file was kept open from header call </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator">
            <summary>
            Class for interpolating ResultData values in time.
            <para>
            This class has some buffer functionality such that results for the same inputs
            are returned immediately, without a need for searching. 
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator._times">
            <summary> Times from ResultData object </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator.#ctor(DHI.Mike1D.ResultDataAccess.IResultData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator.GetInterval(System.DateTime,System.Double@)">
            <summary>
            Calculate interval and fraction for the time.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.ResultDataAccess.DataItemValueTimeInterpolator">
            <summary>
            Class for interpolating data item values in time, for a data
            item with just a single value.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.ResultDataAccess.DataItemValueTimeInterpolator._interpolator">
            <summary> ResultDataTimeInterpolator is a seperate class, to be reused by more than one data item.</summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItemValueTimeInterpolator.#ctor(DHI.Mike1D.ResultDataAccess.ResultDataTimeInterpolator,System.Collections.Generic.IReadOnlyList{System.Double})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.ResultDataAccess.DataItemValueTimeInterpolator.GetValue(System.DateTime)">
            <summary>
            Get value at specified time
            </summary>
        </member>
    </members>
</doc>
