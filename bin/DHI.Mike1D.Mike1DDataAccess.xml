<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DHI.Mike1D.Mike1DDataAccess</name>
    </assembly>
    <members>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController">
            <summary>
            An abstract base controller class.
            <para>
            It handles everything related to the <see cref="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerEvent"/>
            an delegates the real work on to the derived classes in 
            the DoXXX methods.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._timings">
            <summary> Timings used in controller </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._runtimeDiagnostics">
            <summary> Diagnostics object used during runtime </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._mike1DData">
            <summary> MIKE 1D data object </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._state">
            <summary>  Current state of controller  </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._engineNet">
            <summary> EngineNet </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._engineNetGlobal">
            <summary> Global (entire) EngineNet. Used when decomposing setup into several domains, where this contains the full EngineNet </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._resultDataList">
            <summary> Active result data objects </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._suppressUnknownExceptions">
            <summary> Flag indicating whether to suppress unknown exception. </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._controllerProgress">
            <summary> State variable defining how far the controller has got </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._isFailed">
            <summary> True if controller at some point failed </summary>
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerEvent">
            <inheritdoc />
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerProgressEvent">
            <summary> Controller progress event, triggered whenever the controller has progressed, though no more often than <see cref="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.MinSecondsBetweenProgressEvent"/> </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.State">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ProgressState">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.IsFailed">
            <summary> Bool indicating that the controller is in a failed state </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.SimulationType">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.EngineNet">
            <summary>
            The enginenet used for the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ResultDataList">
            <summary>
            List of all result data components associated with 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Timings">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RuntimeDiagnostics">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Mike1DData">
            <summary>
            The Mike1DData that defines the simulation setup
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.MinSecondsBetweenProgressEvent">
            <summary>
            Minimum number of seconds between the <see cref="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerProgressEvent"/> is triggered.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DiagnosticsHandler">
            <summary>
            Handler, taking care of diagnostics messages.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.CurrentTime">
            <summary>
            Current time of simulation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Constructor, providing a diagnostics handler.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.InvokeControllerProgressEvent(System.Double)">
            <summary>
            Call to invoke a progress event
            </summary>
            <param name="progress"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ChangeControllerState(DHI.Mike1D.Mike1DDataAccess.ControllerState)">
            <summary>
            Change the state of the controller. Also triggers the <see cref="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerEvent"/>
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RaiseControllerFailedEvent(System.Exception)">
            <summary>
            Put controller in a failed state, and issue a failed event on <see cref="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerEvent"/>
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Validate">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Initialize(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RunManual">
            <summary>
            Must be called when running the engine manually, timestep by timestep, i.e. when not using the
            <see cref="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Run"/> or <see cref="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.RunUntil(System.DateTime)"/> methods.
            <para>
            This is required for correctly transferring the engine to the run state before taking the 
            time step.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RunStart">
            <summary>
            To be called before running, setting proper state of controller before running.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Run">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RunUntil(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.StopSimulation">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Finish">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.IsInActiveState">
            <summary>
            Returns true if the controller is in an active
            state and currently executing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.InitTimings">
            <summary> Initiate timings </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoValidate">
            <summary> Do Validate. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoInitialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary> Do Initialize. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoPrepare">
            <summary> Do Prepare. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoRun">
            <summary> Do Run. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoRunUntil(System.DateTime)">
            <summary> Do RunUntil. Virtual method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoStopSimulation">
            <summary> Do Stop simulation. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoFinish">
            <summary> Do finish simulation. Abstract method that must be overridden </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControllerExtensions">
            <summary>
            Extension methods for the Controller
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerExtensions.CanWriteHtmlSummary(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Check if controller is in a state to write HTML summary
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControlDataXmlBridge">
            <summary>
            Bridge for reading/writing control data to xml.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControlDataXmlBridge.FilePath">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControlDataXmlBridge.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsDataXmlBridge">
            <summary>
            Bridge class for reading lont term statistics data to/from xml
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsDataXmlBridge.FilePath">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsDataXmlBridge.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationType">
            <summary>
            The type of optmization to perform
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationType.FixedInvertLevel">
            <summary>
            Keep invert levels of all pipes fixed and adjust only pipe diameter
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationType.FixedTopLevel">
            <summary>
            Keep the top level of all pipes fixed, which means that both 
            pipe diameter and pipe invert level are adjusted.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationCriteriaType">
            <summary>
            Pipe design criteria type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationCriteriaType.CriticalLevels">
            <summary> Critical Levels </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationCriteriaType.FillingDegree">
            <summary> Filling degree </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationGroupType">
            <summary>
            Pipe design reach group type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationGroupType.Grouped">
            <summary>
            All reaches in a group are changed together by the same percentage.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationGroupType.Automatic">
            <summary>
            The reaches in this group are optimized individually with respect to the geometric 
            upstream node. Reaches connected to the same node are grouped together
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignIOUnits">
            <summary>
            Units of pipe design in/output
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignIOUnits.SI">
            <summary>
            Use SI units (meter) for reading and writing results
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignIOUnits.US">
            <summary>
            Use US units (feet) for reading and writing results
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData">
            <summary>
            Data class for pipe design data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.Prepare(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create controls necessary to modify pipe Manning numbers and set pipe diameters from 
            pipe design restul file
            </summary>
            <param name="engineNet"></param>
            <param name="controlData"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ConvertMeterToFeetConditionally(System.Double)">
            <summary>
            Conversion from meters to feet, if <see cref="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.InputOutputUnits"/> is <see cref="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignIOUnits.US"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ConvertFeetToMeterConditionally(System.Double)">
            <summary>
            Convert length to SI units if necessary
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.Validate">
            <summary>
            Check PipeDesignData for errors and inconsistencies
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ActiveReaches">
            <summary>
            Return a list of active HDPipeDesignOptimizationReach'es.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.SetDiametersFromResults(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Set new pipe diameters from the results of a previous Pipe Design simulation
            This is called at the beginning of a PD simulation.
            </summary>
            <param name="network"> </param>
            <param name="crossSections"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.Initialize(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.CopyCalculatedNetworkDiametersIntoResults(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Compute new pipe diameters from the Manning numbers found in a PD simulation.
            </summary>
            <param name="network"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.DeletePreviousResults">
            <summary>
            Delete result file (if possible) and delete all previously calculated diameters.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.FindEngineReachFromId(System.String,System.Collections.Generic.IEnumerable{DHI.Mike1D.Engine.EngineReach})">
            <summary>
            Find the EngineReach that has reachId == EngineReach.LocationSpan.ID. If multiple reaches exist that
            have the same ID in locations, then an exception is generated. Use this function from Prepare if the 
            </summary>
            <param name="reachId"></param>
            <param name="reaches"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.FindPipeDesignReachFromId(System.String)">
            <summary>
            Loop through all reaches that are part of Pipe Design and return the one with the
            specified id. 
            </summary>
            <param name="reachId"></param>
            <returns>A HDPipeDesignOptimizationReach or null if the reach was not found</returns>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.CommercialPipeDiameters">
            <summary>
            List of commercial pipe diameters. These are used for suggesting new pipe diameters after a 
            simulation done. The smallest diameter larger than the computed diameter is used as suggestion.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ReadResultFile(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read result file into active flag, init factor and previous results for each reach
            </summary>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.WriteResultFile">
            <summary>
            Write a Pipe Design result file. The result file is a PFS file that contains
            the pipe diameters from a Pipe Design simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.WriteMEXFile(System.String)">
            <summary>
            Write mex file, matching that of MOUSE
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ResultFile">
            <summary>
            File path of the Pipe Design result file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.DesignOptimizationItems">
            <summary>
            A list of items in the Pipe Design simulation. Each item contains a list of reaches
            that will be modified.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDWeightTimeStep3">
            <summary>
            PID weight of time step n-2 to use when modifying the Manning number of reaches.
            Default value 1.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDWeightTimeStep2">
            <summary>
            PID weight of time step n-1 to use when modifying the Manning number of reaches.
            Default value 1.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDWeightTimeStep1">
            <summary>
            PID weight of time step n to use when modifying the Manning number of reaches.
            Default value 1.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDDerivationPeriod">
            <summary>
            PID derivation period in seconds. Default value 0.8 seconds.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDIntegrationPeriod">
            <summary>
            PID integration period in seconds. Default value 300 seconds.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDProportionalityFactor">
            <summary>
            PID proportionality factors. Default value -1
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.InputOutputUnits">
            <summary>
            Unit of input and output files
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.MEXFile">
            <summary>
            Name and path of mex file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.FindPipeDesignItemFromId(System.String)">
            <summary>
            Find a Pipe Design item from an id. This is used from the control module
            when all the reaches in an item are controlled as a group (then the
            control module operates on the item instead of on the individual reaches)
            </summary>
            <param name="itemId"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem">
            <summary>
            Contains item to optimize
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.NodeId">
            <summary>
            Name of the upstream node
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.AddReach(System.String)">
            <summary>
            Add reach to list of reaches that should be optimized.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.LowerWaterLevelLimit">
            <summary>
            The manning number will not be adjusted if the water level 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.FillingDegree">
            <summary>
            Largest degree of filling for reaches
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.Type">
            <summary>
            Specifies what can be optimized
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.GroupType">
            <summary>
            How to optimize, in groups or individually
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.CriteriaType">
            <summary>
            Criteria for optimization
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.Reaches">
            <summary>
            Reaches to optimize
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.Control(System.Double,System.Int32)">
            <summary>
            Setter for controllable entity. Used by the control module.
            Can safely be called multiple times with the same timeN.
            </summary>
            <param name="newValue"></param>
            <param name="controlStrategyId"> </param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.Validate">
            <summary>
            Validate
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.GetDesignFactor">
            <summary>
            Get design factor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach">
            <summary>
            Pipe design reach. The Control() method sets the Manning number of the _first_ XS in the
            underlying EngineReach. In MU setups, the cross section is shared between all points in the
            underlying reach, so in MU setups the Manning number of the whole reach 
            will be controlled.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach._xsCircular">
            <summary>
            This is a pointer into the Engine to the XSCircularPreprocessed that is being modified.
            The reference is set in Prepare()
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Prepare(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Prepare the Pipe Design reach. 
            </summary>
            <param name="network"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.GetAverageManning">
            <summary>
            Calculate a single Manning number, even if the Manning number is exponential.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.GetAverageOriginalManning">
            <summary>
            Calculate a single Manning number, even if the Manning number is exponential.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.GetEngineReach">
            <summary>
            Find the IReach that has _reachId == EngineReach.LocationSpan.ID. If multiple reaches exist that
            have the same ID in locations, the first reach is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.ReachId">
            <summary>
            ID of the underlying EngineReach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.UpstreamNodeId">
            <summary>
            ID of the upstream node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Active">
            <summary>
            If true, then the reach will control the underlying reach's Manning number.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.InitialDesignFactor">
            <summary>
            The control of Manning number is indirect in that the control acts on a factor that is
            multiplied onto the Manning number (the actual Manning number is the original Manning nubmer
            times this factor). InitialDesignFactor controls the value of the factor at the beginning
            of the simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.OriginalDiameter">
            <summary>
            Original diameter of the reach (really of the first (upstream) cross section)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Results">
            <summary>
            List of results from previous simulations
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.DesignFactor">
            <summary>
            Current value of the design factor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.MaxManning">
            <summary>
            Maximum value of the manning number
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.MinManning">
            <summary>
            Minimum value of the manning number
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Diameter">
            <summary>
            The current diameter of the underlying circular reach (the diameter of the cross
            section in the first h-grid point).
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach._controlStategyId">
            <summary>
            If the item is being controlled, then _controlStategyId contains the ID of the
            active control strategy
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Control(System.Double,System.Int32)">
            <summary>
            Setter for controllable entity. Used by the control module.
            Can safely be called multiple times with the same timeN.
            </summary>
            <param name="newValue"></param>
            <param name="controlStrategy"> </param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.ResetControlledState">
            <summary>
            Reset controlled state to initial values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.CalculateNewReachDiametersAndCopyToResults(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Calculate new reach diameter from the Manning number of the cross section in the first 
            (upstream) grid point, and save this diameter to the results list.
            </summary>
            <param name="network"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.DeltaDiameter">
            <summary>
            Return the change in diameter from the original diameter to the newest available result
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.SetDiameterFromResults(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.CrossSectionModule.CrossSectionData,System.Boolean,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Set reach diameter from results. This is called in Initialize() which is called so before Prepare(), therefore 
            we cannot use _xsCircular.
            </summary>
            <param name="network"> </param>
            <param name="crossSections"></param>
            <param name="fixedReachTopLevel"> </param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Validate">
            <summary>
            Validate reach data
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.SaveOriginalDiameter(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Save original diameters, to be used when rerunning the simulation
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSJob">
            <summary>
            A SimulationEvent describes one of a series of simulations that are performed during the
            total runtime of the Long Term Simulation. A SimulationEvent is the same as am LTS "job" in MU terms.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.StartTime">
            <summary>
            Start time of LTS Job
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.EndTime">
            <summary>
            End time of LTS Job
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.ActualStartTime">
            <summary>
            Time at which the job started in the simulation. Can be different from StartTime since the
            previous job can extend into this job.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.ActualEndTime">
            <summary>
            Time at which the job ended in the simulation. Can be different from EndTime since the
            the job runs until the stop conditions are fulfilled.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.JobStartCriterionId">
            <summary>
            Id of Job-start criteria
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.DtMin">
            <summary>
            Minimum Dt in job
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.DtMax">
            <summary>
            Maximum Dt in Job
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.HotStartDate">
            <summary>
            Time to extract hotstart from
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.UseHotStartFile">
            <summary>
            Flag indicating if to use hot start file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.HotStartFile">
            <summary>
            Name and path of hot start file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSJobList">
            <summary>
            LTS joblist 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobList.ReadFromFile(DHI.Mike1D.Generic.IFilePath,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read job list file (PFS file with .MJL extension)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobList.WriteToFile(DHI.Mike1D.Generic.IFilePath)">
            <summary>
            Write job list file (PFS file with .MJL extension)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator">
            <summary>
            Class for creating an LTS job list.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.ResultDataBuffer">
            <summary>
            Result data buffer. Assign an existing one, to share a buffer already in use.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.CurrentTime">
            <summary>
            Current time in the job list generation.
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.PostTimeStepEvent">
            <summary>
            An event that is called after a time step.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator._allNodes">
            <summary> null correspond to all nodes </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.ConditionTimeSpanBox">
            <summary>
            A trivial boxed TimeSpan so that we can modify the TimeSpan in a dictionary
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.#ctor(DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS,DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.Generic.Diagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.CreateJobList">
            <summary>
            Returns LTSJobList for given simulation parameters in mike1DData.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.CreateJobList(System.DateTime,System.DateTime,System.TimeSpan)">
            <summary>
            Returns LTSJobList for given simulation parameters.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.RainActive(System.DateTime)">
            <summary>
            Return true if any rain boundaries exceed _mike1DData.LongTermStatistics.EpsilonRain at time
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobListCreator.GetTotalInflow(System.Collections.Generic.IList{DHI.Mike1D.Generic.Collections.ValueIdList.Item},System.Boolean)">
            <summary>
            Get inflow contributions from point source boundaries into nodes and catchment connections into nodes.
            For includeOnlyStormRunoff=true only Storm Runoff contributions are included.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSResultSpecification">
            <summary>
            Result specification of LTS results
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSResultSpecification.ResultSpecificationItems">
            <summary>
            List of result specifications
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSResultType">
            <summary>
            Type of LTS results
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSResultSpecificationItem.#ctor">
            <summary>
            Initializer for LTSResultSpecificationItem.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSResultSpecificationConverter">
            <summary>
            Class for converting the old LTSResultsSpecification to result specifications
            used in Release 2019 and later.
            After LTSResultsSpecification is completely removed this class can be deleted.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge">
            <summary>
            Bridge for reading the .m1da file, Mike 1D Additional setup file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.#ctor(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.PluginInfos">
            <summary>
            List of plugins loaded from .m1da file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.Open(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.Read(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read the sim11 file into the _mike1dDataAccess.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.FilePath">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.Save">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerEM">
            <summary>
            The Mike1DControllerEM is the entry point for an HD simulation, including
            any enabled modules (Rainfall runoff, AD, Control etc.)
            It is primarely used by DA for the Ensemble Members.
            <para>
            It links the simulation setup with the actual engine setup. It controls
            initialization, start, stop and finalization of the engine.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerEM.#ctor">
            <summary>
            Default constructor
            <para>
            The logfilewriter will be created based on the input file name, or connection properties,
            when calling the <see cref="!:Open"/> method.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerEM.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Make a controller that uses the provided <paramref name="diagnosticsHandler"/> for 
            handling diagnostics messages. 
            This is convenient if the <paramref name="diagnosticsHandler"/> is to be resued by more than
            one controller.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerEM.ReadStartStates">
            <summary>
            Ensemble member controllers reads the start state through the Main DA module and not through the controller.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerEM.SetupStateWriting">
            <summary>
            Ensemble member controllers writes the controller state through the Main DA module and not through the controller.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory">
            <summary>
            Factory class for creating <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/>.
            <para>
            The controller can either be created based on the content of <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/>,
            or from a <see cref="T:DHI.Mike1D.Generic.IConnection"/>, in which case the data will also be loaded.
            </para>
            <para>
            The factory handles log files. By default a new log is created every time a new controller is created,
            and the log file is closed when the controller finishes.
            You can disable log files by setting <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DisableLogFile"/>
            and if you want to reuse a log file for several controllers (append to it), set manually your own
            <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.LogFileWriter"/>. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DisableLogFile">
            <summary>
            Flag to disable log-file writing of the controller
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.KeepLogFileOpen">
            <summary>
            Flag to keep log-file open after simulation has finalized
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.LogFileWriter">
            <summary>
            User provided log file writer.
            <para>
            Set manually if a specified log file writer is to be reused
            for several controllers, or if other types of control
            with the log file writer is required.
            </para>
            <para>
            If the log file writer is provided by the user, remember
            also to attach it to the DiagnosticsHandler 
            <code>
            diagnosticsHandler.MessageEvent += logFileWriter.AddLine;
            </code>
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DiagnosticsHandler">
            <summary>
            User provided <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DiagnosticsHandler"/>.
            <para>
            Set manually if a specified diagnostics handler is to be reused
            for several controllers, or if other types of control
            with the diagnositcs handler is required.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.OpenAndCreate(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Open setup and populate <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/>, and create a <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/>.
            </summary>
            <param name="connection">Connection to file</param>
            <param name="diagnostics">Diagnostics object receiving load messages</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.PrepareLogfile">
            <summary>
            Prepare log file, and write header information to log file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.SetupCloseLogFileOnControllerFinalized(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Connect the log file writer to the controller, such that the log file
            is automatically closed on controller failed or finished.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.CreateController(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Create controller, using the provided MIKE 1D data object.
            <para>
            Sets up log-file writing. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.CreateLogFileWriter(DHI.Mike1D.Generic.IConnection)">
            <summary>
            Create a default log-file-writer
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.CreatePreController(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Create pre-simulation controller. A pre-controller may need to
            run before the actual simulation in order to preproces any 
            required data.
            <para>
            The only current pre-controller is auto-calibration of NAM/RDI
            catchments.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.logfileWriterCreated">
            <summary>
            Date-time format string
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.Create(System.String,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Load data from file, and create controller.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.Create(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Load data from file, and create controller.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.Create(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Create controller based on content of the <paramref name="mike1DData"/>.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS">
            <summary>
            The Mike1DControllerLTS is the entry point for a Long Term Statistics simulation.
            It controls initialization, start, stop and finalization of the engine.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.LTSStateInfo">
            <summary>
            Get a string that informs the user about progress in the job generation process. Used by the GUI.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.SimulationType">
            <summary>
            String to indicate the type of simulation being run. Used for user output only.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.CurrentTime">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Constructor, using the provided diagnostics handler.
            </summary>
            <param name="diagnosticsHandler"></param>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GenerateLTSJobList">
            <summary>
            Indicates if the simulation generates the job list only
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.JobListCreator">
            <summary>
            LTS job list creator
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.JobDoneEvent">
            <summary>
            An event that is called before the start of LTS job simulation
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.JobStartEvent">
            <summary>
            An event that is called when the LTS job simulation is done
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.DoInitialize(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.DoValidate">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.DoPrepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.DoRun">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.DoStopSimulation">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.AddNodeToList(System.String,System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineNode},System.String,System.String)">
            <summary>
            Add node to the 'nodes' list
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.AddReachToList(System.String,System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineReach},System.String,System.String)">
            <summary>
            Add a reach to the 'reaches' list
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.RuntimeConditionState.Active">
            <summary>
            Active true means that the runtime stop condition is fulfilled, and
            this condition allows the simulation to stop.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetTotalInflow(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineNode})">
            <summary>
            Get inflow contributions from point source boundaries and catchment connections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetTotalOutflow(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineNode})">
            <summary>
            Get outflow contributions from point source boundaries and catchment connections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetTotalVolume(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineNode},System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineReach})">
            <summary>
            Get the total water volume in nodes and reaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetFillingDegree(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineNode},System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineReach})">
            <summary>
            Get the maximal filling degree in nodes and in grid points of reaches.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetDepth(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineNode})">
            <summary>
            Get the maximal depth in given nodes.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetLocalFlow(System.Collections.Generic.IList{DHI.Mike1D.Engine.EngineReach})">
            <summary>
            Get local flow in nodes and in grid points of reaches.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControllerState">
            <summary>
            State of controller
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Created">
            <summary> Controller created, the initial state </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Validating">
            <summary> Controller is validating </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Validated">
            <summary> Controller has sucessfully validated setup </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Invalid">
            <summary> Controller has validated setup, and validation failed </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Initializing">
            <summary> Controller is inititalizing </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Initialized">
            <summary> Controller has successfully initialized. </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Preparing">
            <summary> Controller is preparing </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Prepared">
            <summary> Controller has succesfully prepared </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Running">
            <summary> Controller is running </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Paused">
            <summary> Controller is paused while running setup </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Stopped">
            <summary> Controller was stopped while running setup </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Finished">
            <summary> Controller succesfully finished running </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Finalizing">
            <summary> Controller is finalizing </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Finalized">
            <summary> Controller successfully finalized </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Failed">
            <summary> Controller has failed </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs">
            <summary>
            Class containing event data for the controller event.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.#ctor(DHI.Mike1D.Mike1DDataAccess.ControllerState)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.#ctor(DHI.Mike1D.Mike1DDataAccess.ControllerState,System.String)">
            <summary>
            Constructor with additional info string
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.#ctor(DHI.Mike1D.Mike1DDataAccess.ControllerState,System.String,System.Double)">
            <summary>
            Constructor with additional info string and progress
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.State">
            <summary>
            Current state of the controller
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.AdditionalInfo">
            <summary>
            Additional info following the event.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.Progress">
            <summary>
            Progress indicator, a value between 0 (started) and 1 (finished).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.Exception">
            <summary>
            Exception, set when the controller has failed due to an unexpected exception.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControllerCreatedEventArgs">
            <summary>
            Class containing event data for the controller created event.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerCreatedEventArgs.Controller">
            <summary>
            Controller created
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerCreatedEventArgs.#ctor(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController">
            <summary>
            The <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/> is the starting point for 
            controlling and running a simulation. Depending on the underlying
            data components, the controller may do different things. Different
            data controllers may also do different things on the same data
            components. The following are examples of controllers:
            <list type="bullet">
            <item>HD controller: runs an HD simulation, including add ons (rainfall runoff, AD etc.)</item>
            <item>RR controller: runs an RR simulation.</item>
            <item>RR calibration controller: runs an RR calibration.</item>
            <item>LTS controller: runs a LTS (Long Term Statistics) HD simulation.</item>
            </list>
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ControllerEvent">
            <summary>
            Event that is raised while the controller is running.
            It is raised whenever the <see cref="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.State"/> of the controller changes.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.SimulationType">
            <summary>
            String to indicate the type of simulation being run. Used for user output only.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Mike1DData">
            <summary>
            The Mike1DData that defines the simulation setup
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.EngineNet">
            <summary>
            The enginenet used for the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ResultDataList">
            <summary>
            List of all result data components associated with 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.RuntimeDiagnostics">
            <summary>
            Diagnostics that are used during the simulation (prepare, run)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Timings">
            <summary>
            Detailed timings of the different parts of the simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.State">
            <summary>
            Current state of the controller
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ProgressState">
            <summary>
            Progress state of the controller, specifying how far the controller has progressed. One of 
            <see cref="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Initialized"/>,<see cref="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Prepared"/>,<see cref="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Running"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.CurrentTime">
            <summary>
            Current time of controller.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Validate">
            <summary>
            Validate that the Controller/data access modules does not have any errors/warnings.
            Can be called before <see cref="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Initialize(DHI.Mike1D.Generic.IDiagnostics)"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Initialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize the engine. Initialize sets up the engine net. When done, the EngineNet
            will be ready to inform on what data is available
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Prepare">
            <summary>
            Prepare the engine. This is called just before run is called. I will 
            set the initial state (initial conditions), open output files etc.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Run">
            <summary>
            Run the engine
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.RunUntil(System.DateTime)">
            <summary>
            Run the engine until endTime.
            <para>
            endTime should not exceed the simulation end time.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.StopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Finish">
            <summary>
            Finish and clean up.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes">
            <summary>
            Type of network locations
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.AllNodes">
            <summary>
            All nodes in the network
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.ListOfNodes">
            <summary>
            A list of nodes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.SingleNode">
            <summary>
            A single node
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.AllReachess">
            <summary>
            All reaches in the network
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.ListOfReaches">
            <summary>
            A list of reaches
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.SingleReach">
            <summary>
            A single reach
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.StructureReaches">
            <summary>
            Structure reaches
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.StructureReachesConnectedToNode">
            <summary>
            Structure reaches connected to node
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.TotalOut">
            <summary>
            Total out
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.ListOfStructures">
            <summary>
            List of structures
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSRuntimeStopConditionCollection">
            <summary>
            Holds a list of LTSRuntimeStopCondition's that must all be satisfied for a job to stop
            (the LTSRuntimeStopConditions in the collection are combined with the logical "and" operator).
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSInitialCondition">
            <summary>
            LTSInitialCondition hold hot start information for the individual jobs in the LTS simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSInitialCondition.StartInflow">
            <summary>
            This initial condition is used if total inflow at job start time is in the interval [StartInflow; EndInflow]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSInitialCondition.DateToUseInHotStartFile">
            <summary>
            Initial water levels, discharges etc are taken from the hot start file at this date. The _time_ at which the 
            values are taken is equal to the time of job start. To rephrase: The actual DateTime to use when accessing the 
            hot start file is a combination of the date from DateToUseInHotStartFile and the time of day when the job starts.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSInitialCondition.HotStartFile">
            <summary>
            Path to the hot start file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.IncludeDtMinMaxInJoblistFile">
            <summary>
            Include DtMin and DtMax in job list file. Only included so that users can 
            edit the joblist file later and modify for individual events
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.EpsilonRain">
            <summary>
            Do not start simulation if it rains less than EpsilonRain ( m3/s / m2 )
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.MinimumTimeBetweenRain">
            <summary>
            Combine two LTS events if they are less than MinimumTimeBetweenRain apart
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.MaxCatchmentDelayTime">
            <summary>
            After that much time it is allowed to jump after a rain event in job list generation.
            This values should be determined by the maximum delay time of the catchment.
            Default value is zero.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.JobListTimeStep">
            <summary>
            Time step for joblist generation.
            Default value is 1 minute.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.DischargeThreshold">
            <summary>
            Discharge threshold for accumulated event values
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.ResultSpecifications">
            <summary>
            Specifications on how to write result files, when, what to include and where.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.JobListFilePath">
            <summary>
            The job list read from or written to this file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.ResultFilePath">
            <summary>
            LTS results are written to this file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory">
            <summary>
            Factory that sets up and connects the control module
            with the engine net.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.CreateControllableStructureDictionary(DHI.Mike1D.StructureModule.IStructureCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Create dictionary of all controllable structures
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.CreateStructureDictionary(DHI.Mike1D.StructureModule.IStructureCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Create dictionary of all structures
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ConnectControlData(DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Method to connect control data structures to the engine net and pipe design
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.CreateControlVariables">
            <summary>
            Creates a list of control variables that are supported by the engine.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ConnectBuildInVariables(DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Connect sensors to the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ConnectSensorsToNetwork(DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.StructureModule.IStructure},System.DateTime,DHI.Mike1D.Generic.IFilePath,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Connect sensors to the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ConnectActionsToStructures(DHI.Mike1D.ControlModule.ControlData,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.Generic.IControllable},DHI.Mike1D.Engine.EngineNet,System.DateTime,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Connect actions to the structures
            </summary>
            <param name="controlData"></param>
            <param name="structureIdToStructureDictionary"> </param>
            <param name="engineNet"></param>
            <param name="simulationStart"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.IdentifyLicenseFreeControls(DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.StructureModule.IStructure},DHI.Mike1D.ControlModule.ControlData)">
            <summary>
            Identify link regulation control.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ControlIsLinkRegulation(DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.StructureModule.IStructure},DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.ControlModule.ControlStateMachine)">
            <summary>
            Check whether the <paramref name="csm"/> is a link-regulation control.
            <para>
            A link regulation control is only allowed to control a link regulation (discharge) structure at the first Q-grid point.
            </para>
            </summary>
            <returns>True if control is a link regulation control</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ControlIsWetWellSetPoint(DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.StructureModule.IStructure},DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.ControlModule.ControlStateMachine)">
            <summary>
            Check whether the <paramref name="csm"/> is a wet-well set point
            <para>
            A wet well set point is a pump control with a PID action, controlling the upstream water level towards a constant
            </para>
            </summary>
            <returns>True if control is a wet-well set point</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Save(DHI.Mike1D.ControlModule.ControlData)">
            <summary>
            Save control data to file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Open(DHI.Mike1D.Generic.IConnection)">
            <summary>
            Open control data from file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater">
            <summary>
            Helper class for updating various variables.
            <para>
            Currently it updates only the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater.Dt"/> variable with the current time step.
            </para>
            </summary>
            <remarks>
            This helper class is required, because the ControlModule must be independent of the 
            MIKE 1D engine. 
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater.Dt">
            <summary>
            Dt variable
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater.Update(System.DateTime,System.DateTime)">
            <summary>
            Update variables. Must be called at pre-timestep event or pre-iteration event
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DBridgeFactory">
            <summary>
            Factory class for creating <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DBridge"/>, used
            by <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge"/> loader: You can register your
            own bridge using <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DBridgeFactory.Create">
            <summary>
             Create bridge for opening a MIKE 1D setup
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection">
            <summary>
            Collection of MIKE 1D bridges, <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DBridge"/>.
            <para>
            Register a new bridge by calling <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.AddBridge(System.String,System.String,DHI.Mike1D.Mike1DDataAccess.IMike1DBridgeFactory)"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.#cctor">
            <summary>
            Static constructor, registering all standard bridges.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.AddBridge(System.String,System.String,DHI.Mike1D.Mike1DDataAccess.IMike1DBridgeFactory)">
            <summary>
            Register bridge factory to the collection.
            <para>
            If bridge name is already registered, an exception is thrown
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.GetBridge(System.String)">
            <summary>
            Get bridge for given bridge name
            </summary>
            <param name="bridgeName">Name of bridge, usually extension of setup file</param>
            <returns>Bridge, or null if bridgename is not registered.</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.GetBridgeLongName(System.String)">
            <summary>
            Get long name of bridge
            </summary>
            <param name="bridgeName">Name of bridge, usually extension of setup file</param>
            <returns>Long name of bridge.</returns>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DBridge">
            <summary>
            Bridge interface, for loading a MIKE 1D setup from storage.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DBridge.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Open MIKE 1D data from <paramref name="connection"/> specifications
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DMUBridge">
            <summary>
            Special interface for loading MIKE URBAN data into MIKE 1D
            within the MIKE URBAN GUI.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DMUBridge.FlexibleLoad">
            <summary>
            If true, then the bridge will try to find input files even if the name is wrong.
            Presently only used in the MU bridge to change the extension of RR input files
            from .CRF to RR.res1d.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DMUBridge.StopWatch">
            <summary>
            Stop watch, used for detailed timing of the MU loading
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge">
            <summary>
            Common class for loading MIKE 1D setup from various known types of storages.
            <para>
            Currently supporting MIKE 11 (sim11), MIKE URBAN databases (mdb/gdb), MIKE HYDRO (mhydro)
            and MIKE 1D (m1dx).
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.FlexibleLoad">
            <summary>
            If true, then the bridge will try to find input files even if the name is wrong.
            Presently only used in the MU bridge to change the extension of RR input files
            from .CRF to RR.res1d.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.StopWatch">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.DiagnosticsHandler">
            <summary>
            Handler for diagnostics messages
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.AdditionalParameters">
            <summary>
            Additional parameters to use while loading
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.Open(DHI.Mike1D.Generic.IConnection)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.Save(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Save MIKE 1D setup data to file.
            <para>
            Currently supporting MIKE 1D (m1dx).
            </para>
            </summary>
            <param name="mike1DData">MIKE 1D setup to store</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.SetLTSJobListParams(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Set LTS job list parameters, and disable parameters that
            should not be active while creating job list.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DController">
            <summary>
            The Mike1DController is the entry point for an HD simulation, including
            any enabled modules (Rainfall runoff, AD, Control etc.)
            <para>
            It links the simulation setup with the actual engine setup. It controls
            initialization, start, stop and finalization of the engine.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.SimulationType">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.InitTimings">
            <inheritdoc />
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DController._timingsPrep">
            <summary> Timings used during prepare </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DController._timingsRun">
            <summary> Timings used during runtime </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.EngineNetFactory">
            <summary>
            For testing purposes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.CurrentTime">
            <summary>
            Current time of simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DController.MaxNumberOfThreadsUser">
            <summary>
            Maximum number of threads, set by the user.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DController.UseThreadedDomainDecomposition">
            <summary>
            Use Threaded domain decomposition
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.StateWriter">
            <summary>
            State writer, if enabled. Available after <see cref="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Prepare"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.#ctor">
            <summary>
            Default constructor
            <para>
            The logfilewriter will be created based on the input file name, or connection properties,
            when calling the <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)"/> method.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Make a controller that uses the provided <paramref name="diagnosticsHandler"/> for 
            handling diagnostics messages. 
            This is convenient if the <paramref name="diagnosticsHandler"/> is to be resued by more than
            one controller.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.FloodMapFactory">
            <summary>
            For testing purposes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.Load(DHI.Mike1D.Generic.IConnection)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DController"/> and loads the setup.
            The setup is loaded with all default parameters.
            <para>
            In case of errors when loading the setup, a <see cref="T:DHI.Mike1D.Generic.Mike1DException"/>
            is thrown. Errors can be examined by extracting the <see cref="T:DHI.Mike1D.Generic.IDiagnostics"/>
            object stored in <see cref="P:System.Exception.Data"/> using string key "Diagnostics".
            </para>
            </summary>
            <param name="connection">Connection of file to load</param>
            <returns>A new controller, with populated <see cref="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Mike1DData"/></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.Load(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DController"/> and loads the setup.
            The setup is loaded with all default parameters
            </summary>
            <param name="connection">Connection of file to load</param>
            <param name="diagnostics">Diagnostics to put warnings/errors to.</param>
            <returns>A new controller, with populated <see cref="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Mike1DData"/></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Open the file specified by the <paramref name="connection"/>.
            </summary>
            <param name="connection">File to open</param>
            <param name="diagnostics">Diagnostics to handle errors and warnings.</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoInitialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize the engine. Initialize sets up the engine net. When done, the EngineNet
            will be ready to inform on what data is available
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.InitializeStatic(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Initialize static structures (<see cref="T:DHI.Mike1D.Engine.EngineNet"/>)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.InitializeDynamic(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize dynamic structures (all the modules of the EngineNet)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoStopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoPrepare">
            <summary>
            Prepare the engine. This is called just before run is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoPrepareDiagnostics">
            <summary>
            Prepares runtime diagnostics.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoPrepareResultFileFolder">
            <summary>
            Prepares result file folder.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoPrepareBoundaryData">
            <summary>
            Prepares boundary data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoPrepareCatchmentResultFiles">
            <summary>
            Prepares catchment result files.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.ReadStartStates">
            <summary>
            Read the controller start state.
            It is in a method to let the Mike1DControllerEM objects skip this part
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.SetupStateWriting">
            <summary>
            Setup writing of the controller state.
            It is in a method to let the Mike1DControllerEM objects skip this part
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoRun">
            <summary>
            Run the engine to end of simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoRunUntil(System.DateTime)">
            <summary>
            Run the engine to specified end time.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoFinish">
            <summary>
            Finish and clean up
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoValidate">
            <summary>
            Validate that the Controller does not have any errors/warnings
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.WriteState(DHI.Mike1D.ModelState.ModelStateWriter)">
            <summary>
            Writing current state of a MIKE 1D controller to a state file.
            Used when a writer is already defined - could ex. be used to write the DA ensemble member
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.ReadState(DHI.Mike1D.ModelState.ModelStateReader)">
            <summary>
            Reading starting state of a MIKE 1D controller from a state file.
            Used when a reader is already defined - could ex. be used to read the starting state of DA ensemble member
            </summary>
            <param name="reader"></param>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate">
            <summary>
            The Mike1DController is the entry point for automatic RR calibration.
            <para>
            It will loop through all catchments that has auto calibration
            enabled, and calibrate each of these individually.
            When the controller is done, it will update the catchment
            parameters to contain the optimal parameters.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.#ctor">
            <summary>
            Base constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Base constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.Progress">
            <summary>
            Progress object for calibrator
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.SimulationType">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.InitTimings">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoInitialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize the engine. Initialize sets up the engine net. When done, the EngineNet
            will be ready to inform on what data is available
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoStopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoPrepare">
            <summary>
            Prepare the engine. This is called just before run is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoRun">
            <summary>
            Run the engine
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoFinish">
            <summary>
            Finish and clean up
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoValidate">
            <summary>
            Validate that the Controller does not have any errors/warnings
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes">
            <summary>
            Type of result to create default result specifications for. Used in <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.GetDefaultResultSpecification(DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes)"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.HD">
            <summary> HD results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.HDDecoupled">
            <summary> HD decoupled results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.AD">
            <summary> AD component results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.EL">
            <summary> ECO Lab results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RR">
            <summary> Rainfall Runoff results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RRCatchmentDischarge">
            <summary> Catchment discharge results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RRAdditionalNAM">
            <summary> Rainfall Runoff additional results for NAM </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RRAdditionalNAMWithElevationZones">
            <summary> Rainfall Runoff additional results for NAM, including elevation zones </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.UserSpecified">
            <summary> User specified results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RRLID">
            <summary> LID results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.ST">
            <summary> ST results </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ParameterType">
            <summary>
            Type of parameter, for additional data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ParameterType.Option">
            <summary>
            General option. A number of predefined options are supported by the engine.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ParameterType.Property">
            <summary>
            Property is a direct reference to the MIKE 1D object properties.
            All simple properties can be modified using this parameter type
            </summary>
            <example>
            An Id for updating the Delh property will look like: 
            <code>
            HDParameters.SolverSettings.Delh
            </code>
            </example>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter">
            <summary>
            Additional parameter data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.#ctor(System.String)">
            <summary>
            Simple constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.#ctor(System.String,System.String,System.Type,DHI.Mike1D.Mike1DDataAccess.ParameterType)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.Id">
            <summary>
            Id of parameter. For Property, it is the direct reference to the MIKE 1D data object property.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.Description">
            <summary>
            Description
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.ParameterType">
            <summary>
            Type of parameter
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.ValueType">
            <summary>
            Type of value
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.Enabled">
            <summary>
            Flag defining parameter value is enabled.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.Value">
            <summary>
            Value of parameter
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AdditionalParameter.AvailableOptions">
            <summary>
            Available default options
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData">
            <summary>
            Class that collects all DataAccess components in one place.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.#ctor">
            <summary>
            Create a new Mike1DData component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Called when deserialized. 
            </summary>
            <param name="c"></param>
            <remarks>
            The constructor is not called during deserializing, hence
            any constructor code must be executed here.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Construct">
            <summary>
            Constructor code, extracted from constructor to 
            support custom construction when deserializing
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.TsBuffer">
            <summary>
            A buffer containing all timeseries, so they can be reused.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.RuntimeDiagnostics">
            <summary>
            Diagnostics instance for the engine net. Used during runtime.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.CreateRuntimeDiagnostics">
            <summary>
             Create a runtime Diagnostics instance. This is called from Mike1DController.Prepare()
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ControllerCreatedEvent">
            <summary>
            Event that is triggered when a this <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/> is
            being connected to a newly created controller. 
            <para>
            This can be used by components that only have access to data access classes,
            to also get access to the controller and its events. 
            Examples are data bridges and plugins.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Id">
            <summary>
            Id of the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ScenarioId">
            <summary>
            Scenario Id of the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Description">
            <summary>
            Description of the simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseHD">
            <summary>
            Flag specifying whether HD is included.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseRR">
            <summary>
            Flag specifying whether Rainfall Runoff calculation is included.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseRRResults">
            <summary>
            Flag specifying whether rainfall runoff data are 
            extracted from a rainfall runoff result file.
            Can not be used simultaneously with the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseRR"/>, 
            only one of them can be enabled.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseCatchmentDischargeResults">
            <summary>
            Flag specifying whether rainfall runoff catchment discharge data are 
            extracted from a rainfall runoff result file.
            Can not be used simultaneously with the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseRR"/>, 
            only one of them can be enabled.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseAD">
            <summary>
            Flag specifying whether Advection Dispersion/component transport is included.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseST">
            <summary>
            Flag specifying whether Advection Dispersion/component transport is included.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseEL">
            <summary>
            Flag specifying whether EcoLab is included. EcoLab automatically enables AD, <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseAD"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseControlModule">
            <summary>
            Flag specifying whether Control module is included. 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseDA">
            <summary>
            Flag specifying whether DA is included.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseHDLongTermStatistics">
            <summary>
            If this is true, then run HD simulation in Long Term Statistics mode based on the 
            configuration in 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UsePipeDesign">
            <summary>
            Run a pipe design simulation. Pipe design is a MU feature for calibrating reach diameters
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ProjectionString">
            <summary>
            A WKT string defining the spatial reference system. See DHI.Generic.DFSIO.IDFSProjection
            for details.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UnitSystem">
            <summary>
            Unit system used when reporting
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UserUnitProvider">
            <summary>
            Unit provider used when <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UnitSystem"/> is <see cref="F:DHI.Mike1D.Generic.UnitSystem.User"/>
            <para>
            You must also set the <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UnitSystem"/> to <see cref="F:DHI.Mike1D.Generic.UnitSystem.User"/> in order to use
            the specified unit provider.
            </para>
            <para>
            The user unit provider must be set in-process, i.e. it is not stored to MIKE 1D setup file.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Network">
            <summary>
            Network data access. Provides access to input data that defines the network.
            Notice that structure data are accessed through the the network.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.LongTermStatistics">
            <summary>
            Data access for HD long term statistics simulations
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.CrossSections">
            <summary>
            Cross section data access. Provides access to all input data that defines the cross sections.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.HDParameters">
            <summary>
            HD parameter data access. Provides options for the HD part of the engine
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.BoundaryData">
            <summary>
            Boundary data access. Provides access to all input data that specifies the boundary conditions
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.RainfallRunoffData">
            <summary>
            Rainfall Runoff (catchment) data access. Provides access to all input data that specifies rainfall runoff models
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ControlData">
            <summary>
            Control module data access. Provides access to all input data for control
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ADComponentData">
            <summary>
            Advection-dispersion/component transport data access. Defines components that are included in the simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.EcoLabData">
            <summary>
            EcoLab data access component. Defines the connection between the HD and AD module and the EcoLab template
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.STData">
            <summary>
            Sediment Transport data access.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.PipeDesignData">
            <summary>
            Pipe design data. Pipe design is a MU feature for calibrating reach diameters
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.DataAssimilationData">
            <summary>
            Data Assimilation data. Provides access to all input data that specifies Data Assimilation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.SimulationStart">
            <summary>
            Simulation start time
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.SimulationEnd">
            <summary>
            Simulation end time
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.TimeStepping">
            <summary>
            Get/set TimeStepping parameters
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ResultSpecifications">
            <summary>
            Specifications on how to write result files, when, what to include and where.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.StateWriteSpecification">
            <summary>
            Specifications on how to write state files.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.StatestartInfos">
            <summary>
            List of statestart files, prioritized, the first one being
            tried first.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.CrossSectionsFilePath">
            <summary>
            File path to cross section file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.RainfallRunoffResultDataFilePath">
            <summary>
            Path to file containing rainfall runoff results that is to be
            coupled with a HD simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.CatchmentDischargeResultDataFilePath">
            <summary>
            Path to file containing rainfall runoff results that is to be
            coupled with a HD simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ResultBaseFilePath">
            <summary>
            Base path for result files. If a relative path is specified
            for a result file, the path is relative to this path.
            <para>
            If this is not set explicitly, the <see cref="P:DHI.Mike1D.Generic.AbstractDataAccess.Connection"/>
            FilePath is used as base file path. Set to null to delete an explicitly
            defined value.
            </para>
            <para>
            If folder does not exist, but the parent folder exists, the folder will be created
            when the simulation is executed.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.MaxNumberOfErrorLogFileBackups">
            <summary>
            Maximum number of backups of html error log file. Log files are rolled over so that
            older log files are kept. This is the maximum number of old log files that are stored.
            Default value is 3.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.FilePathHtmlErrorLog">
            <summary>
            File path of html error log. Used by SimLauncher.SimulationWorker to create the log.
            <para>
            The log files will not be created when using the <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/> directly.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.FilePathHtmlSummary">
            <summary>
            File path of html summary. Used in SimLauncher.SimulationWorker to create the log.
            <para>
            The log files will not be created when using the <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/> directly.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.PluginInfos">
            <summary>
            List of plugins registered for this setup.
            <para>
            Plugins are handled when the setup has been loaded and a <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/> object is available.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ScriptInfos">
            <summary>
            List of scripts registered for this setup.
            <para>
            Scripts are handled when the setup has been loaded and a <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/> object is available.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.AdditionalData">
            <summary>
            Additional data, a set of key-value pairs, where the key is a string.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.__additionalData">
            <summary>
            Serialization version of the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData._additionalData"/>, to handle the comparer of the dictionary.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.SetAdditionalData(System.String,System.Object)">
            <summary>
            Set additional data
            </summary>
            <remarks>
            If storing/loading setup to/from xml, all additional data objects must include 
            a <see cref="T:System.Runtime.Serialization.DataContractAttribute"/>, otherwise storing/loading will fail.
            </remarks>
            <param name="key">Identifier/key string of network data</param>
            <param name="value">Object containing additional data</param>
            <returns>True if additional data was added, false if not added because data with the existing key already exists.</returns>
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.GetAdditionalData(System.String)">
            <summary>
            Get additional data, based on key.
            </summary>
            <param name="key">Identifier/key string of additional data object</param>
            <returns>Object associated with key. Null if key is not defined</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.GetAdditionalData``1(System.String,``0)">
            <summary>
            Get additional data, based on key. If no data exist for value, return the <paramref name="defaultValue"/>
            </summary>
            <param name="key">Identifier/key string of additional data object</param>
            <param name="defaultValue">Default value, if key not found.</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ContainsAdditionalData(System.String)">
            <summary>
            Returns true if data is associated with the key.
            </summary>
            <param name="key">Identifier/key string of additional data object</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.TryGetAdditionalData(System.String,System.Object@)">
            <summary>
            Get additional data, based on key.
            </summary>
            <param name="key">Identifier/key string of additional data object</param>
            <param name="value">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter.</param>
            <returns>True if value is set for the key. False otherwise</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.GetDefaultResultSpecification(DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes)">
            <summary>
            Creates a default result specification of the type provided.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Validate">
            <summary>
            Validates the contents. Files are validated for existence. Large parts of the validations 
            are delegted to the included data access modules.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.LoadPlugin(DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.Plugins.Mike1DPluginInfo,DHI.Mike1D.Generic.IDiagnostics,DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Static method for explicitly loading of a MIKE 1D plugin.
            </summary>
            <param name="mike1DData">MIKE 1D data object</param>
            <param name="pluginInfo">Info on the plugin to load</param>
            <param name="diagnostics">Diagnostics to report errors to.</param>
            <param name="handler">Handler to write messages to. Can be null</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.LoadPlugin(DHI.Mike1D.Plugins.Mike1DPluginInfo,System.String)">
            <summary>
            Static method for loading a MIKE 1D plugin - creating a new instance of a <see cref="!:Plugins.IMike1DPlugin"/>.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DDataValidator">
            <summary>
            Helper class to do cross-component validation
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataValidator.IsInNetwork(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Returns true if location is part of network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataValidator.ValidateOpenBoundaries(DHI.Mike1D.Generic.IDiagnostics,DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Validate open boundaries, currently only for link-channels
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DDataExtensions">
            <summary>
            Extension methods for the MIKE 1D Data object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataExtensions.UseRRResults(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Bool indicating if RR results are active in the HD simulation.
            <para>
            RR results can contain Runoff or Catchment Discharge results, or both.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataExtensions.UnitProvider(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Get unit provider, matching the <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UnitSystem"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataExtensions.SetMUPRegressionTestCompatabilityMode(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Modifies MUP result specifications to better match the default MU result specifications.
            </summary>
            <param name="mike1DData"></param>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DDataXmlBridge">
            <summary>
            Bridge class for saving MIKE 1D data to XML, handling reading/writing the .m1dx file.
            <para>
            For loading a full setup, use the <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge"/>.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DDataXmlBridge.FilePath">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataXmlBridge.Open(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataXmlBridge.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter">
            <summary>
            Log file writer for MIKE 1D engine. 
            <para>
            Call <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.Prepare"/> to open the logfile. 
            If prepare is not called, all writing to the logfile is ignored silently.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.logfileIndent">
            <summary>
            The indentation matching the date-time output
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.#ctor(System.String)">
            <summary>
            Default constructor, setting the default log file name
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.LogFileOpen">
            <summary>
            Flag indicating if log file is open and can be written to.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.IncludeExceptionStackTrace">
            <summary>
            Flag specifying whether the exception stack trace should be written
            to the log file, in case of an exception. The exception message
            is always written to the log file.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.LogFileName">
            <summary>
            Name and full path of log file. By default the name is the setup
            name where the extension is replaced by ".log". Another name can
            be specified here.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.Prepare">
            <summary>
            Prepare (open) the log file. Returns false if the log file is already open, i.e.
            it can be called multiple times.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.AddLine(DHI.Mike1D.Generic.DiagnosticsHandler.MessageType,System.String)">
            <summary>
            Add a message line to the log file.
            </summary>
            <param name="messageType">Type of message</param>
            <param name="message">Message</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.AddAdditionalLine(System.String)">
            <summary>
            Add an additional line to the log file. This line is related to
            a previous line added by <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.AddLine(DHI.Mike1D.Generic.DiagnosticsHandler.MessageType,System.String)"/>, and
            type of error message and date/time will not be printed.
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.ExceptionToLogFile(System.Exception)">
            <summary>
            Prints exception message and stack to log file, including
            inner exceptions.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.ExceptionToConsole(System.Exception)">
            <summary>
            Helper method that writes exception to console out (for command line output)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.CloseLogFile">
            <summary>
            Close the logfile
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo">
            <summary>
            Helper class for assembly version information
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo.AssemblyName">
            <summary> Name of assembly </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo.MajorVersion">
            <summary> Major version, updated with every major release </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo.FileVersion">
            <summary> File version. Includes updates and build version number </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo.BuildDateTime">
            <summary> Date and time that the assembly was build </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo.GetAssemblyVersionInfo(System.Reflection.Assembly)">
            <summary>
            Create an <see cref="T:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo"/> from an Assembly instance.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo._m1dAssemblyVersionInfos">
            <summary>
            List of all MIKE 1D assemblies
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo.GetFirst">
            <summary>
            Returns the Mike1D assembly with the earliest build date/time
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AssemblyVersionInfo.VersionToConsole">
            <summary>
            Report version to console, but only report once.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory">
            <summary>
            Factory that sets up an <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/>
            to retrieve values from an <see cref="T:DHI.Mike1D.Engine.EngineNet"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.SkipDataItems">
            <summary>
            Flag indicating if to skip creating data items automatically from
            engine. If set, the user must define data items themselves, and
            also assure that data is populated automatically.
            <para>
            Default: false
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.UserDefinedWriting">
            <summary>
            Flag indicating if the user handles flushing to file manually.
            If set, the user must manually write data to file. 
            <para>
            Default: false, meaning that writing to file is handled automatically 
            by the engine.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.#ctor(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Constructor
            </summary>
            <param name="controller"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateResultData(DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create result data object from result specification
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.SetupTimings(DHI.Mike1D.Mike1DDataAccess.IMike1DController,DHI.Mike1D.ResultDataAccess.ResultData,System.Boolean)">
            <summary>
            Setup timings for <paramref name="resultData"/> object,
            to report timings together with the post-time-step event timers.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateResultDataLTS(DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create result data object from result specification for LTS simulation.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.WriteInitialDataToFile">
            <summary>
            Helper class that writes initial data to result file
            at first EngineNet/RR pre-timestep event.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.WriteSteadyIterationsToFile">
            <summary>
            Helper class that writes steady state iterations to result file,
            used when imposing steady state initial conditions
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.SetupNetwork(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Sets up the ResultData based on the static data in the <see cref="T:DHI.Mike1D.Engine.EngineNet"/> and the <see cref="T:DHI.Mike1D.ResultDataAccess.ResultSpecification"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DNetwork(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Create a Res1D network (static data), based on <paramref name="engineNet"/>. 
            Copy over some data from <paramref name="mike1DData"/> to the <paramref name="results"/> object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DNetworkDataItems(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Create data item in <paramref name="results"/> matching the quantities in the <paramref name="resultSpec"/>
            extracting values from the <paramref name="engineNet"/>. The data items are stored in the 
            <paramref name="results"/> object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DDataItem(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider)">
            <summary>
            Create data item in <paramref name="results"/> for the <paramref name="quantity"/>
            extracting values from the <paramref name="module"/>. The data items are stored in the 
            <paramref name="results"/> object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DDataItem(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider,DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter)">
            <summary>
            Create data item in <paramref name="results"/> for the <paramref name="quantity"/>
            extracting values from the <paramref name="module"/>. The data items are stored in the 
            <paramref name="results"/> object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.SetupCatchments(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.RainfallRunoffModule.RainfallRunoffData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Sets up the ResultData for <see cref="T:DHI.Mike1D.RainfallRunoffModule.RainfallRunoffData"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DCatchments(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.RainfallRunoffModule.RainfallRunoffData)">
            <summary>
            Returns: For each res1DCatchment Id, a list of ICatchments that is associated with the res1DCatchment
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateNodeDataItem(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/> for a node if the quantity is offered by the node. 
            If the given quantity is not offered, null is returned.
            </summary>
            <returns>null if quantity is not offered inside reach</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateReachDataItem(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,System.Int32,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider,DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/> for a reach if the quantity is offered as an item global 
            to the reach. If the given quantity is not offered, null is returned.
            </summary>
            <returns>false if quantity is not offered inside reach</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateReachDataItemsFromGridPoints(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,System.Int32,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider,DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/> for all grid points in a reach. If no gridpoints offer 
            the given quantity, null is returned.
            <para>
            The method returns a list of data items, since the same quantity may occur more than
            once on a grid point (e.g. structure discharges if there are paralle structures 
            (more than one structure at the same location)
            </para>
            </summary>
            <returns>null if quantity is not offered inside reach</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DNode(DHI.Mike1D.Engine.EngineNode,System.Int32@)">
            <summary>
            Factory function for creating different types of IRes1DNodes
            depending on the engineNode type
            </summary>
            <returns>IRes1DNode matching engine node type</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateADOutputSpecification(System.String,DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Create an AD output specification that matches the baseSpecss
            </summary>
            <param name="id">ID of result specification</param>
            <param name="adData">AD component specification</param>
            <param name="baseSpecs">Basic result specifications, usually the default HD result specifications</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateADRROutputSpecification(System.String,DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Create an AD-RR output specification that matches the baseSpecss
            </summary>
            <param name="id">ID of result specification</param>
            <param name="adData">AD component specification</param>
            <param name="baseSpecs">Basic result specifications, usually the default HD result specifications</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateSTRROutputSpecification(System.String,DHI.Mike1D.STDataAccess.STData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Create an ST-RR output specification that matches the baseSpecs
            </summary>
            <param name="id">ID of result specification</param>
            <param name="stData">ST data specification</param>
            <param name="baseSpecs">Basic result specifications, usually the default HD result specifications</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateAdditionalOutputSpecification(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Create an additional output specification
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateAdditionalAdOutputSpecification(DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Helper method for model bridges to set up additional AD output specifications
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource">
            <summary>
            A <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> that can update itself based on an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetter"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource._sources">
            <summary>
            Double getter used to access sources
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Sources">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.VectorData">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Quantity">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.DHI#Mike1D#ResultDataAccess#IDataItem#TimeData">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Clear">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.ItemTypeGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.ItemId">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.NumberWithinGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.IndexList">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.CreateTimeSeriesData(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.CreateDataArray">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Update(System.DateTime,System.Int32)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource">
            <summary>
            A <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> that can update itself based on an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetter"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource._source">
            <summary>
            Double getter used to access sources
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Source">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.SourceFrac">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.VectorData">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Quantity">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.TimeData">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Clear">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.ItemTypeGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.ItemId">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.NumberWithinGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.IndexList">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.CreateTimeSeriesData(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.CreateDataArray">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Update(System.DateTime,System.Int32)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource">
            <summary>
            A <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> that can update itself based on an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetter"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource._sources">
            <summary>
            Double getter used to access sources
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource._sourcesFrac">
            <summary>
            Double getter used to access sources
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource._values">
            <summary>
            Values
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource.#ctor(System.Int32)">
            <summary>
            Default constructor
            </summary>
            <param name="size">Size of vector/number of elements in data item</param>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource.Sources">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Plugins.CrfCatchmentConnections">
            <summary>
            Plugin that will delete existing catchment connections and replace 
            by those read from the <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.RainfallRunoffResultDataFilePath"/>,
            in case that is a .crf file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Plugins.CrfCatchmentConnections.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Plugins.CrfCatchmentConnections.Execute(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Run plugin
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ProgressWriter">
            <summary>
            Write progress to standard out
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ProgressWriter.#ctor(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ProgressWriter.UpdateFrequencySeconds">
            <summary>
            Frequency in seconds on how often to update the progress
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DStateReader">
            <summary>
            Class for reading MIKE 1D state file and apply to model.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DStateReader.CustomStateReaders">
            <summary>
            List of custom state readers.
            <para>
            This works in par with the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.CustomStateWriters"/>,
            such that it is possible to write and read custom state into the MIKE 1D state file.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DStateReader.StateTime">
            <summary>
            Timestamp of state
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DStateReader.Diagnostics">
            <summary>
            Diagnostics object for reporting erros and warnings
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter">
            <summary>
            Class for writing current state of a MIKE 1D model to a state file.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.DefaultFileTimeFormat">
            <summary>
            Default formatting of date and time in file name
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.CustomStateWriters">
            <summary>
            List of custom state writers.
            <para>
            This works in par with the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DStateReader.CustomStateReaders"/>,
            such that it is possible to write and read custom state into the MIKE 1D state file.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.#ctor(DHI.Mike1D.Mike1DDataAccess.IMike1DController,DHI.Mike1D.Generic.IFilePath)">
            <summary>
            Create state writer class
            </summary>
            <param name="controller">MIKE 1D Controller</param>
            <param name="templateFilePath">Template file path.
              If containing a placeholder like <code>MyStateFileName_{0}.sta1d</code>,
              it will be replaced with the time of the state
            </param>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.FileTimeFormat">
            <summary>
            Format of time string in file name. Must not include characters that are not valid
            for a file-name, especially colon, i.e. "HH:mm:ss" is not allowed.
            <para>
            Default is "yyyyMMddTHHmmss" (ISO 8601 basic format)
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.StateTime">
            <summary>
            Last time the state was written.
            This may be differ from time series
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.Prepare(System.DateTime)">
            <summary>
            Preparing state writing
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.PostTimeStep(System.DateTime)">
            <summary>
            This methods checks if it is now the time to write state,
            and if so, writes it
            </summary>
            <param name="time">Time of simulation</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DStateWriter.WriteState(System.DateTime)">
            <summary>
            Write state to state file
            </summary>
            <param name="stateTime">Time of state/simulation</param>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification">
            <summary>
            Specification for when and how to write state outputs.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification.TemplateFilePath">
            <summary>
            Template file path, used when creating state file names.
            <para>
            Typically it should have the form
            <code>
              TemplateFilePath.Path = "myFolder\MyStateFileName_{0}.sta1d"
            </code>
            where the placeholder is replaced with the simulation date and time for that state.
            </para>
            <para>
            If the <see cref="P:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification.TemplateFilePath"/> does not contain any placeholder, one is inserted automatically
            as the last part of the filename.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification.StartTime">
            <summary>
             Start Time, first time of state output
             <para>
             Set to <see cref="F:System.DateTime.MinValue"/> to use start-of-simulation time.
             </para>
             <para>
             To store one state at a specific time, set the <see cref="P:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification.StartTime"/> to the
             time to store the state, and leave <see cref="P:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification.TimeStep"/> to zero.
             </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification.EndTime">
            <summary>
             End Time, state will not be outputted after this time
             <para>
             Set to <see cref="F:System.DateTime.MaxValue"/> to write for the entire simulation period.
             </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.StateWriteSpecification.TimeStep">
            <summary>
            Timespan between writing of states.
            <para>
            Set to zero to disable writing of state on a regular basis.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.AddToOutput">
            <summary>
            Plugin for adding quantities to output file.
            <para>
            Two arguments are required:
            <list type="bullet">
            <item><description>ResultId: Id of result output. Values are like: 'DefaultHDResults', 'DefaultRRResults' etc. There can only be one ResultId argument.</description></item>
            <item><description>Quantity: Id of quantity to add to output. Values are names of the <see cref="T:DHI.Mike1D.Generic.PredefinedQuantity"/>, like: 'WaterLevel' etc. There can be more than one Quantity argument</description></item>
            <item><description>UserQuantity: Id of EUM item and ID of quantity to add to output, seperated by '::', example 'eumIInfiltration::WettingLoss [ImperviousSteep]'. There can be more than one UserQuantity argument</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.ControlVariableExpression">
            <summary>
            Plugin class for adding variable expressions to the control module
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.ControlVariableExpression.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Plugins.CulvertIterations">
            <summary>
            Print out culvert iterations to console or file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.CulvertIterations.WriteTimestep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.CompositeStructureIterations">
            <summary>
            Print out composite structure iterations to console or file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.CompositeStructureIterations.WriteTimestep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.PostTimestepReport">
            <summary>
            Abstract class for producing a report at end of time step.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._fileName">
            <summary>
            Filename to write to. If null or empty, writes to console.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._saveStep">
            <summary>
            When negative, only reports at end-of-simulation.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._controller">
            <summary> Controller </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._writer">
            <summary> File to write to </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._countStep">
            <summary> How often to write </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.OnControllerCreatedEvent(System.Object,DHI.Mike1D.Mike1DDataAccess.ControllerCreatedEventArgs)">
            <summary>
            When controller is created, register for controller events
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.OnControllerEvent(System.Object,DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs)">
            <summary>
            Handle controller event
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.OnPostTimestepEvent(System.DateTime)">
            <summary>
            Handle post-time step event
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.WriteTimestep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.DecoupledOutput">
            <summary>
            Plugin for setting up decoupled output.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.DecoupledOutput.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.EcoLabDebugger">
            <summary>
            Plugin that enables debug output from ECO Lab.
            <para>
            The following parameters must be set:
            <list type="bullet">
            <item><description>FilePath: Path to file to write debug info to</description></item>
            <item><description>DebugLevel: ECO Lab debug level</description></item>
            <item><description>StartDateTime: Simulation time of start of debugging, format: yyyy-MM-dd HH:mm:ss</description></item>
            <item><description>EndDateTime: Simulation time of start of debugging, format: yyyy-MM-dd HH:mm:ss</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.EcoLabDebugger.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.EcoLabNumberChecker">
            <summary>
            Plugin that checks output from ECO Lab, and will throw an exception on first occurance
            of a NaN of inf number.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.EcoLabNumberChecker.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.GatelevelHotstart">
             <summary>
             Plugin for using gate level from hotstart file
             <para>
             The plugin takes the following parameters:
             <code>
                Filepath = ''
                Gate = '&lt;&lt;'
             </code>
             </para>
             </summary>
             <example>
             Plugin is loaded through a .m1da file, (for version 2017) as:
             <code>
                  [Plugin]
                     AssemblyName = 'DHI.Mike1D.Mike1DDataAccess, Version=17.0.0.0, Culture=neutral, PublicKeyToken=c513450b5d0bf0bf'
                     ClassName = 'DHI.Mike1D.Plugins.GatelevelHotstart'
                     [Arguments]
                        Filepath = 'output.ADDOUT.res1d'
                        Gate = 'Gate1_ID;Gate2_ID' or 'LoadAllGates' if all gates should be loaded
            
                     EndSect  // Arguments
            
                  EndSect  // Plugin
             </code>
             </example>
        </member>
        <member name="T:DHI.Mike1D.Plugins.IMike1DPlugin">
            <summary>
            Interface for a MIKE 1D Plugin.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.IMike1DPlugin.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Initialize plugin, providing arguments from setup, see <see cref="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.Arguments"/>
            <para>
            It is at this point possible to modify the MIKE 1D setup.
            </para>
            <para>
            It is also possible to register for the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ControllerCreatedEvent"/>
            which will give access to the controller at time of creation, usually when starting up the
            simulation. 
            From the controller you can register for various events using the 
            <see cref="E:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ControllerEvent"/>.
            </para>
            </summary>
            <param name="arguments">Arguments stored in setup</param>
            <param name="mike1DData"><see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/>Object with entire MIKE 1D setup</param>
        </member>
        <member name="T:DHI.Mike1D.Plugins.InitialWaterLevel">
             <summary>
             Plugin for adding parameter initial water level conditions
             <para>
             The plugin takes the following parameters:
             <code>
                Node = '&lt;nodeId&gt;;&lt;wl&gt;'
                Location = '&lt;reachId&gt;;&lt;chainage&gt;;&lt;wl&gt;'
                Span = '&lt;reachId&gt;;&lt;startChainage&gt;;&lt;endChainage&gt;;&lt;wl&gt;'
             </code>
             </para>
             </summary>
             <example>
             Plugin is loaded through a .m1da file, (for version 2018) as:
             <code>
                  [Plugin]
                     AssemblyName = 'DHI.Mike1D.Mike1DDataAccess'
                     ClassName = 'DHI.Mike1D.Plugins.InitialWaterLevel'
                     [Arguments]
                        Node = '90;196.3'
                        Node = '91;0.4;depth'
                        Location = '90l1;57.2876;196.4'
                        Span = '90l1;50;120;196.4'
            
                     EndSect  // Arguments
            
                  EndSect  // Plugin
             </code>
             </example>
        </member>
        <member name="T:DHI.Mike1D.Plugins.Mike1DPluginInfo">
            <summary>
            Information on how to load a MIKE 1D plugin.
            <para>
            A Mike 1D plugin is a class implementing the <see cref="T:DHI.Mike1D.Plugins.IMike1DPlugin"/>.
            To utilize such a class, the name of the class and the name of the assembly
            containing the class must be provided. Also a number of arguments to the
            assembly can be defined.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.AssemblyName">
            <summary>
            Name of assembly that contains the plugin.
            <para>
            The name must contain the full path to the assembly file on the disc.
            It can also contain the fully qualified/long name of the assembly to load from the GAC (including Version, Culture and PublicKeyToken).
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.ClassName">
            <summary>
            Name of class that implements the <see cref="T:DHI.Mike1D.Plugins.IMike1DPlugin"/> interface.
            <para>
            Class name must include name space, i.e. on the form
            <code>
            MyNameSpace.MySubNameSpace.MyPluginClass
            </code>
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.Arguments">
            <summary>
            Plugin arguments, used when initialising the plugin, see <see cref="M:DHI.Mike1D.Plugins.IMike1DPlugin.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.Mike1DPluginArgument">
            <summary>
            Argument for a plugin, in the form of a key and a value
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.Mike1DPluginArgument.Key">
            <summary>
            Key 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.Mike1DPluginArgument.Value">
            <summary>
            Value
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.PluginWriteSteadyIterationsToFile">
            <summary>
            Plugin that enables writing of steady iterations to default HD result file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PluginWriteSteadyIterationsToFile.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.RemoveLID">
            <summary>
            Plugin for removing some or all LID's from a setup
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.RemoveLID.RemoveAll">
            <summary>
            Remove all LID's
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.RemoveLID.Lidids">
            <summary>
            Remove LIDs with ID
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.RemoveLID.Catchids">
            <summary>
            Remove all LIDs from catchments
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.RemoveLID.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Initialize plugin, providing arguments from setup, see <see cref="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.Arguments"/>
            <para>
            Arguments can be:
            <code>
               all = 'true'
               lidid = 'someLIDID'
               catchmentid = 'someCatchmentID'
            </code>
            If specifying <code>all = true</code>, all LIDs are removed. If specifying a catchment ID, then all LIDs
            from that catchment is removed. If specifying a LID ID, only that single lid is removed.
            </para>
            <para>
            It is possible to specify more LID ID's and Catchment ID's
            </para>
            </summary>
            <param name="arguments">Arguments stored in setup</param>
        </member>
        <member name="M:DHI.Mike1D.Plugins.RemoveLID.Execute(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Execute plugin and remove lids from <paramref name="mike1DData"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.ScriptAttribute">
            <summary>
            Script attribute, to decorate methods as script methods to run
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.ScriptAttribute.Order">
            <summary>
            Order of script. Script methods with an order of zero (default) is executed last.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.ScriptLoader">
            <summary>
            Class for loading, compiling and executing MIKE 1D scripts
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.ScriptLoader.AdditionalDependencies">
            <summary>
            Additional dependencies, seperated by ; (semi-colon)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.ScriptLoader.SetCustomScriptParameters(System.String)">
            <summary>
            Script parameters on the form:
            <code>
            scriptParameters = "par1=value1;par2=value2;"
            </code>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.UHMRescaleTimestep">
            <summary>
            Plugin for rescaling the timestep for UHM catchments such that the number of computational 
            cells do not get too big.
            <para>
            One argument can be provided
            <list type="bullet">
            <item><description>MaxNumberOfCells: Integer number.</description></item>
            </list>
            </para>
            </summary>
        </member>
    </members>
</doc>
