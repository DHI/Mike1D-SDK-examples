<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DHI.Mike1D.Mike1DDataAccess</name>
    </assembly>
    <members>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController">
            <summary>
            An abstract base controller class.
            <para>
            It handles everything related to the <see cref="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerEvent"/>
            an delegates the real work on to the derived classes in 
            the DoXXX methods.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController">
            <summary>
            The <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/> is the starting point for 
            controlling and running a simulation. Depending on the underlying
            data components, the controller may do different things. Different
            data controllers may also do different things on the same data
            components. The following are examples of controllers:
            <list type="bullet">
            <item>HD controller: runs an HD simulation, including add ons (rainfall runoff, AD etc.)</item>
            <item>RR controller: runs an RR simulation.</item>
            <item>RR calibration controller: runs an RR calibration.</item>
            <item>LTS controller: runs a LTS (Long Term Statistics) HD simulation.</item>
            </list>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Validate">
            <summary>
            Validate that the Controller/data access modules does not have any errors/warnings.
            Can be called before <see cref="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Initialize(DHI.Mike1D.Generic.IDiagnostics)"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Initialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize the engine. Initialize sets up the engine net. When done, the EngineNet
            will be ready to inform on what data is available
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Prepare">
            <summary>
            Prepare the engine. This is called just before run is called. I will 
            set the initial state (initial conditions), open output files etc.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Run">
            <summary>
            Run the engine
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.RunUntil(System.DateTime)">
            <summary>
            Run the engine until endTime.
            <para>
            endTime should not exceed the simulation end time.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.StopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Finish">
            <summary>
            Finish and clean up.
            </summary>
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ControllerEvent">
            <summary>
            Event that is raised while the controller is running.
            It is raised whenever the <see cref="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.State"/> of the controller changes.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.SimulationType">
            <summary>
            String to indicate the type of simulation being run. Used for user output only.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Mike1DData">
            <summary>
            The Mike1DData that defines the simulation setup
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.EngineNet">
            <summary>
            The enginenet used for the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ResultDataList">
            <summary>
            List of all result data components associated with 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.RuntimeDiagnostics">
            <summary>
            Diagnostics that are used during the simulation (prepare, run)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Timings">
            <summary>
            Detailed timings of the different parts of the simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.State">
            <summary>
            Current state of the controller
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ProgressState">
            <summary>
            Progress state of the controller, specifying how far the controller has progressed. One of 
            <see cref="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Initialized"/>,<see cref="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Prepared"/>,<see cref="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Running"/>.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._timings">
            <summary> Timings used in controller </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._runtimeDiagnostics">
            <summary> Diagnostics object used during runtime </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._mike1DData">
            <summary> MIKE 1D data object </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._state">
            <summary>  Current state of controller  </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._engineNet">
            <summary> EngineNet </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._engineNetGlobal">
            <summary> Global (entire) EngineNet. Used when decomposing setup into several domains, where this contains the full EngineNet </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._resultDataList">
            <summary> Active result data objects </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._suppressUnknownExceptions">
            <summary> Flag indicating whether to suppress unknown exception. </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._controllerProgress">
            <summary> State variable defining how far the controller has got </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController._isFailed">
            <summary> True if controller at some point failed </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Constructor, providing a diagnostics handler.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.InvokeControllerProgressEvent(System.Double)">
            <summary>
            Call to invoke a progress event
            </summary>
            <param name="progress"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ChangeControllerState(DHI.Mike1D.Mike1DDataAccess.ControllerState)">
            <summary>
            Change the state of the controller. Also triggers the <see cref="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerEvent"/>
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RaiseControllerFailedEvent(System.Exception)">
            <summary>
            Put controller in a failed state, and issue a failed event on <see cref="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerEvent"/>
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Validate">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Initialize(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Prepare">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RunManual">
            <summary>
            Must be called when running the engine manually, timestep by timestep, i.e. when not using the
            <see cref="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Run"/> or <see cref="M:DHI.Mike1D.Mike1DDataAccess.IMike1DController.RunUntil(System.DateTime)"/> methods.
            <para>
            This is required for correctly transferring the engine to the run state before taking the 
            time step.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RunStart">
            <summary>
            To be called before running, setting proper state of controller before running.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Run">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RunUntil(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.StopSimulation">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Finish">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.IsInActiveState">
            <summary>
            Returns true if the controller is in an active
            state and currently executing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.InitTimings">
            <summary> Initiate timings </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoValidate">
            <summary> Do Validate. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoInitialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary> Do Initialize. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoPrepare">
            <summary> Do Prepare. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoRun">
            <summary> Do Run. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoRunUntil(System.DateTime)">
            <summary> Do RunUntil. Virtual method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoStopSimulation">
            <summary> Do Stop simulation. Abstract method that must be overridden </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DoFinish">
            <summary> Do finish simulation. Abstract method that must be overridden </summary>
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerEvent">
            <inheritdoc />
        </member>
        <member name="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerProgressEvent">
            <summary> Controller progress event, triggered whenever the controller has progressed, though no more often than <see cref="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.MinSecondsBetweenProgressEvent"/> </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.State">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ProgressState">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.IsFailed">
            <summary> Bool indicating that the controller is in a failed state </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.SimulationType">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.EngineNet">
            <summary>
            The enginenet used for the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ResultDataList">
            <summary>
            List of all result data components associated with 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Timings">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.RuntimeDiagnostics">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.Mike1DData">
            <summary>
            The Mike1DData that defines the simulation setup
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.MinSecondsBetweenProgressEvent">
            <summary>
            Minimum number of seconds between the <see cref="E:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.ControllerProgressEvent"/> is triggered.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.DiagnosticsHandler">
            <summary>
            Handler, taking care of diagnostics messages.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.AbstractMike1DController.CurrentTime">
            <summary>
            Current time of simulation
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControlDataXmlBridge">
            <summary>
            Bridge for reading/writing control data to xml.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControlDataXmlBridge.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControlDataXmlBridge.FilePath">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DPlugin">
            <summary>
            Interface for a MIKE 1D Plugin.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DPlugin.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument})">
            <summary>
            Initialize plugin, providing arguments from setup, see <see cref="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.Arguments"/>
            </summary>
            <param name="arguments">Arguments stored in setup</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DPlugin.OnSetupLoaded(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Method that is called when a setup has been loaded.
            <para>
            It is at this point possible to modify the MIKE 1D setup.
            </para>
            <para>
            It is also possible to register for the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ControllerCreatedEvent"/>
            which will give access to the controller at time of creation, usually when starting up the
            simulation. 
            From the controller you can register for various events using the 
            <see cref="E:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ControllerEvent"/>.
            </para>
            </summary>
            <param name="mike1DData"><see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/>Object with entire MIKE 1D setup</param>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsDataXmlBridge">
            <summary>
            Bridge class for reading lont term statistics data to/from xml
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsDataXmlBridge.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsDataXmlBridge.FilePath">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationType">
            <summary>
            The type of optmization to perform
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationType.FixedInvertLevel">
            <summary>
            Keep invert levels of all pipes fixed and adjust only pipe diameter
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationType.FixedTopLevel">
            <summary>
            Keep the top level of all pipes fixed, which means that both 
            pipe diameter and pipe invert level are adjusted.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationCriteriaType">
            <summary>
            Pipe design criteria type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationCriteriaType.CriticalLevels">
            <summary> Critical Levels </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationCriteriaType.FillingDegree">
            <summary> Filling degree </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationGroupType">
            <summary>
            Pipe design reach group type
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationGroupType.Grouped">
            <summary>
            All reaches in a group are changed together by the same percentage.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationGroupType.Automatic">
            <summary>
            The reaches in this group are optimized individually with respect to the geometric 
            upstream node. Reaches connected to the same node are grouped together
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignIOUnits">
            <summary>
            Units of pipe design in/output
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignIOUnits.SI">
            <summary>
            Use SI units (meter) for reading and writing results
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignIOUnits.US">
            <summary>
            Use US units (feet) for reading and writing results
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData">
            <summary>
            Data class for pipe design data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.Prepare(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create controls necessary to modify pipe Manning numbers and set pipe diameters from 
            pipe design restul file
            </summary>
            <param name="engineNet"></param>
            <param name="controlData"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ConvertMeterToFeetConditionally(System.Double)">
            <summary>
            Conversion from meters to feet, if <see cref="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.InputOutputUnits"/> is <see cref="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignIOUnits.US"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ConvertFeetToMeterConditionally(System.Double)">
            <summary>
            Convert length to SI units if necessary
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.Validate">
            <summary>
            Check PipeDesignData for errors and inconsistencies
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ActiveReaches">
            <summary>
            Return a list of active HDPipeDesignOptimizationReach'es.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.SetDiametersFromResults(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Set new pipe diameters from the results of a previous Pipe Design simulation
            This is called at the beginning of a PD simulation.
            </summary>
            <param name="network"> </param>
            <param name="crossSections"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.Initialize(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.CopyCalculatedNetworkDiametersIntoResults(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Compute new pipe diameters from the Manning numbers found in a PD simulation.
            </summary>
            <param name="network"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.DeletePreviousResults">
            <summary>
            Delete result file (if possible) and delete all previously calculated diameters.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.FindEngineReachFromId(System.String,System.Collections.Generic.IEnumerable{DHI.Mike1D.Engine.EngineReach})">
            <summary>
            Find the EngineReach that has reachId == EngineReach.LocationSpan.ID. If multiple reaches exist that
            have the same ID in locations, then an exception is generated. Use this function from Prepare if the 
            </summary>
            <param name="reachId"></param>
            <param name="reaches"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.FindPipeDesignReachFromId(System.String)">
            <summary>
            Loop through all reaches that are part of Pipe Design and return the one with the
            specified id. 
            </summary>
            <param name="reachId"></param>
            <returns>A HDPipeDesignOptimizationReach or null if the reach was not found</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ReadResultFile(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read result file into active flag, init factor and previous results for each reach
            </summary>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.WriteResultFile">
            <summary>
            Write a Pipe Design result file. The result file is a PFS file that contains
            the pipe diameters from a Pipe Design simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.WriteMEXFile(System.String)">
            <summary>
            Write mex file, matching that of MOUSE
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.FindPipeDesignItemFromId(System.String)">
            <summary>
            Find a Pipe Design item from an id. This is used from the control module
            when all the reaches in an item are controlled as a group (then the
            control module operates on the item instead of on the individual reaches)
            </summary>
            <param name="itemId"></param>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.CommercialPipeDiameters">
            <summary>
            List of commercial pipe diameters. These are used for suggesting new pipe diameters after a 
            simulation done. The smallest diameter larger than the computed diameter is used as suggestion.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.ResultFile">
            <summary>
            File path of the Pipe Design result file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.DesignOptimizationItems">
            <summary>
            A list of items in the Pipe Design simulation. Each item contains a list of reaches
            that will be modified.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDWeightTimeStep3">
            <summary>
            PID weight of time step n-2 to use when modifying the Manning number of reaches.
            Default value 1.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDWeightTimeStep2">
            <summary>
            PID weight of time step n-1 to use when modifying the Manning number of reaches.
            Default value 1.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDWeightTimeStep1">
            <summary>
            PID weight of time step n to use when modifying the Manning number of reaches.
            Default value 1.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDDerivationPeriod">
            <summary>
            PID derivation period in seconds. Default value 0.8 seconds.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDIntegrationPeriod">
            <summary>
            PID integration period in seconds. Default value 300 seconds.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.PIDProportionalityFactor">
            <summary>
            PID proportionality factors. Default value -1
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.InputOutputUnits">
            <summary>
            Unit of input and output files
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignData.MEXFile">
            <summary>
            Name and path of mex file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem">
            <summary>
            Contains item to optimize
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.AddReach(System.String)">
            <summary>
            Add reach to list of reaches that should be optimized.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.Control(System.Double,System.Int32)">
            <summary>
            Setter for controllable entity. Used by the control module.
            Can safely be called multiple times with the same timeN.
            </summary>
            <param name="newValue"></param>
            <param name="controlStrategyId"> </param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.Validate">
            <summary>
            Validate
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.GetDesignFactor">
            <summary>
            Get design factor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.NodeId">
            <summary>
            Name of the upstream node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.LowerWaterLevelLimit">
            <summary>
            The manning number will not be adjusted if the water level 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.FillingDegree">
            <summary>
            Largest degree of filling for reaches
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.Type">
            <summary>
            Specifies what can be optimized
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.GroupType">
            <summary>
            How to optimize, in groups or individually
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.CriteriaType">
            <summary>
            Criteria for optimization
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationItem.Reaches">
            <summary>
            Reaches to optimize
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach">
            <summary>
            Pipe design reach. The Control() method sets the Manning number of the _first_ XS in the
            underlying EngineReach. In MU setups, the cross section is shared between all points in the
            underlying reach, so in MU setups the Manning number of the whole reach 
            will be controlled.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach._xsCircular">
            <summary>
            This is a pointer into the Engine to the XSCircularPreprocessed that is being modified.
            The reference is set in Prepare()
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Prepare(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Prepare the Pipe Design reach. 
            </summary>
            <param name="network"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.GetAverageManning">
            <summary>
            Calculate a single Manning number, even if the Manning number is exponential.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.GetAverageOriginalManning">
            <summary>
            Calculate a single Manning number, even if the Manning number is exponential.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.GetEngineReach">
            <summary>
            Find the IReach that has _reachId == EngineReach.LocationSpan.ID. If multiple reaches exist that
            have the same ID in locations, the first reach is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach._controlStategyId">
            <summary>
            If the item is being controlled, then _controlStategyId contains the ID of the
            active control strategy
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Control(System.Double,System.Int32)">
            <summary>
            Setter for controllable entity. Used by the control module.
            Can safely be called multiple times with the same timeN.
            </summary>
            <param name="newValue"></param>
            <param name="controlStrategy"> </param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.ResetControlledState">
            <summary>
            Reset controlled state to initial values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.CalculateNewReachDiametersAndCopyToResults(DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Calculate new reach diameter from the Manning number of the cross section in the first 
            (upstream) grid point, and save this diameter to the results list.
            </summary>
            <param name="network"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.DeltaDiameter">
            <summary>
            Return the change in diameter from the original diameter to the newest available result
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.SetDiameterFromResults(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.CrossSectionModule.CrossSectionData,System.Boolean,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Set reach diameter from results. This is called in Initialize() which is called so before Prepare(), therefore 
            we cannot use _xsCircular.
            </summary>
            <param name="network"> </param>
            <param name="crossSections"></param>
            <param name="fixedReachTopLevel"> </param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Validate">
            <summary>
            Validate reach data
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.SaveOriginalDiameter(DHI.Mike1D.NetworkDataAccess.Network,DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Save original diameters, to be used when rerunning the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.ReachId">
            <summary>
            ID of the underlying EngineReach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.UpstreamNodeId">
            <summary>
            ID of the upstream node
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Active">
            <summary>
            If true, then the reach will control the underlying reach's Manning number.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.InitialDesignFactor">
            <summary>
            The control of Manning number is indirect in that the control acts on a factor that is
            multiplied onto the Manning number (the actual Manning number is the original Manning nubmer
            times this factor). InitialDesignFactor controls the value of the factor at the beginning
            of the simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.OriginalDiameter">
            <summary>
            Original diameter of the reach (really of the first (upstream) cross section)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Results">
            <summary>
            List of results from previous simulations
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.DesignFactor">
            <summary>
            Current value of the design factor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.MaxManning">
            <summary>
            Maximum value of the manning number
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.MinManning">
            <summary>
            Minimum value of the manning number
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.HDPipeDesignOptimizationReach.Diameter">
            <summary>
            The current diameter of the underlying circular reach (the diameter of the cross
            section in the first h-grid point).
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSEventList">
            <summary>
            List of LTS events. An event is a set of values with a time stamp. This class is abstract, and
            the calculation of the values in the events is performed in the purely abstract function Update().
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSEventList._events">
            <summary> List of LTS events </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSEventList._zeroFlow">
            <summary> Zero flow tolerance </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Constructor
            </summary>
            <param name="maxNumberOfResults"></param>
            <param name="minimumTimeBetweenValues"> </param>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSEventList._getter">
            <summary>
            The current value to use when calculating the maximum
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.PrepareForNextLTSJob">
            <summary>
            Resets the state of the eventlist in preparation for another simulation in the LTS sequence.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.Update(System.DateTime)">
            <summary>
            Update calculates the values in the events.
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.CommitLastValueInJob">
            <summary>
            Commit the last value in the LTS job (and LTS simulation consists of multiple jobs) 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.CommitLastValueInSimulation">
            <summary>
            Commit the last value in the LTS simulation (and LTS simulation consists of multiple jobs) 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSEventList._minimumTimeBetweenValues">
            <summary>
            Two events in the event list should be separated by at least this TimeSpan. If they are closer
            together then they are considered part of the same event.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.Add(System.DateTime,System.Double)">
            <summary>
            Add an event with a single value to the list
            </summary>
            <param name="time"></param>
            <param name="value"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.Add(System.DateTime,System.Double,System.Double)">
            <summary>
            Add an event with two values to the list
            </summary>
            <param name="time"></param>
            <param name="value1"></param>
            <param name="value2"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.Add(System.DateTime,System.Double,System.Double,System.Double)">
            <summary>
            Add an event with three values to the list
            </summary>
            <param name="time"></param>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.WriteToPFSFile(DHI.PFS.PFSBuilder,DHI.Mike1D.Mike1DDataAccess.EventListSortType,System.String)">
            <summary>
            Write this event list to a PFS file (MU ERF format)
            </summary>
            <param name="pfsFile"></param>
            <param name="sortType"> </param>
            <param name="label"> </param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.SortOnTime">
            <summary>
            Sort the event list on time stamps
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventList.SortOnValue1">
            <summary>
            Sort the event list on the first value of each event
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSEventList.Getter">
            <summary>
            The current value to use when calculating the maximum
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSEventList.MaxNumberOfResults">
            <summary>
            The maximum number of result that will be written to the result file.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSEventList.MinimumTimeBetweenValues">
            <summary>
            Two events in the event list should be separated by at least this TimeSpan. If they are closer
            together then they are considered part of the same event.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSEventList.Event">
            <summary>
            An LTS event start time and values
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSEventList.Event.Time">
            <summary> Time </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSEventList.Event.Values">
            <summary> Values </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSEventListMax">
            <summary>
            An event list that calculates the maximum value. The value is taken from the DDoubleGetter in Getter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListMax.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListMax.Update(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListMax.CommitLastValueInJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListMax.PrepareForNextLTSJob">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSEventListIntegrated">
            <summary>
            An event list that calculates the total integrated value over time. The value is taken from the DDoubleGetter in Getter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListIntegrated.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListIntegrated.Update(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListIntegrated.CommitLastValueInJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListIntegrated.PrepareForNextLTSJob">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSEventListAnnualIntegrated">
            <summary>
            An event list that calculates the total integrated value over time. The value is taken from the DDoubleGetter in Getter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListAnnualIntegrated.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListAnnualIntegrated.Update(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListAnnualIntegrated.PrepareForNextLTSJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListAnnualIntegrated.CommitLastValueInSimulation">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListAnnualIntegrated.WriteToPFSFile(DHI.PFS.PFSBuilder,DHI.Mike1D.Mike1DDataAccess.EventListSortType,System.String)">
            <summary>
            Write this event list to a PFS file (MU ERF format)
            </summary>
            <param name="pfsFile"></param>
            <param name="sortType"> </param>
            <param name="label"> </param>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut">
            <summary>
            An event list that calculates the total integrated value over time. The value is taken from the DDoubleGetter in Getter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.Update(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.PrepareForNextLTSJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.CommitLastValueInSimulation">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.WriteToPFSFile(DHI.PFS.PFSBuilder,DHI.Mike1D.Mike1DDataAccess.EventListSortType,System.String)">
            <summary>
            Write this event list to a PFS file (MU ERF format)
            </summary>
            <param name="pfsFile"></param>
            <param name="sortType"> </param>
            <param name="label"> </param>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.OutletGetters">
            <summary>
            Getters for outlet discharges
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.PumpGetters">
            <summary>
            Getters for external pump discharges
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.WeirGetters">
            <summary>
            Getters for external weir discharges
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSEventListTotalIntegratedDischargeOut.MonthlyDischarge">
            <summary>
            If true, the integrated discharges are collected over a period of one month.
            If false, the period is one year.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSEventListDuration">
            <summary>
            An event list that calculates the total integrated value over time. The value is taken from the DDoubleGetter in Getter.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListDuration.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListDuration.Update(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListDuration.CommitLastValueInJob">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSEventListDuration.PrepareForNextLTSJob">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSJob">
            <summary>
            A SimulationEvent describes one of a series of simulations that are performed during the
            total runtime of the Long Term Simulation. A SimulationEvent is the same as am LTS "job" in MU terms.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.StartTime">
            <summary>
            Start time of LTS Job
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.EndTime">
            <summary>
            End time of LTS Job
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.ActualStartTime">
            <summary>
            Time at which the job started in the simulation. Can be different from StartTime since the
            previous job can extend into this job.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.ActualEndTime">
            <summary>
            Time at which the job ended in the simulation. Can be different from EndTime since the
            the job runs until the stop conditions are fulfilled.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.JobStartCriterionId">
            <summary>
            Id of Job-start criteria
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.DtMin">
            <summary>
            Minimum Dt in job
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.DtMax">
            <summary>
            Maximum Dt in Job
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.HotStartDate">
            <summary>
            Time to extract hotstart from
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.UseHotStartFile">
            <summary>
            Flag indicating if to use hot start file
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSJob.HotStartFile">
            <summary>
            Name and path of hot start file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobList.ReadFromFile(DHI.Mike1D.Generic.IFilePath,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read job list file (PFS file with .MJL extension)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSJobList.WriteToFile(DHI.Mike1D.Generic.IFilePath)">
            <summary>
            Write job list file (PFS file with .MJL extension)
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.EventListSortType">
            <summary>
            LTS sort type, when writing results to PFS file, whether to sort on time or on value.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.EventListSortType.Time">
            <summary> Sort on time </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.EventListSortType.Value">
            <summary> Sort on value </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSResultSpecification">
            <summary>
            Result specification of LTS results
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSResultSpecification.ResultSpecificationItems">
            <summary>
            List of result specifications
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSResultType">
            <summary>
            Type of LTS results
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSResults">
            <summary>
            Holds results of an LTS calculation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSResults.#ctor(DHI.Mike1D.Engine.EngineNet,System.DateTime,System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="engineNet"></param>
            <param name="simulationStart"> </param>
            <param name="simulationEnd"> </param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSResults.GetLinkType(DHI.Mike1D.Engine.GridPoint)">
            <summary>
            Return the "link type" to be used in the result output file.
            </summary>
            <param name="gridPoint"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.LTSResults.WriteResultFile(DHI.Mike1D.Generic.IFilePath)">
            <summary>
            Write results to PFS file 
            </summary>
            <param name="resultFilePath"></param>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge">
            <summary>
            Bridge for reading the .m1da file, Mike 1D Additional setup file.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DBridge">
            <summary>
            Bridge interface, for loading a MIKE 1D setup from storage.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DBridge.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Open MIKE 1D data from <paramref name="connection"/> specifications
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.#ctor(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.Open(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.Read(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read the sim11 file into the _mike1dDataAccess.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.Save">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.PluginInfos">
            <summary>
            List of plugins loaded from .m1da file.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DAdditionalBridge.FilePath">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory">
            <summary>
            Factory class for creating <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/>.
            <para>
            The controller can either be created based on the content of <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/>,
            or from a <see cref="T:DHI.Mike1D.Generic.IConnection"/>, in which case the data will also be loaded.
            </para>
            <para>
            The factory handles log files. By default a new log is created every time a new controller is created,
            and the log file is closed when the controller finishes.
            You can disable log files by setting <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DisableLogFile"/>
            and if you want to reuse a log file for several controllers (append to it), set manually your own
            <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.LogFileWriter"/>. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.OpenAndCreate(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Open setup and populate <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/>, and create a <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/>.
            </summary>
            <param name="connection">Connection to file</param>
            <param name="diagnostics">Diagnostics object receiving load messages</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.PrepareLogfile">
            <summary>
            Prepare log file, and write header information to log file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.SetupCloseLogFileOnControllerFinalized(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Connect the log file writer to the controller, such that the log file
            is automatically closed on controller failed or finished.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.CreateController(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Create controller, using the provided MIKE 1D data object.
            <para>
            Sets up log-file writing. 
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.CreateLogFileWriter(DHI.Mike1D.Generic.IConnection)">
            <summary>
            Create a default log-file-writer
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.CreatePreController(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Create pre-simulation controller. A pre-controller may need to
            run before the actual simulation in order to preproces any 
            required data.
            <para>
            The only current pre-controller is auto-calibration of NAM/RDI
            catchments.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DateTimeFormatString">
            <summary>
            Date-time format string
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.Create(System.String,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Load data from file, and create controller.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.Create(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Load data from file, and create controller.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.Create(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Create controller based on content of the <paramref name="mike1DData"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DisableLogFile">
            <summary>
            Flag to disable log-file writing of the controller
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.LogFileWriter">
            <summary>
            User provided log file writer.
            <para>
            Set manually if a specified log file writer is to be reused
            for several controllers, or if other types of control
            with the log file writer is required.
            </para>
            <para>
            If the log file writer is provided by the user, remember
            also to attach it to the DiagnosticsHandler 
            <code>
            diagnosticsHandler.MessageEvent += logFileWriter.AddLine;
            </code>
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DiagnosticsHandler">
            <summary>
            User provided <see cref="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerFactory.DiagnosticsHandler"/>.
            <para>
            Set manually if a specified diagnostics handler is to be reused
            for several controllers, or if other types of control
            with the diagnositcs handler is required.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS">
            <summary>
            The Mike1DControllerLTS is the entry point for a Long Term Statistics simulation.
            It controls initialization, start, stop and finalization of the engine.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DController">
            <summary>
            The Mike1DController is the entry point for an HD simulation, including
            any enabled modules (Rainfall runoff, AD, Control etc.)
            <para>
            It links the simulation setup with the actual engine setup. It controls
            initialization, start, stop and finalization of the engine.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.InitTimings">
            <inheritdoc />
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DController._timingsRun">
            <summary> Timings used during runtime </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DController.MaxNumberOfThreadsUser">
            <summary>
            Maximum number of threads, set by the user.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.#ctor">
            <summary>
            Default constructor
            <para>
            The logfilewriter will be created based on the input file name, or connection properties,
            when calling the <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)"/> method.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Make a controller that uses the provided <paramref name="diagnosticsHandler"/> for 
            handling diagnostics messages. 
            This is convenient if the <paramref name="diagnosticsHandler"/> is to be resued by more than
            one controller.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.Load(DHI.Mike1D.Generic.IConnection)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DController"/> and loads the setup.
            The setup is loaded with all default parameters.
            <para>
            In case of errors when loading the setup, a <see cref="T:DHI.Mike1D.Generic.Mike1DException"/>
            is thrown. Errors can be examined by extracting the <see cref="T:DHI.Mike1D.Generic.IDiagnostics"/>
            object stored in <see cref="P:System.Exception.Data"/> using string key "Diagnostics".
            </para>
            </summary>
            <param name="connection">Connection of file to load</param>
            <returns>A new controller, with populated <see cref="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Mike1DData"/></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.Load(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DController"/> and loads the setup.
            The setup is loaded with all default parameters
            </summary>
            <param name="connection">Connection of file to load</param>
            <param name="diagnostics">Diagnostics to put warnings/errors to.</param>
            <returns>A new controller, with populated <see cref="P:DHI.Mike1D.Mike1DDataAccess.IMike1DController.Mike1DData"/></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Open the file specified by the <paramref name="connection"/>.
            </summary>
            <param name="connection">File to open</param>
            <param name="diagnostics">Diagnostics to handle errors and warnings.</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoInitialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize the engine. Initialize sets up the engine net. When done, the EngineNet
            will be ready to inform on what data is available
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.InitializeStatic(DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Initialize static structures (<see cref="T:DHI.Mike1D.Engine.EngineNet"/>)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.InitializeDynamic(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize dynamic structures (all the modules of the EngineNet)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoStopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoPrepare">
            <summary>
            Prepare the engine. This is called just before run is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoRun">
            <summary>
            Run the engine to end of simulation.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoRunUntil(System.DateTime)">
            <summary>
            Run the engine to specified end time.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoFinish">
            <summary>
            Finish and clean up
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DController.DoValidate">
            <summary>
            Validate that the Controller does not have any errors/warnings
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.SimulationType">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.EngineNetFactory">
            <summary>
            For testing purposes
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.CurrentTime">
            <summary>
            Current time of simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DController.FloodMapFactory">
            <summary>
            For testing purposes
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Constructor, using the provided diagnostics handler.
            </summary>
            <param name="diagnosticsHandler"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.DoRun">
            <summary>
            Run the engine
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.AddGridPointToResults(DHI.Mike1D.Engine.ProxyUtil,DHI.Mike1D.Engine.EngineReach,DHI.Mike1D.Engine.GridPoint,DHI.Mike1D.Mike1DDataAccess.LTSEventList,DHI.Mike1D.Generic.PredefinedQuantity,DHI.Mike1D.Generic.NetworkData{DHI.Mike1D.Mike1DDataAccess.LTSEventList})">
            <summary>
            Create a getter for eventList and add that eventList to networkData at the location of gridPoint
            </summary>
            <param name="proxyUtil"></param>
            <param name="engineReach"></param>
            <param name="gridPoint"></param>
            <param name="eventList"></param>
            <param name="predefinedQuantity"></param>
            <param name="networkData"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.CreateEventListsForNodesAndGridPoints(DHI.Mike1D.Mike1DDataAccess.LTSResultSpecificationItem,DHI.Mike1D.Engine.ProxyUtil,DHI.Mike1D.Generic.NetworkData{DHI.Mike1D.Mike1DDataAccess.LTSEventList},System.TimeSpan,DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.LTSEventListTypes,DHI.Mike1D.Generic.PredefinedQuantity)">
            <summary>
            Create LTSEventLists of the type specified in resultSpecificationItem and store those LTSEventLists in networkDataEventList
            </summary>
            <param name="resultSpecificationItem"></param>
            <param name="proxyUtil"></param>
            <param name="networkDataEventList"></param>
            <param name="minimumTimeBetweenUpdates"></param>
            <param name="type"></param>
            <param name="predefinedQuantity"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.DoStopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.AddNodeToList(System.String,System.String,DHI.Mike1D.NetworkDataAccess.INodes,System.String)">
            <summary>
            Add node to the 'nodes' list
            </summary>
            <param name="nodeId"></param>
            <param name="nodeNotFoundDiagnosticsId"> </param>
            <param name="nodes">The node is added to this list of nodes</param>
            <param name="errAdditionalInfo"> </param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.AddReachToList(System.String,System.String,DHI.Mike1D.Engine.EngineReaches,System.String)">
            <summary>
            Add node to the 'nodes' list
            </summary>
            <param name="reachId"></param>
            <param name="reachNotFoundDiagnosticsId"> </param>
            <param name="reaches">The reach is added to this list of reaches</param>
            <param name="errAdditionalInfo"> </param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.LTSStateInfo">
            <summary>
            Get a string that informs the user about progress in the job generation process. Used by the GUI.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.RainActive(System.DateTime)">
            <summary>
            Return true if any rain boundaries exceed _mike1DData.LongTermStatistics.EpsilonRain at time
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetTotalInflow(System.DateTime,DHI.Mike1D.NetworkDataAccess.INodes)">
            <summary>
            Get inflow contributions from point source boundaries into nodes and catchment connections into nodes.
            </summary>
            <param name="time"></param>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetTotalInflowWithoutDWF(System.DateTime,DHI.Mike1D.NetworkDataAccess.INodes)">
            <summary>
            Get inflow contributions excluding dry weather flow from point source boundaries and catchment connections.
            </summary>
            <param name="time"></param>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.GetTotalOutflow(System.DateTime,DHI.Mike1D.NetworkDataAccess.INodes)">
            <summary>
            Get outflow contributions from point source boundaries and catchment connections.
            </summary>
            <param name="time"></param>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.CreateNodeIdPointSourceboundaryDict(DHI.Mike1D.NetworkDataAccess.INodes)">
            <summary>
            Create a list of point source boundaries for each node in nodes, and 
            put those lists in a dictionary on the node id.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.DoValidate">
            <summary>
            Validate that the Controller does not have any errors/warnings
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.SimulationType">
            <summary>
            String to indicate the type of simulation being run. Used for user output only.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.CurrentTime">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerLTS.ConditionTimeSpanBox">
            <summary>
            A trivial boxed TimeSpan so that we can modify the TimeSpan in a dictionary
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControllerState">
            <summary>
            State of controller
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Created">
            <summary> Controller created, the initial state </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Validating">
            <summary> Controller is validating </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Validated">
            <summary> Controller has sucessfully validated setup </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Invalid">
            <summary> Controller has validated setup, and validation failed </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Initializing">
            <summary> Controller is inititalizing </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Initialized">
            <summary> Controller has successfully initialized. </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Preparing">
            <summary> Controller is preparing </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Prepared">
            <summary> Controller has succesfully prepared </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Running">
            <summary> Controller is running </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Paused">
            <summary> Controller is paused while running setup </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Stopped">
            <summary> Controller was stopped while running setup </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Finished">
            <summary> Controller succesfully finished running </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Finalizing">
            <summary> Controller is finalizing </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Finalized">
            <summary> Controller successfully finalized </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ControllerState.Failed">
            <summary> Controller has failed </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs">
            <summary>
            Class containing event data for the controller event.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.#ctor(DHI.Mike1D.Mike1DDataAccess.ControllerState)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.#ctor(DHI.Mike1D.Mike1DDataAccess.ControllerState,System.String)">
            <summary>
            Constructor with additional info string
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.#ctor(DHI.Mike1D.Mike1DDataAccess.ControllerState,System.String,System.Double)">
            <summary>
            Constructor with additional info string and progress
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.State">
            <summary>
            Current state of the controller
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.AdditionalInfo">
            <summary>
            Additional info following the event.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.Progress">
            <summary>
            Progress indicator, a value between 0 (started) and 1 (finished).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs.Exception">
            <summary>
            Exception, set when the controller has failed due to an unexpected exception.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ControllerCreatedEventArgs">
            <summary>
            Class containing event data for the controller created event.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ControllerCreatedEventArgs.#ctor(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.ControllerCreatedEventArgs.Controller">
            <summary>
            Controller created
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes">
            <summary>
            Type of network locations
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.AllNodes">
            <summary>
            All nodes in the network
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.ListOfNodes">
            <summary>
            A list of nodes
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.SingleNode">
            <summary>
            A single node
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.AllReachess">
            <summary>
            All reaches in the network
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.ListOfReaches">
            <summary>
            A list of reaches
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.SingleReach">
            <summary>
            A single reach
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.StructureReaches">
            <summary>
            Structure reaches
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.StructureReachesConnectedToNode">
            <summary>
            Structure reaches connected to node
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSNetworkLocationTypes.TotalOut">
            <summary>
            Total out
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LTSJobStopCondition.Value">
            <summary>
            The simulation will be stopped if the total inflow descends below "Value" for at least "Time"
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSRuntimeStopConditionCollection">
            <summary>
            Holds a list of LTSRuntimeStopCondition's that must all be satisfied for a job to stop
            (the LTSRuntimeStopConditions in the collection are combined with the logical "and" operator).
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.LTSInitialCondition">
            <summary>
            LTSInitialCondition hold hot start information for the individual jobs in the LTS simulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSInitialCondition.StartInflow">
            <summary>
            This initial condition is used if total inflow at job start time is in the interval [StartInflow; EndInflow]
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSInitialCondition.DateToUseInHotStartFile">
            <summary>
            Initial water levels, discharges etc are taken from the hot start file at this date. The _time_ at which the 
            values are taken is equal to the time of job start. To rephrase: The actual DateTime to use when accessing the 
            hot start file is a combination of the date from DateToUseInHotStartFile and the time of day when the job starts.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.LTSInitialCondition.HotStartFile">
            <summary>
            Path to the hot start file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.IncludeDtMinMaxInJoblistFile">
            <summary>
            Include DtMin and DtMax in job list file. Only included so that users can 
            edit the joblist file later and modify for individual events
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.EpsilonRain">
            <summary>
            Do not start simulation if it rains less than EpsilonRain ( m3/s / m2 )
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.MinimumTimeBetweenRain">
            <summary>
            Combine two LTS events if they are less than MinimumTimeBetweenRain apart
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.JobListFilePath">
            <summary>
            The jlob list read from or written to this file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.LongTermStatisticsData.ResultFilePath">
            <summary>
            LTS results are written to this file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory">
            <summary>
            Factory that sets up and connects the control module
            with the engine net.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.CreateControllableStructureDictionary(DHI.Mike1D.StructureModule.IStructureCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Create dictionary of all controllable structures
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.CreateStructureDictionary(DHI.Mike1D.StructureModule.IStructureCollection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Create dictionary of all structures
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ConnectControlData(DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Method to connect control data structures to the engine net and pipe design
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.CreateControlVariables">
            <summary>
            Creates a list of control variables that are supported by the engine.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ConnectBuildInVariables(DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Connect sensors to the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ConnectSensorsToNetwork(DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.StructureModule.IStructure},System.DateTime,DHI.Mike1D.Generic.IFilePath,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Connect sensors to the network.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ConnectActionsToStructures(DHI.Mike1D.ControlModule.ControlData,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.Generic.IControllable},DHI.Mike1D.Engine.EngineNet,System.DateTime,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Connect actions to the structures
            </summary>
            <param name="controlData"></param>
            <param name="structureIdToStructureDictionary"> </param>
            <param name="engineNet"></param>
            <param name="simulationStart"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.IdentifyLicenseFreeControls(DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.StructureModule.IStructure},DHI.Mike1D.ControlModule.ControlData)">
            <summary>
            Identify link regulation control.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ControlIsLinkRegulation(DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.StructureModule.IStructure},DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.ControlModule.ControlStateMachine)">
            <summary>
            Check whether the <paramref name="csm"/> is a link-regulation control.
            <para>
            A link regulation control is only allowed to control a link regulation (discharge) structure at the first Q-grid point.
            </para>
            </summary>
            <returns>True if control is a link regulation control</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.ControlIsWetWellSetPoint(DHI.Mike1D.Engine.EngineNet,System.Collections.Generic.Dictionary{System.String,DHI.Mike1D.StructureModule.IStructure},DHI.Mike1D.ControlModule.ControlData,DHI.Mike1D.ControlModule.ControlStateMachine)">
            <summary>
            Check whether the <paramref name="csm"/> is a wet-well set point
            <para>
            A wet well set point is a pump control with a PID action, controlling the upstream water level towards a constant
            </para>
            </summary>
            <returns>True if control is a wet-well set point</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Save(DHI.Mike1D.ControlModule.ControlData)">
            <summary>
            Save control data to file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Open(DHI.Mike1D.Generic.IConnection)">
            <summary>
            Open control data from file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater">
            <summary>
            Helper class for updating various variables.
            <para>
            Currently it updates only the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater.Dt"/> variable with the current time step.
            </para>
            </summary>
            <remarks>
            This helper class is required, because the ControlModule must be independent of the 
            MIKE 1D engine. 
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater.Dt">
            <summary>
            Dt variable
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControlDataFactory.Mike1DControlDataVariableUpdater.Update(System.DateTime,System.DateTime)">
            <summary>
            Update variables. Must be called at pre-timestep event or pre-iteration event
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DBridgeFactory">
            <summary>
            Factory class for creating <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DBridge"/>, used
            by <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge"/> loader: You can register your
            own bridge using <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DBridgeFactory.Create">
            <summary>
             Create bridge for opening a MIKE 1D setup
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection">
            <summary>
            Collection of MIKE 1D bridges, <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DBridge"/>.
            <para>
            Register a new bridge by calling <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.AddBridge(System.String,System.String,DHI.Mike1D.Mike1DDataAccess.IMike1DBridgeFactory)"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.#cctor">
            <summary>
            Static constructor, registering all standard bridges.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.AddBridge(System.String,System.String,DHI.Mike1D.Mike1DDataAccess.IMike1DBridgeFactory)">
            <summary>
            Register bridge factory to the collection.
            <para>
            If bridge name is already registered, an exception is thrown
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.GetBridge(System.String)">
            <summary>
            Get bridge for given bridge name
            </summary>
            <param name="bridgeName">Name of bridge, usually extension of setup file</param>
            <returns>Bridge, or null if bridgename is not registered.</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridgeCollection.GetBridgeLongName(System.String)">
            <summary>
            Get long name of bridge
            </summary>
            <param name="bridgeName">Name of bridge, usually extension of setup file</param>
            <returns>Long name of bridge.</returns>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.IMike1DMUBridge">
            <summary>
            Special interface for loading MIKE URBAN data into MIKE 1D
            within the MIKE URBAN GUI.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.IMike1DMUBridge.Open(DHI.Mike1D.Generic.WorkspaceContainer,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create MIKE 1D data from the MIKE URBAN workspace specified in the <paramref name="workspaceContainer"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DMUBridge.FlexibleLoad">
            <summary>
            If true, then the bridge will try to find input files even if the name is wrong.
            Presently only used in the MU bridge to change the extension of RR input files
            from .CRF to RR.res1d.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.IMike1DMUBridge.StopWatch">
            <summary>
            Stop watch, used for detailed timing of the MU loading
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge">
            <summary>
            Common class for loading MIKE 1D setup from various known types of storages.
            <para>
            Currently supporting MIKE 11 (sim11), MIKE URBAN databases (mdb/gdb), MIKE HYDRO (mhydro)
            and MIKE 1D (m1dx).
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.Open(DHI.Mike1D.Generic.IConnection)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.Open(DHI.Mike1D.Generic.WorkspaceContainer,DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.Save(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Save MIKE 1D setup data to file.
            <para>
            Currently supporting MIKE 1D (m1dx).
            </para>
            </summary>
            <param name="mike1DData">MIKE 1D setup to store</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.SetLTSJobListParams(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Set LTS job list parameters, and disable parameters that
            should not be active while creating job list.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.FlexibleLoad">
            <summary>
            If true, then the bridge will try to find input files even if the name is wrong.
            Presently only used in the MU bridge to change the extension of RR input files
            from .CRF to RR.res1d.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.StopWatch">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge.DiagnosticsHandler">
            <summary>
            Handler for diagnostics messages
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate">
            <summary>
            The Mike1DController is the entry point for automatic RR calibration.
            <para>
            It will loop through all catchments that has auto calibration
            enabled, and calibrate each of these individually.
            When the controller is done, it will update the catchment
            parameters to contain the optimal parameters.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.#ctor">
            <summary>
            Base constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.#ctor(DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Base constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.InitTimings">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoInitialize(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Initialize the engine. Initialize sets up the engine net. When done, the EngineNet
            will be ready to inform on what data is available
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoStopSimulation">
            <summary>
            Calling this function will end the simulation after the current timestep has been completed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoPrepare">
            <summary>
            Prepare the engine. This is called just before run is called.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoRun">
            <summary>
            Run the engine
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoFinish">
            <summary>
            Finish and clean up
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.DoValidate">
            <summary>
            Validate that the Controller does not have any errors/warnings
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.Progress">
            <summary>
            Progress object for calibrator
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DControllerRRCalibrate.SimulationType">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes">
            <summary>
            Type of result to create default result specifications for. Used in <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.GetDefaultResultSpecification(DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes)"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.HD">
            <summary> HD results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.HDDecoupled">
            <summary> HD decoupled results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.AD">
            <summary> AD component results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.EL">
            <summary> ECO Lab results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RR">
            <summary> Rainfall Runoff results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RRCatchmentDischarge">
            <summary> Catchment discharge results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RRAdditionalNAM">
            <summary> Rainfall Runoff additional results for NAM </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RRAdditionalNAMWithElevationZones">
            <summary> Rainfall Runoff additional results for NAM, including elevation zones </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.UserSpecified">
            <summary> User specified results </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes.RRLID">
            <summary> LID results </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData">
            <summary>
            Class that collects all DataAccess components in one place.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.#ctor">
            <summary>
            Create a new Mike1DData component
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Called when deserialized. 
            </summary>
            <param name="c"></param>
            <remarks>
            The constructor is not called during deserializing, hence
            any constructor code must be executed here.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Construct">
            <summary>
            Constructor code, extracted from constructor to 
            support custom construction when deserializing
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.CreateRuntimeDiagnostics">
            <summary>
             Create a runtime Diagnostics instance. This is called from Mike1DController.Prepare()
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ControllerCreatedEvent">
            <summary>
            Event that is triggered when a this <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/> is
            being connected to a newly created controller. 
            <para>
            This can be used by components that only have access to data access classes,
            to also get access to the controller and its events. 
            Examples are data bridges and plugins.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseHD">
            <summary>
            Flag specifying whether HD is included.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseRR">
            <summary>
            Flag specifying whether Rainfall Runoff calculation is included.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseRRResults">
            <summary>
            Flag specifying whether rainfall runoff data are 
            extracted from a rainfall runoff result file.
            Can not be used simultaneously with the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseRR"/>, 
            only one of them can be enabled.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseCatchmentDischargeResults">
            <summary>
            Flag specifying whether rainfall runoff catchment discharge data are 
            extracted from a rainfall runoff result file.
            Can not be used simultaneously with the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseRR"/>, 
            only one of them can be enabled.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseAD">
            <summary>
            Flag specifying whether Advection Dispersion/component transport is included.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseEL">
            <summary>
            Flag specifying whether EcoLab is included. EcoLab automatically enables AD, <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseAD"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseControlModule">
            <summary>
            Flag specifying whether Control module is included. 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseDA">
            <summary>
            Flag specifying whether DA is included.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseThreadedDomainDecomposition">
            <summary>
            Use Threaded domain decomposition
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.SetAdditionalData(System.String,System.Object)">
            <summary>
            Set additional data
            </summary>
            <remarks>
            If storing/loading setup to/from xml, all additional data objects must include 
            a <see cref="T:System.Runtime.Serialization.DataContractAttribute"/>, otherwise storing/loading will fail.
            </remarks>
            <param name="key">Identifier/key string of network data</param>
            <param name="value">Object containing additional data</param>
            <returns>True if additional data was added, false if not added because data with the existing key already exists.</returns>
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.GetAdditionalData(System.String)">
            <summary>
            Get additional data, based on key.
            </summary>
            <param name="key">Identifier/key string of additional data object</param>
            <returns>Object associated with key. Null if key is not defined</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.GetAdditionalData``1(System.String,``0)">
            <summary>
            Get additional data, based on key. If no data exist for value, return the <paramref name="defaultValue"/>
            </summary>
            <param name="key">Identifier/key string of additional data object</param>
            <param name="defaultValue">Default value, if key not found.</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ContainsAdditionalData(System.String)">
            <summary>
            Returns true if data is associated with the key.
            </summary>
            <param name="key">Identifier/key string of additional data object</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.TryGetAdditionalData(System.String,System.Object@)">
            <summary>
            Get additional data, based on key.
            </summary>
            <param name="key">Identifier/key string of additional data object</param>
            <param name="value">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter.</param>
            <returns>True if value is set for the key. False otherwise</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.GetDefaultResultSpecification(DHI.Mike1D.Mike1DDataAccess.ResultSpecificationTypes)">
            <summary>
            Creates a default result specification of the type provided.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Validate">
            <summary>
            Validates the contents. Files are validated for existence. Large parts of the validations 
            are delegted to the included data access modules.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.LoadPlugin(DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.Plugins.Mike1DPluginInfo,DHI.Mike1D.Generic.IDiagnostics,DHI.Mike1D.Generic.DiagnosticsHandler)">
            <summary>
            Static method for explicitly loading of a MIKE 1D plugin.
            </summary>
            <param name="mike1DData">MIKE 1D data object</param>
            <param name="pluginInfo">Info on the plugin to load</param>
            <param name="diagnostics">Diagnostics to report errors to.</param>
            <param name="handler">Handler to write messages to. Can be null</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.LoadPlugin(DHI.Mike1D.Plugins.Mike1DPluginInfo)">
            <summary>
            Static method for loading a MIKE 1D plugin - creating a new instance of a <see cref="T:DHI.Mike1D.Plugins.IMike1DPlugin"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.LoadPlugin(DHI.Mike1D.Plugins.Mike1DPluginInfo,System.String)">
            <summary>
            Static method for loading a MIKE 1D plugin - creating a new instance of a <see cref="T:DHI.Mike1D.Plugins.IMike1DPlugin"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DData.LoadPluginObj(DHI.Mike1D.Plugins.Mike1DPluginInfo,System.String)">
            <summary>
            Static method for loading a MIKE 1D plugin - creating a new instance of a <see cref="T:DHI.Mike1D.Plugins.IMike1DPlugin"/>.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.TsBuffer">
            <summary>
            A buffer containing all timeseries, so they can be reused.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.RuntimeDiagnostics">
            <summary>
            Diagnostics instance for the engine net. Used during runtime.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Id">
            <summary>
            Id of the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ScenarioId">
            <summary>
            Scenario Id of the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Description">
            <summary>
            Description of the simulation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UseHDLongTermStatistics">
            <summary>
            If this is true, then run HD simulation in Long Term Statistics mode based on the 
            configuration in 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.UsePipeDesign">
            <summary>
            Run a pipe design simulation. Pipe design is a MU feature for calibrating reach diameters
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ProjectionString">
            <summary>
            A WKT string defining the spatial reference system. See DHI.Generic.DFSIO.IDFSProjection
            for details.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.Network">
            <summary>
            Network data access. Provides access to input data that defines the network.
            Notice that structure data are accessed through the the network.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.LongTermStatistics">
            <summary>
            Data access for HD long term statistics simulations
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.CrossSections">
            <summary>
            Cross section data access. Provides access to all input data that defines the cross sections.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.HDParameters">
            <summary>
            HD parameter data access. Provides options for the HD part of the engine
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.BoundaryData">
            <summary>
            Boundary data access. Provides access to all input data that specifies the boundary conditions
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.RainfallRunoffData">
            <summary>
            Rainfall Runoff (catchment) data access. Provides access to all input data that specifies rainfall runoff models
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ControlData">
            <summary>
            Control module data access. Provides access to all input data for control
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ADComponentData">
            <summary>
            Advection-dispersion/component transport data access. Defines components that are included in the simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.EcoLabData">
            <summary>
            EcoLab data access component. Defines the connection between the HD and AD module and the EcoLab template
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.PipeDesignData">
            <summary>
            Pipe design data. Pipe design is a MU feature for calibrating reach diameters
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.DataAssimilationData">
            <summary>
            Data Assimilation data. Provides access to all input data that specifies Data Assimilation
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.SimulationStart">
            <summary>
            Simulation start time
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.SimulationEnd">
            <summary>
            Simulation end time
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.TimeStepping">
            <summary>
            Get/set TimeStepping parameters
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ResultSpecifications">
            <summary>
            Specifications on how to write result files, when, what to include and where.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.CrossSectionsFilePath">
            <summary>
            File path to cross section file
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.RainfallRunoffResultDataFilePath">
            <summary>
            Path to file containing rainfall runoff results that is to be
            coupled with a HD simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.CatchmentDischargeResultDataFilePath">
            <summary>
            Path to file containing rainfall runoff results that is to be
            coupled with a HD simulation.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ResultBaseFilePath">
            <summary>
            Base path for result files. If a relative path is specified
            for a result file, the path is relative to this path.
            <para>
            If this is not set explicitly, the <see cref="P:DHI.Mike1D.Generic.AbstractDataAccess.Connection"/>
            FilePath is used as base file path. Set to null to delete an explicitly
            defined value.
            </para>
            <para>
            If folder does not exist, but the parent folder exists, the folder will be created
            when the simulation is executed.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.MaxNumberOfErrorLogFileBackups">
            <summary>
            Maximum number of backups of html error log file. Log files are rolled over so that
            older log files are kept. This is the maximum number of old log files that are stored.
            Default value is 3.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.FilePathHtmlErrorLog">
            <summary>
            File path of html error log. Used by SimLauncher.SimulationWorker to create the log.
            <para>
            The log files will not be created when using the <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/> directly.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.FilePathHtmlSummary">
            <summary>
            File path of html summary. Used in SimLauncher.SimulationWorker to create the log.
            <para>
            The log files will not be created when using the <see cref="T:DHI.Mike1D.Mike1DDataAccess.IMike1DController"/> directly.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.PluginInfos">
            <summary>
            List of plugins registered for this setup.
            <para>
            Plugins are handled when the setup has been loaded and a <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/> object is available.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DData.AdditionalData">
            <summary>
            Additional data, a set of key-value pairs, where the key is a string.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DDataXmlBridge">
            <summary>
            Bridge class for saving MIKE 1D data to XML, handling reading/writing the .m1dx file.
            <para>
            For loading a full setup, use the <see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DBridge"/>.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataXmlBridge.Open(DHI.Mike1D.Generic.IDiagnostics)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DDataXmlBridge.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DDataXmlBridge.FilePath">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter">
            <summary>
            Log file writer for MIKE 1D engine. 
            <para>
            Call <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.Prepare"/> to open the logfile. 
            If prepare is not called, all writing to the logfile is ignored silently.
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.logfileIndent">
            <summary>
            The indentation matching the date-time output
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.#ctor(System.String)">
            <summary>
            Default constructor, setting the default log file name
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.Prepare">
            <summary>
            Prepare (open) the log file. Returns false if the log file is already open, i.e.
            it can be called multiple times.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.AddLine(DHI.Mike1D.Generic.DiagnosticsHandler.MessageType,System.String)">
            <summary>
            Add a message line to the log file.
            </summary>
            <param name="messageType">Type of message</param>
            <param name="message">Message</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.AddAdditionalLine(System.String)">
            <summary>
            Add an additional line to the log file. This line is related to
            a previous line added by <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.AddLine(DHI.Mike1D.Generic.DiagnosticsHandler.MessageType,System.String)"/>, and
            type of error message and date/time will not be printed.
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.ExceptionToLogFile(System.Exception)">
            <summary>
            Prints exception message and stack to log file, including
            inner exceptions.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.ExceptionToConsole(System.Exception)">
            <summary>
            Helper method that writes exception to console out (for command line output)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.CloseLogFile">
            <summary>
            Close the logfile
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.LogFileOpen">
            <summary>
            Flag indicating if log file is open and can be written to.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.IncludeExceptionStackTrace">
            <summary>
            Flag specifying whether the exception stack trace should be written
            to the log file, in case of an exception. The exception message
            is always written to the log file.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DLogFileWriter.LogFileName">
            <summary>
            Name and full path of log file. By default the name is the setup
            name where the extension is replaced by ".log". Another name can
            be specified here.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory">
            <summary>
            Factory that sets up an <see cref="T:DHI.Mike1D.ResultDataAccess.IResultData"/>
            to retrieve values from an <see cref="T:DHI.Mike1D.Engine.EngineNet"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.#ctor(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Constructor
            </summary>
            <param name="controller"></param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateResultData(DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Mike1DDataAccess.Mike1DData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Create result data object from result specification
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.SetupNetwork(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Sets up the ResultData based on the static data in the <see cref="T:DHI.Mike1D.Engine.EngineNet"/> and the <see cref="T:DHI.Mike1D.ResultDataAccess.ResultSpecification"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DNetwork(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Create a Res1D network (static data), based on <paramref name="engineNet"/>. 
            Copy over some data from <paramref name="mike1DData"/> to the <paramref name="results"/> object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DNetworkDataItems(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet)">
            <summary>
            Create data item in <paramref name="results"/> matching the quantities in the <paramref name="resultSpec"/>
            extracting values from the <paramref name="engineNet"/>. The data items are stored in the 
            <paramref name="results"/> object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DDataItem(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider)">
            <summary>
            Create data item in <paramref name="results"/> for the <paramref name="quantity"/>
            extracting values from the <paramref name="module"/>. The data items are stored in the 
            <paramref name="results"/> object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DDataItem(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider,DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter)">
            <summary>
            Create data item in <paramref name="results"/> for the <paramref name="quantity"/>
            extracting values from the <paramref name="module"/>. The data items are stored in the 
            <paramref name="results"/> object.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.SetupCatchments(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.RainfallRunoffModule.RainfallRunoffData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CatchmentResultDataUpdaterPerTimestep)">
            <summary>
            Sets up the ResultData for <see cref="T:DHI.Mike1D.RainfallRunoffModule.RainfallRunoffData"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DCatchments(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.RainfallRunoffModule.RainfallRunoffData)">
            <summary>
            Returns: For each res1DCatchment Id, a list of ICatchments that is associated with the res1DCatchment
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateNodeDataItem(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNode,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/> for a node if the quantity is offered by the node. 
            If the given quantity is not offered, null is returned.
            </summary>
            <returns>null if quantity is not offered inside reach</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateReachDataItem(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,System.Int32,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider,DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/> for a reach if the quantity is offered as an item global 
            to the reach. If the given quantity is not offered, null is returned.
            </summary>
            <returns>false if quantity is not offered inside reach</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateReachDataItemsFromGridPoints(DHI.Mike1D.ResultDataAccess.ResultData,DHI.Mike1D.ResultDataAccess.ResultSpecification,DHI.Mike1D.Engine.EngineNet,System.Int32,DHI.Mike1D.Generic.IQuantity,DHI.Mike1D.Engine.IProxyProvider,DHI.Mike1D.ResultDataAccess.IRes1DSpatialFilter)">
            <summary>
            Creates a <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/> for all grid points in a reach. If no gridpoints offer 
            the given quantity, null is returned.
            <para>
            The method returns a list of data items, since the same quantity may occur more than
            once on a grid point (e.g. structure discharges if there are paralle structures 
            (more than one structure at the same location)
            </para>
            </summary>
            <returns>null if quantity is not offered inside reach</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateRes1DNode(DHI.Mike1D.Engine.EngineNode,System.Int32@)">
            <summary>
            Factory function for creating different types of IRes1DNodes
            depending on the engineNode type
            </summary>
            <returns>IRes1DNode matching engine node type</returns>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateADOutputSpecification(System.String,DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Create an AD output specification that matches the baseSpecss
            </summary>
            <param name="id">ID of result specification</param>
            <param name="adData">AD component specification</param>
            <param name="baseSpecs">Basic result specifications, usually the default HD result specifications</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateADRROutputSpecification(System.String,DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Create an AD-RR output specification that matches the baseSpecss
            </summary>
            <param name="id">ID of result specification</param>
            <param name="adData">AD component specification</param>
            <param name="baseSpecs">Basic result specifications, usually the default HD result specifications</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateAdditionalOutputSpecification(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Create an additional output specification
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CreateAdditionalAdOutputSpecification(DHI.Mike1D.ADDataAccess.ADComponentData,DHI.Mike1D.ResultDataAccess.ResultSpecification)">
            <summary>
            Helper method for model bridges to set up additional AD output specifications
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.SkipDataItems">
            <summary>
            Flag indicating if to skip creating data items automatically from
            engine. If set, the user must define data items themselves, and
            also assure that data is populated automatically.
            <para>
            Default: false
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.UserDefinedWriting">
            <summary>
            Flag indicating if the user handles flushing to file manually.
            If set, the user must manually write data to file. 
            <para>
            Default: false, meaning that writing to file is handled automatically 
            by the engine.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.WriteInitialDataToFile">
            <summary>
            Helper class that writes initial data to result file
            at first EngineNet/RR pre-timestep event.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.WriteSteadyIterationsToFile">
            <summary>
            Helper class that writes steady state iterations to result file,
            used when imposing steady state initial conditions
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CatchmentRunController">
            <summary>
            A <see cref="T:DHI.Mike1D.RainfallRunoffModule.ICatchmentRunController"/> that makes sure that an update
            event is raised at certain "check point" times, and whenever certain
            catchments have performed an update. The times are handled by 
            a "CheckPointProvider", which is a method that defines the next 
            checkpoint in time where an update event must be raised.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CatchmentRunController.AddCheckPointProvider(System.Func{System.DateTime})">
            <summary>
            Add a new check point provider. The check point provider must provide
            the time of which it wants the next update, and it must be sure
            to increment the time when the update event at that time is raised.
            </summary>
            <param name="checkPointProvider"></param>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CatchmentResultDataUpdaterPerTimestep">
            <summary>
            Helper class for result data updating when the results
            are retrieved from catchments with potential different 
            time steps, and not all catchments are included in all
            result files.
            <para>
            This helper class is required since the catchments may update
            asynchroniously and out-of-order from a time point of view, while
            the results need to be written timewise in-order.
            </para>
            <para>
            The <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CatchmentResultDataUpdaterPerTimestep.SingleCatchmentPerformTimestepEvent(System.DateTime)"/> is
            triggered everytime one of the catchments included in this
            result data has taken a time step. It is in general triggered with 
            time arguments in non-sorted order.
            </para> 
            <para>
            The <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CatchmentResultDataUpdaterPerTimestep.RrPerformTimestepEvent(System.DateTime)"/> is called every time
            the rainfall runoff run-controller reaches a certain time. These are
            triggered in sorted order, and also for times that are not relevant
            for this result file.
            </para>
            <para>
            Results will be updated in the <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.CatchmentResultDataUpdaterPerTimestep.RrPerformTimestepEvent(System.DateTime)"/>, but 
            only if at least one of the catchments has been updated to that time.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource">
            <summary>
            A <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> that can update itself based on an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetter"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource._sources">
            <summary>
            Double getter used to access sources
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Clear">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.CreateTimeSeriesData(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.CreateDataArray">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Sources">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.VectorData">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.Quantity">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.TimeData">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.ItemTypeGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.ItemId">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.NumberWithinGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemReachVectorProxySource.IndexList">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource">
            <summary>
            A <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> that can update itself based on an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetter"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource._source">
            <summary>
            Double getter used to access sources
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Clear">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.GetValue(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.CreateTimeSeriesData(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.CreateDataArray">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Source">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.SourceFrac">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.VectorData">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.Quantity">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.NumberOfElements">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.NumberOfTimeSteps">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.TimeData">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.ItemTypeGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.ItemId">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.NumberWithinGroup">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemNodeProxySource.IndexList">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource">
            <summary>
            A <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/> that can update itself based on an <see cref="T:DHI.Mike1D.Generic.IDoubleVectorGetter"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource._sources">
            <summary>
            Double getter used to access sources
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource._sourcesFrac">
            <summary>
            Double getter used to access sources
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource._values">
            <summary>
            Values
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource.#ctor(System.Int32)">
            <summary>
            Default constructor
            </summary>
            <param name="size">Size of vector/number of elements in data item</param>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource.Update(System.DateTime)">
            <summary>
            Update the <see cref="P:DHI.Mike1D.ResultDataAccess.IDataItem.TimeData"/> with a new set of time step values
            </summary>
            <remarks>
            For some <see cref="T:DHI.Mike1D.ResultDataAccess.IDataItem"/>'s this call may have no effect.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource.Sources">
            <summary>
            List of sources for the <see cref="T:DHI.Mike1D.ResultDataAccess.DataItem"/>, i.e., 
            where to get new <see cref="P:DHI.Mike1D.ResultDataAccess.DataItem.TimeData"/> when <see cref="M:DHI.Mike1D.Mike1DDataAccess.Mike1DResultDataFactory.DataItemVectorProxySource.Update(System.DateTime)"/>
            is called.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.AddToOutput">
            <summary>
            Plugin for adding quantities to output file.
            <para>
            Two arguments are required:
            <list type="bullet">
            <item><description>ResultId: Id of result output. Values are like: 'DefaultHDResults', 'DefaultRRResults' etc. There can only be one ResultId argument.</description></item>
            <item><description>Quantity: Id of quantity to add to output. Values are names of the <see cref="T:DHI.Mike1D.Generic.PredefinedQuantity"/>, like: 'WaterLevel' etc. There can be more than one Quantity argument</description></item>
            <item><description>UserQuantity: Id of EUM item and ID of quantity to add to output, seperated by '::', example 'eumIInfiltration::WettingLoss [ImperviousSteep]'. There can be more than one UserQuantity argument</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.ControlVariableExpression">
            <summary>
            Plugin class for adding variable expressions to the control module
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.IMike1DPlugin">
            <summary>
            Interface for a MIKE 1D Plugin.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.IMike1DPlugin.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Initialize plugin, providing arguments from setup, see <see cref="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.Arguments"/>
            <para>
            It is at this point possible to modify the MIKE 1D setup.
            </para>
            <para>
            It is also possible to register for the <see cref="F:DHI.Mike1D.Mike1DDataAccess.Mike1DData.ControllerCreatedEvent"/>
            which will give access to the controller at time of creation, usually when starting up the
            simulation. 
            From the controller you can register for various events using the 
            <see cref="E:DHI.Mike1D.Mike1DDataAccess.IMike1DController.ControllerEvent"/>.
            </para>
            </summary>
            <param name="arguments">Arguments stored in setup</param>
            <param name="mike1DData"><see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/>Object with entire MIKE 1D setup</param>
        </member>
        <member name="M:DHI.Mike1D.Plugins.ControlVariableExpression.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc/>
        </member>
        <member name="T:DHI.Mike1D.Plugins.CulvertIterations">
            <summary>
            Print out culvert iterations to console or file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.PostTimestepReport">
            <summary>
            Abstract class for producing a report at end of time step.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._fileName">
            <summary>
            Filename to write to. If null or empty, writes to console.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._saveStep">
            <summary>
            When negative, only reports at end-of-simulation.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._controller">
            <summary> Controller </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._writer">
            <summary> File to write to </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.PostTimestepReport._countStep">
            <summary> How often to write </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.OnSetupLoaded(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.OnControllerCreatedEvent(System.Object,DHI.Mike1D.Mike1DDataAccess.ControllerCreatedEventArgs)">
            <summary>
            When controller is created, register for controller events
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.OnControllerEvent(System.Object,DHI.Mike1D.Mike1DDataAccess.ControllerEventArgs)">
            <summary>
            Handle controller event
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.OnPostTimestepEvent(System.DateTime)">
            <summary>
            Handle post-time step event
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PostTimestepReport.WriteTimestep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Plugins.CulvertIterations.WriteTimestep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.CompositeStructureIterations">
            <summary>
            Print out composite structure iterations to console or file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.CompositeStructureIterations.WriteTimestep(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.DecoupledOutput">
            <summary>
            Plugin for setting up decoupled output.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.DecoupledOutput.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Plugins.DecoupledOutput.OnSetupLoaded(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.EcoLabDebugger">
            <summary>
            Plugin that enables debug output from ECO Lab.
            <para>
            The following parameters must be set:
            <list type="bullet">
            <item><description>FilePath: Path to file to write debug info to</description></item>
            <item><description>DebugLevel: ECO Lab debug level</description></item>
            <item><description>StartDateTime: Simulation time of start of debugging, format: yyyy-MM-dd HH:mm:ss</description></item>
            <item><description>EndDateTime: Simulation time of start of debugging, format: yyyy-MM-dd HH:mm:ss</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.EcoLabDebugger.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Plugins.EcoLabDebugger.OnSetupLoaded(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.EcoLabNumberChecker">
            <summary>
            Plugin that checks output from ECO Lab, and will throw an exception on first occurance
            of a NaN of inf number.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.EcoLabNumberChecker.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Plugins.EcoLabNumberChecker.OnSetupLoaded(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.Mike1DPluginInfo">
            <summary>
            Information on how to load a MIKE 1D plugin.
            <para>
            A Mike 1D plugin is a class implementing the <see cref="T:DHI.Mike1D.Plugins.IMike1DPlugin"/>.
            To utilize such a class, the name of the class and the name of the assembly
            containing the class must be provided. Also a number of arguments to the
            assembly can be defined.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.AssemblyName">
            <summary>
            Name of assembly that contains the plugin.
            <para>
            The name must contain the full path to the assembly file on the disc.
            It can also contain the fully qualified/long name of the assembly to load from the GAC (including Version, Culture and PublicKeyToken).
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.ClassName">
            <summary>
            Name of class that implements the <see cref="T:DHI.Mike1D.Plugins.IMike1DPlugin"/> interface.
            <para>
            Class name must include name space, i.e. on the form
            <code>
            MyNameSpace.MySubNameSpace.MyPluginClass
            </code>
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.Arguments">
            <summary>
            Plugin arguments, used when initialising the plugin, see <see cref="M:DHI.Mike1D.Plugins.IMike1DPlugin.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument},DHI.Mike1D.Mike1DDataAccess.Mike1DData)"/>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.Mike1DPluginArgument">
            <summary>
            Argument for a plugin, in the form of a key and a value
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.Mike1DPluginArgument.Key">
            <summary>
            Key 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Plugins.Mike1DPluginArgument.Value">
            <summary>
            Value
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Plugins.PluginWriteSteadyIterationsToFile">
            <summary>
            Plugin that enables writing of steady iterations to default HD result file.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.PluginWriteSteadyIterationsToFile.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument})">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.Plugins.PluginWriteSteadyIterationsToFile.OnSetupLoaded(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.Plugins.RemoveLID">
            <summary>
            Plugin for removing some or all LID's from a setup
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Plugins.RemoveLID.Initialize(System.Collections.Generic.IList{DHI.Mike1D.Plugins.Mike1DPluginArgument})">
            <summary>
            Initialize plugin, providing arguments from setup, see <see cref="P:DHI.Mike1D.Plugins.Mike1DPluginInfo.Arguments"/>
            <para>
            Arguments can be:
            <code>
               all = 'true'
               lidid = 'someLIDID'
               catchmentid = 'someCatchmentID'
            </code>
            If specifying <code>all = true</code>, all LIDs are removed. If specifying a catchment ID, then all LIDs
            from that catchment is removed. If specifying a LID ID, only that single lid is removed.
            </para>
            <para>
            It is possible to specify more LID ID's and Catchment ID's
            </para>
            </summary>
            <param name="arguments">Arguments stored in setup</param>
        </member>
        <member name="M:DHI.Mike1D.Plugins.RemoveLID.OnSetupLoaded(DHI.Mike1D.Mike1DDataAccess.Mike1DData)">
            <summary>
            Method that is called when a setup has been loaded.
            <para>
            Removes lids from setup
            </para>
            </summary>
            <param name="mike1DData"><see cref="T:DHI.Mike1D.Mike1DDataAccess.Mike1DData"/>Object with entire MIKE 1D setup</param>
        </member>
        <member name="P:DHI.Mike1D.Plugins.RemoveLID.RemoveAll">
            <summary>
            Remove all LID's
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.RemoveLID.Lidids">
            <summary>
            Remove LIDs with ID
            </summary>
        </member>
        <member name="P:DHI.Mike1D.Plugins.RemoveLID.Catchids">
            <summary>
            Remove all LIDs from catchments
            </summary>
        </member>
        <member name="T:DHI.Mike1D.Mike1DDataAccess.ProgressWriter">
            <summary>
            Write progress to standard out
            </summary>
        </member>
        <member name="M:DHI.Mike1D.Mike1DDataAccess.ProgressWriter.#ctor(DHI.Mike1D.Mike1DDataAccess.IMike1DController)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:DHI.Mike1D.Mike1DDataAccess.ProgressWriter.UpdateFrequencySeconds">
            <summary>
            Frequency in seconds on how often to update the progress
            </summary>
        </member>
    </members>
</doc>
