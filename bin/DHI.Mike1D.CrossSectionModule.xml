<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DHI.Mike1D.CrossSectionModule</name>
    </assembly>
    <members>
        <member name="T:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot">
            <summary>
             Base functionality for the <see cref="T:DHI.Mike1D.CrossSectionModule.BottomSlotClassic"/>
             and <see cref="T:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving"/>.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot._slotStartDepth">
            <summary>
            depth where the slot is used
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot._bottomLevel">
            <summary>
            Bottom level for cross section.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot._crossSection">
            <summary>
            Cross section that slot is attached to.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double)">
            <summary>
             Construct and initialize AbstractBottomSlot
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.MoveSlot(System.Double)">
            <summary>
            Move slot up or down, to match the specified bottom level.
            <para>
            Initially the bottom level is set to <see cref="P:DHI.Mike1D.CrossSectionModule.ICrossSection.ZMin"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.GetStorageWidth(System.Double)">
            <summary>
            Returns the width of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Width of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.GetFlowArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.GetFlowAreaDerivative(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Returns the additional storage area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.GetRadius(System.Double)">
            <summary>
            Returns the radius in the slot. This is the value
            at the top of the slot (at waterLevel = ICrossSection.ZMin+slotStartDepth)
            </summary>
            <remarks>
            If overriding, remember to make virtual
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.GetRadiusDerivative(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            </summary>
            <remarks>
            This is presently always the value at the top of the slot (at waterLevel = ICrossSection.ZMin+slotStartDepth)
            If overriding, remember to make virtual
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.GetResistanceFactor(System.Double)">
            <summary>
            Returns the resistance factor in the slot. This is the value
            at the top of the slot (at waterLevel = ICrossSection.ZMin+slotStartDepth)
            </summary>
            <remarks>
            If overriding, remember to make virtual
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
            <remarks>
            This is presently always the value at the top of the slot (at waterLevel = ICrossSection.ZMin+slotStartDepth)
            If overriding, remember to make virtual
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.AbstractBottomSlot.Validate">
            <summary>
            Validate the object
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving">
            <summary>
            Classic Slot. TODO: Document
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving._widthAtSlotTop">
            <summary>
            Width at top of slot
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving._c1">
            <summary>
            Coefficient below <see cref="F:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving._z0"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving._c2">
            <summary>
            Coefficient above <see cref="F:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving._z0"/>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving._z0">
            <summary>
            Depth at which equations change
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving._areaZ0">
            <summary>
            Area at <see cref="F:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving._z0"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double)">
            <summary>
            Constructor. The arguments passed are used to determine the bottom level of the corresponding
            cross section and the width slotStartDepth above the bottom.
            </summary>
            <param name="crossSection">CrossSection that slot is attached to</param>
            <param name="slotStartDepth">Depth where bottom slot starts</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving.GetStorageWidth(System.Double)">
            <summary>
            Returns the width of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Width of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.BottomSlotAreaPreserving.GetFlowArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.BottomSlotClassic">
            <summary>
            Classic Slot. When in the slot, the area is constant corresponding to the area at hDelta, 
            while the width is decreasing down through the slot.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.BottomSlotClassic._slotBottomLevel">
            <summary>
            Bottom level for cross section.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.BottomSlotClassic._c">
            <summary>
            Constant containing b_s at slot top * Sqrt(6*_slotStartDepth)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.BottomSlotClassic._areaAtSlotTop">
            <summary>
            Area
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.BottomSlotClassic.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double)">
            <summary>
            Constructor. The arguments passed are used to determine the bottom level of the corresponding
            cross section and the width of the slot at the slotStartDepth.
            </summary>
            <param name="crossSection">CrossSection that slot is attached to</param>
            <param name="slotStartDepth">Depth where bottom slot starts</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.BottomSlotClassic.GetStorageWidth(System.Double)">
            <summary>
            Returns the width of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Width of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.BottomSlotClassic.GetFlowArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.ClosedXSPreprocessedData.DistanceBetweenLevels">
            <summary>
            Distance between levels
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.ClosedXSPreprocessedData.NumberOfLevels">
            <summary>
            Number of levels
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.ClosedXSPreprocessedData.RelativeAR23">
            <summary>
            A relative A*R^(2/3). Let AR23Top be the value
            of A*R^(2/3) at level 100 (height of cross section), then
              RelativeAR23[i] = A[i]*R[i]^(2/3) / AR23Top
            If larger than one, then set to one. The maximum value of AR23
            is not at the top, but a bit below.
            
            In MU called the fyd table
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.ClosedXSPreprocessedData.RelativeAR23CutOffLevel">
            <summary>
            The level where the RelativeAR23 has been cut to the value 1
            
            In MU called the y_div_dia_full
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.ClosedXSPreprocessedData.RelativeAR23Max">
            <summary>
            
            In MU called fyd_max
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ClosedXSPreprocessedData.ConvertMatrixData(System.Int32,System.Double[0:,0:])">
            <summary>
            Convert a data matrix to a ClosedXSPreprocessedData
            </summary>
            <param name="arrayLength">Number of layers</param>
            <param name="matrix">2D datamatrix</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ClosedXSCoefficients.#cctor">
            <summary>
            Convert array structures to individual vectors.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ClosedXSCoefficients.ConvertMatrixData">
            <summary>
            Convert array structures to individual vectors.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.ClosedXSCoefficients.NumberOfLevelsToUseMU">
            <summary>
            Specifies the number of levels to use for MU type cross sections. Default 151, max 251.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.ClosedXSCoefficients.NumberOfLevelsToUseM11">
            <summary>
            Specifies the number of levels to use for M11 type cross sections. Default 251, max 251.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.ClosedXSCoefficients.CircularM11">
            <summary>
            area, width, and radius^(2/3) for CIRCULAR Pipe. This is the old version from MU (Pre 2007), which is the same as M11
            The delta area has been added so it should not be calculated
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ComputationalGeometry">
            <summary>
            Utilities for computational geometry, static methods only
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ComputationalGeometry.PointIsInRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns true iff a point is inside a rectangle. The rectangle can be improper,
            i.e., unbounded on one or multiple verteces
            </summary>
            <param name="x">x coordinate of the point</param>
            <param name="y">y coordinate of the point</param>
            <param name="xmin">leftmost x coordinate of rectangle, or COMMath.DOUBLE_NaN
            if not applicable (no left x bound)</param>
            <param name="ymin">lowermost y coordinate or COMMath.DOUBLE_NaN</param>
            <param name="xmax">rightmost x coordinate or COMMath.DOUBLE_NaN</param>
            <param name="ymax">uppermost y coordinate or COMMath.DOUBLE_NaN</param>
            <returns>true if intersection</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ComputationalGeometry.LineIntersectsRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns true iff a line intersects a rectangle. The rectangle can be improper,
            i.e., unbounded on one or multiple verteces
            </summary>
            <param name="x1"> X coordinate of first point</param>
            <param name="y1"> Y coordinate of first point</param>
            <param name="x2"> X coordinate of second point</param>
            <param name="y2"> Y coordinate of second point</param>
            <param name="xmin">leftmost x coordinate of rectangle, or COMMath.DOUBLE_NaN
            if not applicable (no left x bound)</param>
            <param name="ymin">lowermost y coordinate or COMMath.DOUBLE_NaN</param>
            <param name="xmax">rightmost x coordinate or COMMath.DOUBLE_NaN</param>
            <param name="ymax">uppermost y coordinate or COMMath.DOUBLE_NaN</param>
            <returns>true if intersection</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ComputationalGeometry.LinInterp(System.Double,System.Double,System.Double)">
            <summary>
            interpolated between left and right neighbor values. Returns COMMath.DOUBLE_NaN
            if either value is NotANumber
            </summary>
            <param name="d1">left value</param>
            <param name="d2">right value</param>
            <param name="dRatio">relative distance between neighbors. A value of 0 indicates
            the left neighbor, so if 0, d1 will be returned</param>
            <returns>double or COMMath.DOUBLE_NaN if either neighbor is so.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ComputationalGeometry.CalculatePolygonArea(System.Collections.Generic.List{DHI.Mike1D.CrossSectionModule.ICrossSectionPoint})">
            <summary>
            Calculates the area inside the polygon defined by the vertices
            </summary>
            <param name="Vertices"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ComputationalGeometry.CalculateLengthOfPolyline(System.Collections.Generic.List{DHI.Mike1D.CrossSectionModule.ICrossSectionPoint})">
            <summary>
            Calculates the length of the polyline defined by the vertices. Equal to circumference of polygon
            </summary>
            <param name="Vertices"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionFactory">
            <summary>
            A factory builder for creating cross sections.
            <para>
            To create a new cross section, first create a <see cref="T:DHI.Mike1D.CrossSectionModule.CrossSectionFactory"/>.
            Then build the base of the cross section by calling one of the BuildXXX functions.
            Use the SetXXX functions to customize the cross section.
            Get the finished cross section from <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.GetCrossSection"/>
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.BuildCircularPreprocessed(System.Double,DHI.Mike1D.Generic.StandardCrossSectionType)">
            <summary>
            Class to build a cross section.
            </summary>
            <param name="diameter"></param>
            <param name="type"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.BuildCircular(System.Double)">
            <summary>
            Class to build a cross section.
            </summary>
            <param name="diameter"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.BuildRectangularPreprocessed(System.Double,System.Double)">
            <summary>
            Class to build a cross section.
            Uses the Build Pattern.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.BuildRectangular(System.Double,System.Double)">
            <summary>
             Build rectangular XS
            </summary>
            <param name="height"></param>
            <param name="width"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.BuildRectangularPolygon(System.Double,System.Double,System.Int32)">
            <summary>
            Create a Polygon cross section representing a rectangle, with the given number
            of equidistant processed levels.
            <para>
            Processed data has not yet been calculated, you should call 
            <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.IDiagnostics)"/> before using it.
            </para>
            </summary>
            <param name="width">Width of rectangle</param>
            <param name="height">Height of rectangle</param>
            <param name="nLevels">Number of processed levels</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.BuildOpen(System.String)">
            <summary>
            Build a CrossSectionLocated with an XSOpen as base cross section
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.BuildPolygon(System.String)">
            <summary>
            Build a CrossSectionLocated with an XSPolygon as base cross section
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetTopExtension(DHI.Mike1D.Generic.TopExtensionType)">
            <summary>
             Set top slotter on XSPolygon. The top slotter creates additional levels
             in the processed data during XS initialize
            </summary>
            <param name="topExtensionType">Type of extension of top of cross section </param>
            <exception cref="T:DHI.Mike1D.Generic.Mike1DException"></exception>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetFlowResistance(DHI.Mike1D.CrossSectionModule.FlowResistance)">
            <summary>
             Set the flow resistance of the cross section being build
            </summary>
            <param name="flowResistance"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetResistanceDistribution(DHI.Mike1D.Generic.ResistanceDistribution)">
            <summary>
             Set the flow resistance of the cross section being build
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.GetDepthDependence">
            <summary>
            Return the depthdependence of the cross section currently being build
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetLocation(DHI.Mike1D.Generic.ZLocation)">
            <summary>
             Set the XLocation of the current cross section
            </summary>
            <param name="location"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetCoordinates(DHI.Mike1D.Generic.Spatial.Geometry.ICoordinateSequence)">
            <summary>
             Set the real world X-Y/easting-northing coordinates of the current cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.CrossSectionNeedsLocation">
            <summary>
            Set if this cross section needs a location. If cross section needs
            a location, and does not have one set, an error is thrown at <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.GetCrossSection"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.CrossSectionIsSymmetric">
            <summary>
            Set XSBaseRaw base cross section to symmetric
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetRawPoints(DHI.Mike1D.CrossSectionModule.CrossSectionPointList)">
            <summary>
            Set raw data points.
            It is setting the point list of an XSBaseRaw base cross section.
            </summary>
            <param name="xsPointList"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetEquidistantProcessingLevelSpecs(System.Int32,System.Double,System.Double)">
            <summary>
            Sets equidistant processinglevel specs similar to those set in a MU setup. 
            Use when the minimum and maximum Z-value of the raw data is known.
            Builder pattern: Builds xsBaseRaw.
            </summary>
            <param name="nLevels">Number of equidistant layers</param>
            <param name="minZ">Minium z-value of raw data</param>
            <param name="maxZ">Maximum z-value of raw data</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetEquidistantProcessingLevelSpecs(System.Int32)">
            <summary>
            Sets equidistant processinglevel specs similar to those set in a MU setup
            Builder pattern: Builds xsBaseRaw.
            </summary>
            <param name="nLevels">Number of equidistant layers</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetProcessedData(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Set processed data. All arrays must have same length. Only 
            </summary>
            <param name="levels">Processed levels</param>
            <param name="flowAreas">Processed flow areas</param>
            <param name="radii">Processed hydraulic radii</param>
            <param name="storageWidths">Processed storage widths</param>
            <param name="additionalStorageAreas">Processed additional storage areas</param>
            <param name="resistFactors">Processed resistance factors</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetRadiusType(DHI.Mike1D.Generic.RadiusType)">
            <summary>
            Set radius type of XSBaseRaw base cross section
            </summary>
            <param name="radiusType"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetLowestPoint(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            The lowest point in the channel (marker 2).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetLeftLeveeBank(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            The left levee bank (marker 1)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetRightLeveeBank(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            The right levee bank (marker 3).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetLeftLowFlowBank(DHI.Mike1D.CrossSectionModule.CrossSectionPoint)">
            <summary>
            The left low flow bank (marker 4).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetRightLowFlowBank(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            The right low flow bank (marker 5).
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetDefaultMarkers">
            <summary>
            Set default markers if missing. This will set marker 1, 2 and 3, i.e., the lowest
            point and left/right levee bank.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetDefaultMarkers(DHI.Mike1D.CrossSectionModule.XSBaseRaw)">
            <summary>
            Set default markers if missing. This will set marker 1, 2 and 3, i.e., the lowest
            point and left/right levee bank.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.GetCrossSection">
            <summary>
            Get a finished cross section from the builder. Checks whether cross section
            has been build correctly and throws an exception if not.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetEquidistantProcessingLevelSpecs(DHI.Mike1D.CrossSectionModule.XSBaseRaw,System.Int32)">
            <summary>
            Sets equidistant processinglevel specs similar to those set in a MU setup
            Builder pattern: Builds xsBaseRaw.
            </summary>
            <param name="xsBaseRaw">Base cross section to set specs to</param>
            <param name="nLevels">Number of equidistant layers</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionFactory.SetEquidistantProcessingLevelSpecs(DHI.Mike1D.CrossSectionModule.XSBaseRaw,System.Int32,System.Double,System.Double)">
            <summary>
            Sets equidistant processinglevel specs similar to those set in a MU setup. 
            Use when the minimum and maximum Z-value of the raw data is known.
            Builder pattern: Builds xsBaseRaw.
            </summary>
            <param name="xsBaseRaw">Base cross section to set specs to</param>
            <param name="nLevels">Number of equidistant layers</param>
            <param name="minZ">Minium z-value of raw data</param>
            <param name="maxZ">Maximum z-value of raw data</param>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities">
            <summary>
            A number of algorithms, that are not currently used, and therefor placed here
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities.GetResistance(DHI.Mike1D.CrossSectionModule.XSBaseRaw,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint,DHI.Mike1D.CrossSectionModule.CrossSectionPointList)">
            <summary>
            Returns resistance factor, accounting for the owning cross section's 
            ResistanceDistribution (if there is an owning cross section, otherwise
            return the distributed value). The EUM unit and type depend on the 
            cross section's ResistanceFormulation!. Several additional special issues, 
            see remarks!
            </summary>
            <remarks>
            For Uniform or Zones, the resistance factor is dependent also on markers'
            positions within the entire cross section, so it must be computed on the fly.
            In either case, if left and right levee bank markers (1 and 3) are not both
            defined or lie on the same point, the default value of 1.0 is returned.
            Another thing: The leftmost resistance is meaningless for the engine.
            This code replaces the XSOpen.UpdateResistanceXXX methods in the MZ code.
            Those were more efficient, but there was a risk of the Point returning a
            wrong value if the Update method hadn't been called before for the entire
            cross section. The most inefficient part, for Zones resistance distribution,
            is hardly ever used in M11.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities.GetIntermediatePoint(DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionPointList,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint,System.Double,System.Boolean)">
            <summary>
            Returns a point within this cross section, if need be by interpolating neighbors. 
            Any interpolated point will have (1) Interpolated = true; (2) Owner = null; (3)
            Zone = that of the right neighbor (following convention); 
            (4) Z and Resistance from linear interpolation relative to transversalRelativeDistance. If there
            are multiple points at that position ("vertical wall"), return their average.
            </summary>
            <param name="list">List that the left and right points belong to</param>
            <param name="pointLeft">reference point on the left. OK if null, then the
            interpolation will return a Clone of the right point (if that is non-null)</param>
            <param name="pointRight">reference point on the left. OK if null, then the
            interpolation will return a Clone of the left point (if that is non-null)</param>
            <param name="transversalRelativeDistance">transversal relative location between left and right point
            for which the interpolation is desired (0 = left point, 1 = right point; 
            outside 0..1: implies extrapolation and thus not recommended.</param>
            <param name="interpolateAlways">If false, and if there is a point already on the
            <param name="owner">Owner of this cross section point</param>
            position, return a Clone of that. If true, interpolate always.</param>
            <returns>interpolated point</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities.GetPointsBetween(DHI.Mike1D.CrossSectionModule.CrossSectionPointList,System.Int32,System.Int32)">
            <summary>
            Return the points between 2 markers (user or predefined), or left/right of
            a marker
            </summary>
            <param name="list">Source list of cross section points.</param>
            <param name="leftMarker">either a PreDefinedMarker, other int (user marker),
            or -1 (no left bound)</param>
            <param name="rightMarker">either a PreDefinedMarker, other int (user marker),
            or -1 (no right bound)</param>
            <returns>array of points, all non-marked. Can be empty.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities.GetDistanceBetween(DHI.Mike1D.CrossSectionModule.CrossSectionPointList,System.Int32,System.Int32)">
            <summary>
            get the transversal distance (on the x axis) between 2 markers or left/right of
            a marker [meter]. If the requested marker(s) do(es) not exist, return 
            COMMath.DOUBLE_NaN. The returned value will be negative if the supposedly
            right marker is actually on the left.
            </summary>
            <param name="list">List of points</param>
            <param name="leftMarker">either a PreDefinedMarker, other int (user marker),
            or -1 (no left bound)</param>
            <param name="rightMarker">either a PreDefinedMarker, other int (user marker),
            or -1 (no right bound)</param>
            <returns>length [m]</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities.GetRelativeTransversalPosition(DHI.Mike1D.CrossSectionModule.CrossSectionPoint,DHI.Mike1D.CrossSectionModule.CrossSectionPointList)">
            <summary>
            returns relative x position on owning cross section point list, with 
            0 = leftmost x and 1 = rightmost x. If there is only 1 point, return 0.
            Exception if there is no owner.
            </summary>
            <returns>0..1</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities.IsRightOf(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint,System.Int32,DHI.Mike1D.CrossSectionModule.CrossSectionPointList)">
            <summary>
            returns true iff this point is to the right of a given marker. If the
            point list that this point is part of does not contain the given marker,
            return false as well. Exception if there is no owning cross section.
            </summary>
            <param name="point">List of points</param>
            <param name="marker">the reference marker</param>
            <param name="owner">List which owns this point</param>
            <returns>true iff to the right</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities.IsLeftOf(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint,System.Int32,DHI.Mike1D.CrossSectionModule.CrossSectionPointList)">
            <summary>
            returns true iff this point is to the left of a given marker. If the
            point list that this point is part of does not contain the given marker,
            return false as well. Exception if there is no owning cross section.
            </summary>
            <param name="point">The point to check</param>
            <param name="marker">the reference marker</param>
            <param name="owner">The list which owns this point</param>
            <returns>true iff to the left</returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.Processing">
            <summary>
            Class containing various methods that can be utilized when processing data.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.Processing.UseM11Prcca">
            <summary>
            Use m11prcca for processing cross section. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.CalculateProcessedData(DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            m1dprcca processing of raw data
            </summary>
            <param name="xsBase"></param>
            <param name="diagnostics"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.TestLevel(DHI.Mike1D.CrossSectionModule.Processing.LevelTestType,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Double,System.Double)">
            <summary>
            Test level's significance using test type (conveyance or flow width)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.CalculateRawOpen(System.Double,System.Double@,System.Double@,System.Double@,System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            Calculate area, width, amd radius in open cross section at given water level by integrating over raw data x, z 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.ConvertDarcyWeisbachToChezy(System.Double,System.Double)">
            <summary>
            Converts from the Darcy Weisbach equivalent sand roughness to
            the Chezy roughness number.
            </summary>
            <param name="sandRough">Also called equivalent grain diameter, k_s</param>
            <param name="rad">Hydraulic radius</param>
            <returns>Chezy number</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.CalculateAreas(System.Double[],DHI.Mike1D.CrossSectionModule.XSBase)">
            <summary>
            Calculate the area below the given water levels by integrating up the 
            storage widths of the processed data, or if the provided cross section has
            raw data, these are used instead to calculate the areas.
            </summary>
            <param name="hs">Water levels to calculate areas at. Assuming water levels are increasing and in the range of the raw data</param>
            <param name="xs">Cross section with raw data</param>
            <returns>Areas for each level</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.CalculateAreasFromWidths(System.Double[],DHI.Mike1D.CrossSectionModule.XSBase)">
            <summary>
            Calculate the area below the given water levels by integrating up the 
            storage widths of the processed data.
            </summary>
            <param name="hs">Water levels to calculate areas at. Assuming water levels are increasing and in the range of the raw data</param>
            <param name="xs">Cross section with raw data</param>
            <returns>Areas for each level</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.CalculateAreasFromRaw(System.Double[],DHI.Mike1D.CrossSectionModule.XSBaseRaw)">
            <summary>
            Calculate the area below the given water levels using the
            raw points of the cross section.
            </summary>
            <param name="hs">Water levels to calculate areas at. Assuming water levels are in the range of the raw data</param>
            <param name="xs">Cross section with raw data</param>
            <returns>Areas for each level</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.CalculateArea(System.Double,System.Collections.Generic.IList{DHI.Mike1D.CrossSectionModule.ICrossSectionPoint},System.Double)">
            <summary>
            Calculate the area below the given water level for the
            raw cross section points
            </summary>
            <param name="h">Water levels to calculate areas at. Assuming water levels are in the range of the raw data</param>
            <param name="xsPoints">Cross section raw data points</param>
            <param name="xScale">Factor to scale x-values with, in case cross section is not perpendicular to river.</param>
            <returns>Areas for each level</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.GetPointsBetweenMarker1And3(DHI.Mike1D.CrossSectionModule.XSBaseRaw)">
            <summary>
            Get all cross section points between marker 1 and marker 3, those included, i.e. all points
            within the active part of the cross section.
            </summary>
            <param name="xsBaseRaw"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.SortPointsWithTopFirst(DHI.Mike1D.CrossSectionModule.CrossSectionPointList)">
            <summary>
            Order cross section points such that the point with the highest z-value comes first.
            <para>
            This is utilized by closed cross sections, to go from highest point, counterclockwise round to highest point again.
            </para>
            <para>
            An additional endpoint at the top may be add, such that the first and last cross section point are identical.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Processing.FindTopPointIndex(DHI.Mike1D.CrossSectionModule.CrossSectionPointList)">
            <summary>
            Find index of cross section point with highest z-value
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ProcessingSimple">
            <summary>
            Small class that does the storage width and flow area processing
            (total area) in the most simple way.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ProcessingSimple.#ctor(DHI.Mike1D.CrossSectionModule.XSBaseRaw)">
            <summary>
            Constructor, including cross section to process
            </summary>
            <param name="xs"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ProcessingSimple.Process(System.Double[])">
            <summary>
            Process cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingSimple.ProcessedStorageWidth">
            <summary> Processed storage widths </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingSimple.ProcessedArea">
            <summary> Processed areas </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingSimple.ProcessedHydraulicRadius">
            <summary> Processed Hydraulic radia </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingSimple.ProcessedWettedPerimeter">
            <summary> Processed wetted perimeter </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ReachCrossSections">
            <summary>
            Class containing all crossSections for one reach/topo-id combination. It can either contain
            one global cross section (the MikeUrban way, ID based), or a set of crosssections, sorted 
            on chainage (the Mike11 way, ID+chainage based). In case of a set of cross-sections, each
            cross section must have a valid Location.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ReachCrossSections.#ctor(DHI.Mike1D.CrossSectionModule.CrossSectionData.CSID,System.Boolean)">
            <summary>
            Construct new cross-section set. Use argument true, if this is to hold 
            one global cross section, and false if it is to hold a set of chainge sorted cross sections.
            
            </summary>
            <param name="csid">id of reach and topo id</param>
            <param name="useGlobalCrossSection">True if this only is to contain one global cross section</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ReachCrossSections.#ctor(DHI.Mike1D.CrossSectionModule.CrossSectionData.CSID,DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
            Construct new cross section set consisting of one global cross section
            </summary>
            <param name="csid">id of reach and topo id</param>
            <param name="globalCrossSection"></param>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ReachCrossSections.ReachId">
            <summary>
            Reach-Id of all reaches in this object
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ReachCrossSections.TopoId">
            <summary>
            Topo-Id of all reaches in this object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ReachCrossSections.IsGlobal">
            <summary>
            Returns true if this set holds only one global cross section
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ReachCrossSections.ToGlobal">
            <summary>
            Make this contain a reach global cross section. All
            currently stored local cross sections will be removed
            from this class.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ReachCrossSections.Count">
            <summary>
            Number of cross sections in reach
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ReachCrossSections.GlobalCrossSection">
            <summary>
            Get/Set the global cross-section.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ReachCrossSections.GetChainageSortedCrossSections">
            <summary>
            If set is not global, return the list of chainage sorted cross sections. Otherwise null.
            </summary>
            <returns>A SortedDictionary, sorted on chainage</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ReachCrossSections.Add(DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Add cross section to set. This will fail if set is global.
            </summary>
            <param name="cs">Cross section to add to set</param>
            <param name="diagnostics">Diagnostics object to report issues to.</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ReachCrossSections.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ReachCrossSections.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.TopSlotAngle">
            <summary>
            Top slot that returns value corresponding to adding vertical walls
            approaching infinity
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.TopSlotAngle._slotStartDepth">
            <summary>
            Depth where the slot is used
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.TopSlotAngle._crossSection">
            <summary>
            Cross section that slot is attached to.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double)">
            <summary>
             Construct and initialize AbstractBottomSlot
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.TopSlotAngle.Angle">
            <summary>
            Angle of the slot with vertical. Both side angle out, ie, the angle is positive if
            the sides angle away from then center and negative if they angle in toward the center.
            Unit: degrees
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetStorageWidth(System.Double)">
            <summary>
            Returns the width of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Width of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Returns the additional storage area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetFlowAreaDerivative(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetFlowArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetRadius(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetRadiusDerivative(System.Double)">
            <summary>
            Get the derivate of the hydraulic radius at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetResistanceFactor(System.Double)">
            <summary>
            Resistance factor for the given water level.
            This will always return absolute resistance values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
            <remarks>
            This is presently always the value at the top of the slot (at waterLevel = ICrossSection.ZMin+slotStartDepth)
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotAngle.Validate">
            <summary>
            Validate the object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.InterpolateXSLocated.GetIntermediateCrossSection(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Interpolate between the two CrossSectionLocated. Only fields of the 
            CrossSectionLocated is interpolated. Remaining fields are left 
            blank/null, as e.g. BaseCrossSection
            </summary>
            <param name="location">Location for new CrossSectionLocated</param>
            <param name="xsBefore">CrossSectionLocated before location</param>
            <param name="xsAfter">CrossSectionLocated after location</param>
            <param name="diagnostics">Diagnostics instance for reporting errors. Can be null.</param>
            <returns>A new CrossSectionLocated at the given location</returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.InterpolateXS">
            <summary>
            Handles interpolation between two CrossSectionLocated, also interpolates in the BaseCrossSections.
            Handles the non-raw cross sections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.InterpolateXS.GetIntermediateCrossSection(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.CrossSectionModule.CrossSectionLocated,DHI.Mike1D.CrossSectionModule.CrossSectionLocated,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Interpolate between the two CrossSectionLocated, also interpolates in the BaseCrossSection
            
            Handles:
            - <see cref="T:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed"/>
            - <see cref="T:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed"/>
            - <see cref="T:DHI.Mike1D.CrossSectionModule.XSRectangular"/>
            
            The two cross sections must be of the same type.
            </summary>
            <param name="location">Location for new CrossSectionLocated</param>
            <param name="xsBefore">CrossSectionLocated before locatino</param>
            <param name="xsAfter">CrossSectionLocated after location</param>
            <param name="diagnostics">Diagnostics instance for reporting errors. Can be null.</param>
            <returns>A new CrossSectionLocated at the given location</returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed">
            <summary>
            Closed Circular Cross Section with preprocessed data. There are
            several different types of circular cross sections:
             - Circular.
             - Egg-shaped circular.
             - O-shaped circular.
            
            For the O-shaped cross section the <see cref="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.Height"/> is 9/8*diameter
            
            The preprocessed data contains a slot up to a height of 1.5 
            times the diameter. Hence, the <see cref="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.TopLevel"/> does not equal 
            <see cref="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.BottomLevel"/> plus the diameter/height.
            </summary>
            <remarks>
            The (pre)processed data are scaled with the diameter, i.e., 
            the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedStorageWidths"/> are storage widths
            for a circular cross section with diameter 1. 
            
            Do not update in the processed data, since that will change the 
            processed data for all cross sections of this type.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.#ctor(System.Double,DHI.Mike1D.Generic.StandardCrossSectionType)">
            <summary>
            Constructs a circular CrossSection and sets the diameter
            </summary>
            <param name="diameter">Cross section diameter</param>
            <param name="Type">Cross section type</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.Clone">
            <summary>
            Returns a deep clone. Note: Does not clone any children
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.Prepare(DHI.Mike1D.Generic.Diagnostics,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.ILocation)">
            <summary>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.Validate">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetResistanceFactorsDerivative(System.Int32,System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetFlowArea(System.Int32,System.Double)">
            <summary>
            Gets the flow area
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetArea(System.Int32,System.Double)">
            <summary>
            Gets the flow area, calculated so that the area derivative is smooth
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetLevelFromArea(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetHydraulicRadius(System.Int32,System.Double)">
            <summary>
            Gets the radius;
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetStorageWidth(System.Int32,System.Double)">
            <summary>
            Returns the storage width
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
            <remarks>
            The critical depth can not be larger than the <see cref="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.Height"/>.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetNaturalDepthBase(System.Double,System.Double)">
            <summary>
            Same results as <see cref="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetNaturalDepth(System.Double,System.Double)"/>, 
            when manning is uniform (no depth dependence). Otherwise
            results will differ slightly.
            
            This version is more "correct", since calculate the max conveyance
            based on MAR23 and limits the value of MAR23, while the <see cref="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetNaturalDepth(System.Double,System.Double)"/>
            does it only on AR23. Hence results will differ when manning varies with depth.
            
            However, with the <see cref="F:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed._relativeAR23"/> table it is possible to do binary search
            (currently linear search)
            
            </summary>
            <param name="discharge"></param>
            <param name="slope"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetNaturalDepth(System.Double,System.Double)">
            <summary>
            Get the natural depth at a given discharge and slope
            </summary>
            <param name="discharge">Discharge to find depth for</param>
            <param name="slope">Slope to use in calculations</param>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.Diameter">
            <summary>
            Gets and sets the diameter of the pipe
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.Height">
            <summary>
             Height of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.MaximumStorageWidth">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.BottomLevel">
            <summary>
             Lowest level of the processed data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.BottomLevelFromCenter(System.Double)">
            <summary>
            Return the bottom level of the cross section at a distance dx from 
            the center of the cross section. Throws an exception if dx is larger than 
            half the cross section width.
            </summary>
            <param name="dx"></param>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.TopLevel">
            <summary>
             Highest level/depth of the processed data. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.CoefficientsType">
            <summary>
            Gets or sets the type of coefficents to use
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircularPreprocessed.GetMaximumValues(System.Double@,System.Double@,System.Double@)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed">
            <summary>
             An open rectangular cross section with preprocessed data.
             
             The preprocessed data contains a slot up to a height of 1.5 
             times the diameter. Hence, the <see cref="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.TopLevel"/> does not equal 
             <see cref="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.BottomLevel"/> plus the <see cref="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.Height"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="Height"></param>
            <param name="Width"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.Prepare(DHI.Mike1D.Generic.Diagnostics,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.ILocation)">
            <summary>
            Prepare cross section. Calculates processed data if needed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.CalculateProcessedData">
            <summary>
            Calculate processed data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.Height">
            <summary>
             Height of the cross section.
            </summary>
             <remarks>
             To get the height of the processed data, use instead
             <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.TopLevel"/>-<see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.BottomLevel"/>.
             
             For user specified cross sections, this is the difference
             between the top and bottom level of the processed data.
             For other types of cross sections, this need not be the case.
             </remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.MaximumStorageWidth">
            <summary>
             Maximum storage width of the cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.Validate">
            <summary>
            Prepare the cross section. Not implemented.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.GetFlowArea(System.Int32,System.Double)">
            <summary>
            Returns the wetted area.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.BottomLevel">
            <summary>
             Lowest level of the processed data.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.TopLevel">
            <summary>
             Lowest level of the processed data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.GetHydraulicRadius(System.Int32,System.Double)">
            <summary>
            Returns the hydraulic radius
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.GetRadiusAboveProcessed(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water depth above the processed data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.GetStorageWidth(System.Int32,System.Double)">
            <summary>
            Returns the storage width
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical discharge for a given water level
            The critical discharge is the discharge where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.RectangleWidth">
            <summary>
            Gets and sets the width. Also sets the width in any children
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.RectangleHeight">
            <summary>
            Gets and sets the width. Also sets the width in any children
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.BottomLevelFromCenter(System.Double)">
            <summary>
            Return the bottom level of the cross section at a distance dx from 
            the center of the cross section. Throws an exception if dx is larger than 
            half the cross section width.
            </summary>
            <param name="dx"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.GetMaximumValues(System.Double@,System.Double@,System.Double@)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangularPreprocessed.Clone">
            <summary>
            Returns a deep clone. Note: Does not clone any children
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSRectangular">
            <summary>
             An open rectangular cross section. Processed data is calculated by the Mike11 processing code 
             <see cref="M:DHI.Mike1D.CrossSectionModule.ProcessXSRaw.CalculateProcessedData(DHI.Mike1D.CrossSectionModule.XSBase)"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangular.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangular.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="Height"></param>
            <param name="Width"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangular.Validate">
            <summary>
            Prepare the cross section. Not implemented.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangular.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangular.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical discharge for a given water level
            The critical discharge is the discharge where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangular.RectangleWidth">
            <summary>
            Gets and sets the width. Also sets the width in any children
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangular.RectangleHeight">
            <summary>
            Gets and sets the width. Also sets the width in any children
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangular.Height">
            <summary>
             Height of the cross section.
            </summary>
             <remarks>
             To get the height of the processed data, use instead
             <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.TopLevel"/>-<see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.BottomLevel"/>.
             
             For user specified cross sections, this is the difference
             between the top and bottom level of the processed data.
             For other types of cross sections, this need not be the case.
             </remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSRectangular.MaximumStorageWidth">
            <summary>
             Maximum storage width of the cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangular.BottomLevelFromCenter(System.Double)">
            <summary>
            Return the bottom level of the cross section at a distance dx from 
            the center of the cross section. Throws an exception if dx is larger than 
            half the cross section width.
            </summary>
            <param name="dx"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSRectangular.Clone">
            <summary>
            Returns a deep clone. Note: Does not clone any children
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator">
            <summary>
            Adds slot funtionality to an ICrossSection. 
            It handles as well topslot as bottom slot.
            </summary>
            <remarks>
            Using a decorator design pattern type (itself implementing ICrossSection)
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator._crossSectionZMin">
            <summary>
            Buffering ZMin of cross section (for performance).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.CrossSection">
            <summary>
             Get the underlying cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.BottomSlotStartDepth">
            <summary>
            Start depth of the bottom slot
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
            Construct a new ICrossSection slot decorator with no bottom and top slot defined.
            Use one ore more of <see cref="!:SetBottomSlot(ISlot,double)"/>, <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SetTopSlot(DHI.Mike1D.CrossSectionModule.ITopSlot,System.Double)"/>,
            <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SetBottomSlot(DHI.Mike1D.HDParameterDataAccess.BottomSlotType,System.Double)"/>, <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SetTopSlot(DHI.Mike1D.HDParameterDataAccess.TopSlotType,System.Double)"/> 
            to add slot functionality.
            </summary>
            <param name="crossSection">Cross section to add slot functionality to.</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.#ctor(DHI.Mike1D.HDParameterDataAccess.BottomSlotType,System.Double,DHI.Mike1D.HDParameterDataAccess.TopSlotType,System.Double,DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
            Construct a new ICrossSection slot decorator with predefined bottom and top slot types.
            </summary>
            <param name="bottomSlotType">Type of bottom slot</param>
            <param name="bottomSlotStartDepth">Depth where bottom slot starts</param>
            <param name="topSlotType">Type of top slot</param>
            <param name="topSlotStartDepth">Depth where top slot starts</param>
            <param name="crossSection">Cross section to add slot functionality to.</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SetBottomSlot(DHI.Mike1D.HDParameterDataAccess.BottomSlotType,System.Double)">
            <summary>
            Set bottom slot type and start depth (where bottom slot is to start).
            </summary>
            <param name="bottomSlotType">Type of predefined bottom slot</param>
            <param name="bottomSlotStartDepth">Depth above bottom level where the slot should start</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SetBottomSlot(DHI.Mike1D.CrossSectionModule.IBottomSlot,System.Double)">
            <summary>
             Set bottom slot and start depth (where bottom slot is to start).
             if bottomSlot is null, bottom slot functionality is disabled.
            </summary>
            <param name="bottomSlot">Bottom slot to use. Must be fully initialized.</param>
            <param name="bottomSlotStartDepth">Depth above bottom level where the slot should start</param>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.TopSlot">
            <summary>
            Top slot
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SetTopSlot(DHI.Mike1D.HDParameterDataAccess.TopSlotType,System.Double)">
            <summary>
            Set top slot type and depth (where top slot is to start).
            </summary>
            <param name="topSlotType">Type of predefined top slot</param>
            <param name="topSlotStartDepth">Depth above bottom level where the slot should start</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SetTopSlot(DHI.Mike1D.CrossSectionModule.ITopSlot,System.Double)">
            <summary>
            Set top slot type and depth (where top slot is to start).
            </summary>
            <param name="topSlot">Top slot to set, must be fully initialized.</param>
            <param name="topSlotStartDepth">Depth above bottom level where the slot should start</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SetTopSlotWidth(System.Double)">
            <summary>
            Set top slot width. Only valid if top slot is of type TopSlotConstantARW. Throws an exception otherwise. 
            Used to override the default width which is the width of the cross section where the top slot begins.
            </summary>
            <param name="width"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.InBottomSlot(System.Double)">
            <summary>
            Check if we are in bottom slot.
            Returns false when no bottom slot is active.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>True if in slot.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.InTopSlot(System.Double)">
            <summary>
            Check if we are in bottom slot.
            Returns false when no bottom slot is active.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>True if in slot.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.UpdateDatum(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.UpdateSedimentArea(System.Double)">
            <summary>
            Update area of sediment and reset buffers
            </summary>
            <param name="sedimentArea"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetArea(System.Double)">
            <summary>
            Return the cross sectional geometric area, 
            at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetFlowArea(System.Double)">
            <summary>
            Return the cross sectional flow area, 
            at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetFlowAreaTotal(System.Double)">
            <summary>
            Return the total cross sectional flow area, 
            at the given water level, i.e. including sedimented area
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetFlowAreaWithoutBottomSlot(System.Double)">
            <summary>
            Return the cross sectional area, also called the flow area, 
            at the given water level.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.ResistanceFormulation">
            <summary>
            The ResistanceFormulation that is used for this crossSection and stored in the processed data.
            <para>
            This may differ from the ones specified in the <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.Formulation"/>, which
            is the formulation for the raw data.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetConveyance(System.Double)">
            <summary>
            Get the conveyance at the specified water level
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Additional storage area is a volume that the mass equation takes
            into account, but it does not influence the momentum equation. It
            could be a small pond next to the river that is filled/emptied as
            the water level in the river raises/falss.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetVolumeFromAdditionalSurfaceArea(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.HasBottomSlot">
            <summary>
             Returns true if the decorator has a bottom slot
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetStorageWidth(System.Double)">
            <summary>
            Returns the width from left bank to right bank at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetHydraulicRadius(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            The radius are calculated as one of : todo: check:
            Resistance Radius.
            Effective area, hydraulic radius
            Total area, hydraulic radius.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetHydraulicRadiusDerivative(System.Double)">
            <summary>
            Get the derivate of the hydraulic radius at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetResistanceFactor(System.Double)">
            <summary>
            Resistance factor for the given water level.
            This will always return absolute resistance values.
            </summary>
            <param name="waterLevel"></param>
            <remarks>Conversion from relative to absolute is handled in the prepare step</remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.ResistanceFactorProportionality">
            <summary>
            A proportionality factor that is multiplied with the resistance factor. 
            ResistanceFactorProportionality is used by the resistance factor
            boundaries to adjust the resistance factor.
            Default value: 1.0
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Validate">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Ensures that the resistance fomulation is not relative. If the resistance fomulation is 
            Mannings n it is changed to Mannings M and the data are changed accordingly if the resistance 
            formulation is Darcy Weisbach formulation and data are changed to Chezy.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.BaseCrossSection">
            <summary>
             Base cross section. The base cross section has no location and holds
             data in depth, not in water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical discharge for a given water level
            The critical discharge is the discharge where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetNaturalDepth(System.Double,System.Double)">
            <summary>
            Gets the Natural depth for a given discharge [m3/s] and slope [dimensionless]
            The natural depth is the depth where the flow resistance and velocity
            balances, i.e., the Manning formula is fullfilled: Q = M*A*R^(2/3)*sqrt(I)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.TopoID">
            <summary>
            The TopoID set that this cross section belongs to. TODO: See where for details?
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Info">
            <summary>
            Generel info on this cross section, user specified, can be empty. In
            Mike11 XNS editor called cross section ID (though it does not identify 
            the cross section)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.ZMax">
            <summary>
            The maximum value of Z in the cross section. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.ZMin">
            <summary>
            The minimum value of Z in the cross section (bottom level)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.ZMinFromCenter(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Height">
            <summary>
             Height of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.MaximumWidth">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.MinWaterDepth">
            <summary>
             Minimum water depth of the cross section.
             <para>
             If the water depth goes below this depth, it will be corrected
             to match this depth.
             </para>
             <para>
             This can be negative, in case the cross 
             section has a slot attached.
             </para>
            </summary>
             <para>
             In case of no slot, it is set by the <see cref="P:DHI.Mike1D.HDParameterDataAccess.SolverSettings.MinWaterDepth"/>, 
             see there for details.
             </para>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Location">
            <summary>
            Defines the location of the current cross section. The Z-coordinate
            is the bottom level of the cross section (unless defined by the
            raw data (the open cross sections)).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Interpolated">
            <summary>
            Returns true if the CrossSection is interpolated from other cross sections
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.ApplyCoordinates">
            <summary>
            Flag specifying whether the <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Coordinates"/> is to be applied or ´not
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Coordinates">
            <summary>
            Gets or sets the cross section coordinates, i.e., the geographical coordinates
            of line that the cross section follows.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.IsOpen">
            <summary>
             Return true if the cross section is open
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SedimentResistanceFactor">
            <summary>
            Sediment resistance factor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SedimentWidth">
            <summary>
            Width of sediment surface layer.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.SedimentArea">
            <summary>
            Xs area of stored sediment. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetFlowAreaDerivative(System.Double)">
            <summary>
            Get storagewidth as dA/dh from neighboring values in processed XS areas at waterLevel
            This is how M11 does it - ONLY USED IN M11 SCHEME WHEN COMPARING DIRECTLY WITH M11 RESULTS
            Only implemented in XSOpen for now
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Initialize">
            <summary>
             Initialize cross section. Calculates processed data if needed.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than obj. Zero This instance is equal to obj. Greater than zero This instance is greater than obj. 
            </returns>
            
            <param name="obj">An object to compare with this instance. </param>
            <exception cref="T:System.ArgumentException">obj is not the same type as this instance. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Extrapolate(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Returns an extrapolated CrossSection, i.e., a copy of this cross
            section at the new location.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.GetFrictionValuesNoBottomSlot(System.Double,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Values required to calculate friction factor for higher order friction term
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionSlotDecorator.CreateSlotDecorator(DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Create a slot decorator for the cross section.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ISlot">
            <summary>
             Interface to slots.
             
             A slot is not responsible for checking whether the water level argument is
             valid for the slot. Such a check should be done before using the slot.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.GetStorageWidth(System.Double)">
            <summary>
            Returns the width of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Width of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.GetFlowArea(System.Double)">
            <summary>
            Returns the flow area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.GetFlowAreaDerivative(System.Double)">
            <summary>
            Returns the flow area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Returns the additional storage area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.GetRadius(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.GetRadiusDerivative(System.Double)">
            <summary>
            Get the derivate of the hydraulic radius at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.GetResistanceFactor(System.Double)">
            <summary>
            Resistance factor for the given water level.
            This will always return absolute resistance values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ISlot.Validate">
            <summary>
            Validate the object
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ITopSlot">
            <summary>
             Interface to a top slot.
             
             A slot is not responsible for checking whether the water level argument is
             valid for the slot. Such a check should be done before using the slot.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ITopSlot.GetArea(System.Double)">
            <summary>
            Returns the geometric area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ITopSlot.MoveSlot(System.Double)">
            <summary>
            Move slot up or down with given deltaZ.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.IBottomSlot">
            <summary>
             Interface to a top slot.
             
             A slot is not responsible for checking whether the water level argument is
             valid for the slot. Such a check should be done before using the slot.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.IBottomSlot.MoveSlot(System.Double)">
            <summary>
            Move slot up or down, to match the specified bottom level.
            <para>
            For bottom slots, initially the bottom level is set to <see cref="P:DHI.Mike1D.CrossSectionModule.ICrossSection.ZMin"/>
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW">
            <summary>
             Top slot that returns area, radius and width
             as the value at the slot start level.
             
             If no top slot start level is defined, the crossSection.ZMax is used
             as start level.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW._slotStartLevel">
            <summary>
            level where the slot is used
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW._crossSection">
            <summary>
            Cross section that slot is attached to.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW._constantWidth">
            <summary>
            Constant width to use
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
             Construct and initialize the topslot.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double)">
            <summary>
             Construct and initialize the topslot.
            </summary>
             <param name="crossSection">Cross section that the slot is attached to</param>
             <param name="slotStartDepth">Depth where the top slot should take over</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double,System.Double)">
            <summary>
             Construct and initialize AbstractBottomSlot.
             
             This constructor overrides the constant width from the cross seciton
             with the specified width.
            </summary>
             <param name="crossSection">Cross section that the slot is attached to</param>
             <param name="slotStartDepth">Depth where the top slot should take over</param>
             <param name="constantWidth">Constant width to use in top slot.</param>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.ConstantWidth">
            <summary>
            Constant width to use
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.GetStorageWidth(System.Double)">
            <summary>
            Returns the width of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Width of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.GetArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.GetFlowArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Returns the additional storage area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.GetRadius(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.GetRadiusDerivative(System.Double)">
            <summary>
            Get the derivate of the hydraulic radius at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.GetResistanceFactor(System.Double)">
            <summary>
            Resistance factor for the given water level.
            This will always return absolute resistance values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotConstantARW.Validate">
            <summary>
            Validate the object
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.TopSlotVertical">
            <summary>
            Top slot that returns value corresponding to adding vertical walls
            approaching infinity.
            
            Width stays constant.
            Area grows with width*height_in_slot.
            Radius grows with height in in slot.
            Resistance factor remains constant.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.TopSlotVertical._slotStartLevel">
            <summary>
            level where the slot is used
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.TopSlotVertical._crossSection">
            <summary>
            Cross section that slot is attached to.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.TopSlotVertical._storageWidth">
            <summary>
            Width of cross section where slot begins
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
             Construct and initialize top slot. The slot starts where
             the cross section ends (ZMax)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.#ctor(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double)">
            <summary>
             Construct and initialize AbstractBottomSlot
            </summary>
             <param name="crossSection">Cross section that the slot is attached to</param>
             <param name="slotStartDepth">Depth where the slot starts. Must be smaller than crossSection ZMax-ZMin</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.GetStorageWidth(System.Double)">
            <summary>
            Returns the width of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Width of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Returns the additional storage area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.GetArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.GetFlowArea(System.Double)">
            <summary>
            Returns the area of the slot given the water level.
            </summary>
            <param name="waterLevel">Water level</param>
            <returns>Cross sectional area of the slot</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.GetRadius(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.GetRadiusDerivative(System.Double)">
            <summary>
            Get the derivate of the hydraulic radius at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.GetResistanceFactor(System.Double)">
            <summary>
            Resistance factor for the given water level.
            This will always return absolute resistance values.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.TopSlotVertical.Validate">
            <summary>
            Validate the object
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSBase">
            <summary>
            Base class for crossSections. Holds processed data.
            <para>
            The most common case is that <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.BottomLevel"/> is zero, 
            meaning that the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedLevels"/> are depth based.
            However, this is not a requirement.
            </para>
            <para>
            Can hold equidistant as well as non-equidistant processed data,
            <see cref="F:DHI.Mike1D.CrossSectionModule.XSBase._equidistantLevels"/>.
            In case of equidistant, the processed levels always start
            at zero, i.e., the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.BottomLevel"/> is always zero (depth based).
            </para>
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._bAutoProcess">
            <summary>
            Allow CalculateProcessedDataIfNeeded. Set to false to disable
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.AutoProcess">
            <summary>
            Automatically calculate processed data if
            1) They are missing
            2) They are not up-to-date (<see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedDataStatus"/> is <see cref="F:DHI.Mike1D.Generic.ProcessedDataStatus.NotUpdated"/>)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._isInitialized">
            <summary>
            Flag defining whether <see cref="M:DHI.Mike1D.CrossSectionModule.XSBase.Initialize"/> has been called.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._isPrepared">
            <summary>
            Flag defining whether <see cref="M:DHI.Mike1D.CrossSectionModule.XSBase.Prepare(DHI.Mike1D.Generic.Diagnostics,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.ILocation)"/> has been called.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._interpolated">
            <summary>
            True if the CrossSection is interpolated by the engine from other cross sections, i.e. it
            is not part of the original data.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedData">
            <summary>
            Internal helper class for storing a complete set of processed data
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedData.Levels">
            <summary> Levels </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedData.StorageWidths">
            <summary> Storage widths </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedData.Areas">
            <summary> Geometric areas </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedData.FlowAreas">
            <summary> Flow areas </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedData.Radii">
            <summary> Hydraulic radii </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedData.ResistFactors">
            <summary> Resistance factors/numbers </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedData.AdditionalSurfaceAreas">
            <summary> Additional surface areas </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._originalProcessedData">
            <summary>
            A copy of original processed data, in case they have
            been modified by the engine during the simulation.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._modifiedFormulation">
            <summary>
            Flow resistance formulation
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._modifiedResistanceFactors">
            <summary>
            Modified resistance factors. As default points to <see cref="F:DHI.Mike1D.CrossSectionModule.XSBase._processedResistanceFactors"/>, 
            but during simulation contains resistance factors that are supported by the engine, which may
            differ from the original values.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._modifiedResistanceFactorsDerivatives">
            <summary>
            Processed resistance factor derivatives for the modified resistance factors.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._equidistantLevels">
            <summary>
            Flag to indicate whether equidistant levels are used. 
            If equidistant levels are used, then getIndex and getFraction are faster.
            Each derived cross section must set this flag to true (during construction), 
            if it does not store levels in the <see cref="F:DHI.Mike1D.CrossSectionModule.XSBase._processedLevels"/> array.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._distanceBetweenLevels">
            <summary>
            The distance between levels if equidistant levels are ued.
            If equidistant levels are used, then getIndex and getFraction are faster.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedDataStatus">
            <summary>
            ProcessingStatus defines the status of the processed data of this cross section.
            Whenever the user updates raw data of the cross section, its state must be changed
            to NotUpdated.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._bProcessedDataProtected">
            <summary>
            false: data are not protected and will be recomputed. 
            true: processed data are protected, data has been manually updated and will not be recomputed.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._crossSectionType">
            <summary>
            Type of cross section.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._flowResistance">
            <summary>
            Flow resistance
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._resistenceDistri">
            <summary>
            Resistance distribution
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._numberOfProcessedLevels">
            <summary>
            The number of processed levels
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._procLevelsSpecs">
            <summary>
            Specifications for how to process levels
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedDerivatives">
            <summary>
            Flag specifying whether processed derivatives are stored
            as processed data arrays, or calculated directly. If true,
            processed data arrays for the derivatives are created 
            (most accurate, smooth interpolation)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedDerivatives">
            <summary>
            Flag specifying whether processed derivatives are stored
            as processed data arrays, or calculated directly. If true,
            processed data arrays for the derivatives are created 
            (most accurate, smooth interpolation)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedLevels">
            <summary>
            Processed depths
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedAreas">
            <summary>
            Processed geometric areas
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedFlowAreas">
            <summary>
            Processed flow ares
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.NumberOfProcessedLevels">
            <summary>
            returns the number of processed levels (same as dimension of all processed data
            arrays). Returns 0 if processed data have not been calculated, yet.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedRadii">
            <summary>
            Processed radii
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedRadiiDerivatives">
            <summary>
            Processed radius derivatives
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedStorageWidths">
            <summary>
            Processed storage widths
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedAdditionalSurfaceAreas">
            <summary>
            Processed additional storage areas
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedResistanceFactors">
            <summary>
            Processed resistance factors
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBase._processedCriticalDischarges">
            <summary>
            Table with processed critical discharges, created automatically when required.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.TopoID">
            <summary>
            The TopoID set that this cross section belongs to. TODO: See where for details?
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.Interpolated">
            <summary>
            Returns true if the CrossSection is interpolated from other cross sections
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.CrossSectionType">
            <summary>
             Type of cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.EquidistantLevels">
            <summary>
            Flag to indicate whether equidistant levels are used. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.Height">
            <summary>
             Height of the cross section.
            </summary>
             <remarks>
             To get the height of the processed data, use instead
             <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.TopLevel"/>-<see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.BottomLevel"/>.
             
             For user specified cross sections, this is the difference
             between the top and bottom level of the processed data.
             For other types of cross sections, this need not be the case.
             </remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.BottomLevel">
            <summary>
             Lowest level/depth of the processed data.
             Note: ProcessedLevels must be defined
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.TopLevel">
            <summary>
             Highest level/depth of the processed data. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedDataStatus">
            <summary>
            ProcessingStatus defines the status of the processed data of this cross section.
            Whenever the user updates raw data of the cross section, its state must be changed
            to NotUpdated.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedDataProtected">
            <summary>
            false: data are not protected and will be recomputed. 
            true: processed data are protected, data has been manually updated and will not be recomputed.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.IsOpen">
            <summary>
             Return true if cross section is open
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedFormulation">
            <summary>
            Gets the Resistance Formulation that matches
            the <see cref="M:DHI.Mike1D.CrossSectionModule.XSBase.GetResistanceFactor(System.Int32,System.Double)"/> value.
            <para>
            This is not necessarily the same as in 
            <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.FlowResistance"/>. but can be different for several reasons:
            a) The raw and processed data differ, as for <see cref="F:DHI.Mike1D.Generic.ResistanceFormulation.DarcyWeisbach"/>.
            b) The resistance factors have been modified, and values used are those in <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.FlowResistance">
            <summary>
             Flow resistance. Contains information on flow resistance type 
             (ManningM or Chezy, Z dependence etc) and flow resistence values.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedLevels">
            <summary>
             Processed levels
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedAreas">
            <summary>
             Processed geometric areas
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedFlowAreas">
            <summary>
             Processed flow areas
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedRadii">
            <summary>
             Processed radii
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedRadiiDerivatives">
            <summary>
             Processed radii
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedStorageWidths">
            <summary>
             Processed storage widths
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors">
            <summary>
             Processed resistance factors. Their type corresponds to the 
             Resistance formulation specified in <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.FlowResistance"/>.
            </summary>
            <remarks>
             These factors will not be changed if any of the convert functions are
             called. The result of the convert functions are stored in 
             <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors">
            <summary>
             Modified resistance factors. These will be different than <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/>
             if one of the Multiply functions has been executed. This is matching the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedFormulation"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedAdditionalSurfaceAreas">
            <summary>
             Processed additional storage area
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessingLevelsSpecs">
            <summary>
            Access to all level-related specifications for pre-processing of cross section
            data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.MorphologicalDivisionType">
            <summary>
            Specifies the type of morphological division 
            that is applied.
            <para>
            For ST modeling only.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.MorphologicalDivision">
            <summary>
            When <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.MorphologicalDivisionType"/> is <see cref="F:DHI.Mike1D.Generic.MorphologicalDivisionType.Level"/>,
            specifies the level of morphological division 
            <para>
            For ST modeling only.
            </para>
            <para>
            Level is relative to raw data, and must not include any datum offset
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetActualMorphologicalDivision">
            <summary>
            Get actual morphological division or top of cross section if not defined.
            </summary>
            <returns>Actual morphological division</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedLevel(System.Int32)">
            <summary>
            Get the processed level at the given index. Works
            regardless of the <see cref="F:DHI.Mike1D.CrossSectionModule.XSBase._equidistantLevels"/> flag, 
            i.e., also when <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedLevels"/> are not present. 
            
            Index must be between 0 and <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.NumberOfProcessedLevels"/>-1
            otherwise it will fail or give incorrect results
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.SetAllProcessedValues(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
            set all the processed data (references to the member array).
            All values are in SI.
            </summary>
            <param name="levels">the processed levels. All other arrays must have same
              dimension and contain values for each processed level.</param>
            <param name="storageWidths">the processed storage widths</param>
            <param name="flowAreas">The processed cross-sectional geometric areas</param>
            <param name="radii">the processed radii</param>
            <param name="resistFactors">the processed resistance factors. Can b</param>
            <param name="additionalSurfaceAreas">the processed additional storage areas</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.SaveOriginalProcessedData">
            <summary>
            Store the current processed data arrays (shallow copy). 
            If a set of original processed data already exists, the original 
            set is kept and not overwritten. 
            <para>
            Updating the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedLevels"/> will still update the
            original processed data, unless new processed data has been provided,
            i.e. by using <see cref="M:DHI.Mike1D.CrossSectionModule.XSBase.CreateAllProcessedArrays(System.Int32)"/> or <see cref="M:DHI.Mike1D.CrossSectionModule.XSBase.SetAllProcessedValues(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])"/>,
            due to the shallow copy.
            </para>
            <para>
            The original processed data arrays are kept when setting
            new processed data, using e.g. <see cref="M:DHI.Mike1D.CrossSectionModule.XSBase.SetAllProcessedValues(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])"/>
            </para>
            </summary>
            <returns>True if stored, false if not stored and stored data already exists</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.ClearOriginalProcessedData">
            <summary>
            Clear any stored processed data arrays
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.RestoreOriginalProcessedData">
            <summary>
            Restores any stored processed data arrays previously 
            stored.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.CreateAllProcessedArrays(System.Int32)">
            <summary>
             Creates all processed data arrays with the given number of levels.
            </summary>
            <param name="numberOfLevels">Number of levels in processed data arrays</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.CalculateProcessedData">
            <summary>
            Calculate processed data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.CalculateProcessedDataIfNeeded">
            <summary>
            Calculate the processed levels, storage areas, radii, etc, ie, fill in all 
            ProcessedXXX properties if they are not up to date. Also called by getters for these properties if needed,
            so usually, this method doesn't have to be called explicitly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.CalculatedProcessedDataCheck">
            <summary>
            Indicating if processed data is to be calculated.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetIndexFraction(System.Double,System.Int32,System.Double@)">
            <summary>
            Get index and fraction from depth. Used to interpolate data:
            value = in[index] + fraction*(in[index+1] - in[index])
            
            If depth is above <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.TopLevel"/> or above <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.BottomLevel"/>
            an exception is thrown.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.RestoreModifiedResistanceFactors">
            <summary>
            if Multiply... or Convert... or similar was called earlier, 
            reset the modified resistance factors 
            to the original processed resistance factors
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.ConvertRelativeResistance(DHI.Mike1D.HDParameterDataAccess.BedResistanceValueSet,DHI.Mike1D.Generic.ResistanceFormulation)">
            <summary>
             Converts the relative resistance formulation to an absolute formulation based
             on a BedResistanceValueSet
             
             The relative formulation are maintained in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/>
             while the new absolute resistance factors are stored in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>.
             
             If this cross section already has an absolute resistance formulation 
             (according to <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.FlowResistance"/>), this has no effect.
            </summary>
            <param name="bedResistance">ValueSet of the resistance to convert to</param>
            <param name="absoluteFormulation">Resistance formulation of value. Can not be relative</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.ConvertRelativeResistance(System.Double,DHI.Mike1D.Generic.ResistanceFormulation)">
            <summary>
             Converts the relative resistance formulation to an absolute formulation.
             
             The relative formulation are maintained in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/>
             while the new absolute resistance factors are stored in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>.
             
             If this cross section already has an absolute resistance formulation 
             (according to <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.FlowResistance"/>), this has no effect.
            </summary>
            <param name="absoluteValue">Value of the resistance to convert to</param>
            <param name="absoluteFormulation">Resistance formulation of value. Can not be relative</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.ConvertRelativeResistanceMultiZones(System.Double[],System.Double[],DHI.Mike1D.Generic.ResistanceFormulation)">
            <summary>
            Converts the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/> according
            to a multizone set of absolute resistance values.
            
            Each input factor is applied between each level seperator, 
            the first factor from -infinity to the first level, the second factor
            from the first level to the second level, and the last factor
            from the last level to infinity, i.e., the levelSeperators defines where
            one factor takes over from the previous. 
            
            The factors array must be one longer than the levelSeperators array.
            
            The relative resistance factor is taken into account also.
            
            Results are stored in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>
            and those are used in the calculation.
            </summary>
            <param name="depths">Monotonically increasing vector of levels</param>
            <param name="resistanceValues">Resistance values</param>
            <param name="absoluteFormulation">The resistance formulation that the factors refer to</param>
            <remarks>
            Average factors are applied for depths that fall exactly on one of the levelseperators
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.MultiplyByResistanceFactors(System.Double)">
            <summary>
            Multiplies the resValue with the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/>.
            
            Results are stored in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>
            and those are used in the calculation.
            </summary>
            <param name="resValue">factor to multiply</param>
            <remarks>
            If the resValue is 1.0, <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>
            are set to point to <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/>.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.DivideByResistanceFactors(System.Double)">
            <summary>
            Divides the resValue with the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/>
            
            Results are stored in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>
            and those are used in the calculation.
            </summary>
            <param name="resValue">factor to multiply</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.ConvertDarcyWeisbachResistanceFactors(System.Double)">
            <summary>
            Divides the resValue with the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/>
            
            Results are stored in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>
            and those are used in the calculation.
            </summary>
            <param name="dwValue">Uniform Darcy Weisbach resistance value</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.MulDivByResistanceFactorsMultiZones(System.Double[],System.Double[],System.Boolean,DHI.Mike1D.Generic.ResistanceFormulation)">
            <summary>
            Multiplies or divides the factors with the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ProcessedResistanceFactors"/>. 
            
            Each input factor is applied between each level seperator, 
            the first factor from -infinity to the first level, the second factor
            from the first level to the second level, and the last factor
            from the last level to infinity, i.e., the depthSeperators defines where
            one factor takes over from the previous. 
            
            The factors array must be one longer than the depthSeperators array.
            
            Results are stored in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>
            and those are used in the calculation.
            </summary>
            <param name="depthSeperators">Monotonically increasing vector of depths</param>
            <param name="resistanceValues">Factors to multiply the resistance with</param>
            <param name="multiply">If true: multiply, if false: divide.</param>
            <param name="resFormulation"></param>
            <remarks>
            Average factors are applied for levels that fall exactly on one of the levelseperators
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.AdjustProcessedLevelSpecs(System.Double)">
            <summary>
             Adjust the processed level specification.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.AdjustProcessedLevels(System.Double)">
            <summary>
             Adjust the processed levels. Used to ensure that _processedLevels[0] has a certain value
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.AdjustProcessedLevels(System.Double[],System.Double)">
            <summary>
             Adjust the processed levels, subtract delta. 
             Used to ensure that _processedLevels[0] has a certain value
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.InheritProcessedDataFrom(DHI.Mike1D.CrossSectionModule.XSBase)">
            <summary>
            Makes all processed data arrays point to the same arrays as in the other.
            (reference copy, not value copy)
            </summary>
            <param name="xsOther">XSBase to get references from.</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.InterpolateValue(System.Double[],System.Int32,System.Double)">
            <summary>
            Interpolate values at index and index+1:
            value = vals[index] + fraction * (vals[index + 1] - vals[index])
            </summary>
            <param name="vals"></param>
            <param name="index"></param>
            <param name="fraction"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetArea(System.Int32,System.Double)">
            <summary>
            Return the cross sectional geometric area, 
            for index and fraction into the processed data. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetAreaByIntegratingWidths(System.Double)">
            <summary>
            Return the cross sectional geometric area, 
            integrating the storage widths
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetLevelFromArea(System.Double)">
            <summary>
            For a given area, find the level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetFlowArea(System.Int32,System.Double)">
            <summary>
            Return the cross sectional flow area, 
            for index and fraction into the processed data. 
            
            This can be the total areas or the effective flow area
            hence the area does not necessarily correspond to the amount 
            of water in the system (volume)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetFlowAreaDerivative(System.Int32,System.Double)">
            <summary>
            Get storagewidth as dA/dh from neighboring values in processed XS areas at waterLevel.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetHydraulicRadius(System.Int32,System.Double)">
            <summary>
            Returns the hydraulic radius for index and fraction into the processed data
            </summary>
            TODO: Test use of virtual functions. Can be avoided by adding a scalefactor to result, in case there is a performance penalty.
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetHydraulicRadiusDerivative(System.Int32,System.Double)">
            <summary>
            Get the derivate of the hydraulic radius for index and fraction into the processed data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetAdditionalSurfaceArea(System.Int32,System.Double)">
            <summary>
            Additional storage area is a volume that the mass equation takes
            into account, but it does not influence the momentum equation. It
            could be a small pond next to the river that is filled/emptied as
            the water level in the river raises/falss.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetStorageWidth(System.Int32,System.Double)">
            <summary>
            Returns the width from left bank to right bank for index and fraction into the processed data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.MaximumStorageWidth">
            <summary>
             Maximum storage width of the cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.BottomLevelFromCenter(System.Double)">
            <summary>
            Return the bottom level of the cross section at a distance dx from 
            the center of the cross section. Throws an exception if dx is larger than 
            half the cross section width.
            </summary>
            <param name="dx"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetResistanceFactor(System.Int32,System.Double)">
            <summary>
            Returns the resistance factor. 
            </summary>
            <returns>Resistance factor</returns>
            <remarks>
            Uses the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>, see there for more details
            </remarks>
            This base method is used when the resistance factor is 
            not tabulated. Only open cross sections override 
            this method since only open cross sections can have a tabulated
            resistance factor.
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetResistanceFactorsDerivative(System.Int32,System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
            <remarks>
            Derivative is based on the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedResistanceFactors"/>
            see ther for more details.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
            <remarks>
            The critical depth can not be larger than the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.Height"/>.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetCriticalDepth(System.Double,System.Double,System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            
            MU version
            </summary>
            <param name="discharge"></param>
            <param name="depth">Current depth, used to calculate a general wave speed</param>
            <param name="flowArea">Current flowarea, used to calculate a general wave speed</param>
            <remarks>
            Should not depend on current depth and current flowarea?!?
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GenerateCriticalDischarges(System.Boolean)">
            <summary>
            Generate the _processedCriticalDisharge array, on each level
            of processed data adding sqrt(g*A^3/b)
            </summary>
            <param name="mustBeIncreasing">True of the critical discharges are created so they are always increasing.</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical discharge for a given water level
            The critical discharge is the discharge where the flow changes 
            from supercritical to subcritical flow.
            </summary>
            <remarks>
            Based on Equation (4.13) p. 150 in "Hydraulik", F.A. Engelund and Fl. Bo Pedersen, 1978
            The alpha (see Equation (2.23) p. 80) is set to 1 (as on p. 156, p. 167 ?) 
            Alpha is the "hastigheds-fordelings-coefficient" - velocity-distribution-coefficient.
            
            <code>
            Qcrit = Sqrt(g*A^3/b) = Sqrt(g*A/b)*A = Sqrt(g*D)*A
            </code>
            
            where D=A/b is the average depth.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetNaturalDepth(System.Double,System.Double)">
            <summary>
            Get the natural depth at a given discharge and slope
            </summary>
            <param name="discharge">Discharge to find depth for</param>
            <param name="slope">Slope to use in calculations</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.ConvertModifiedResistanceFactorsIfNecessary">
            <summary>
            Converts the modified resistance data to another formulation. Returns false if the
            conversion could be performed. 
            Note: so far only few conversions are supported: 
            - from Manningsn to ManningsM;
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetMaximumValues(System.Double@,System.Double@,System.Double@)">
            <summary>
            Set maximum area, maximum hydraulic radius and maximum storage width.
            </summary>
            <param name="maxArea"></param>
            <param name="maxHydraulicRadius"></param>
            <param name="maxStorageWidth"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.Validate">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.CheckProcessedData(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.Initialize">
            <summary>
             Calculate processed data if needed
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.Prepare(DHI.Mike1D.Generic.Diagnostics,DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.ILocation)">
            <summary>
            Ensures that the resistance fomulation is not relative. If the resistance fomulation is 
            Mannings n it is changed to Mannings M and the data are changed accordingly if the resistance 
            formulation is Darcy Weisbach formulation and data are changed to Chezy.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBase.GetVolumeFromAdditionalSurfaceArea(System.Double)">
            <summary>
            Return the integrated additional surface area from the bottom of the top slot to waterLevel
            </summary>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBase.System#Runtime#Serialization#IExtensibleDataObject#ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSCircular">
            <summary>
            Closed circular cross section. Circular cross sections are defined by their diameter.
            
            Processed data is calculated by <see cref="M:DHI.Mike1D.CrossSectionModule.ProcessXSRaw.CalculateProcessedData(DHI.Mike1D.CrossSectionModule.XSBase)"/>
            </summary>
            <remarks>
            Remember to call CalculateProcessedData() before use.
            </remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircular.Diameter">
            <summary>
            Diameter of cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircular.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircular.#ctor(System.Double)">
            <summary>
            Construct a circular cross section with specified diameter
            </summary>
            <param name="diameter"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircular.Validate">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircular.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
            <remarks>
            The critical depth can not be larger than the <see cref="P:DHI.Mike1D.CrossSectionModule.XSCircular.Height"/>.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircular.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircular.Height">
            <summary>
             Height of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSCircular.MaximumStorageWidth">
            <summary>
             Maximum storage width of the cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircular.BottomLevelFromCenter(System.Double)">
            <summary>
            Return the bottom level of the cross section at a distance dx from 
            the center of the cross section. Throws an exception if dx is larger than 
            half the cross section width.
            </summary>
            <param name="dx"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSCircular.Clone">
            <summary>
            Returns a deep clone. Note: Does not clone any children
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSOpen">
            <summary>
             Open cross section. Open cross sections are defined by a list of points.
             Remember to call CalculateProcessedData() before use.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSOpen.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSOpen.#ctor(DHI.Mike1D.CrossSectionModule.XSBaseRaw)">
            <summary>
            Constructor creating a new open cross section from an existing raw cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSOpen.Clone">
            <summary>
            ICloneable implementation. deep clone, including owner
            </summary>
            <returns>a copy of this cross section</returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.InterpolateXSRaw">
            <summary>
            Interpolates in the raw data using the M11CrossSectionAlg.dll. It is the same
            interpolation as in the Cross Section Editor (crossectionedit.dll)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.InterpolateXSRaw.GetIntermediateCrossSection(DHI.Mike1D.Generic.ILocation,System.String,DHI.Mike1D.CrossSectionModule.CrossSectionLocated,DHI.Mike1D.CrossSectionModule.CrossSectionLocated,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
            Interpolates in the raw data using the M11CrossSectionAlg.dll. It is the same
            interpolation as in the Cross Section Editor (crossectionedit.dll)
            <para>
            The two cross sections must be based on raw data, being either an open cross section
            or a closed polygon.
            </para>
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess">
            <summary>
            data bridge to/from an xns11 file
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType">
            <summary>
            Type of cross section, the enum numbers matching those
            defined in the xns11 file.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType.Open">
            <summary>
            Open cross-section (standard M11)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType.ClosedIrregular">
            <summary>
            Closed irregular/Polygon cross-section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType.Circular">
            <summary>
            Circular closed cross-section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType.Rectangular">
            <summary>
            Rectangular closed cross-section
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType.CircularPreprocessed">
            <summary>
            Circular closed cross-section, preprocessed (MU type)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType.OShapedPreprocessed">
            <summary>
            O-shaped closed cross-section, preprocessed (MU type)
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType.EggShapedPreprocessed">
            <summary>
            Egg-shaped closed cross-section, preprocessed (MU type)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.CreateCrossSectionFromXfsStruct(System.IntPtr,DHI.Mike1D.CrossSectionModule.ICrossSectionFilter)">
            <summary>
            Create cross section from XFSStruct. Can be null.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.CreateXfsStructFromCrossSection(DHI.Mike1D.CrossSectionModule.CrossSectionLocated,DHI.Mike1D.CrossSectionModule.ICrossSectionFilter)">
            <summary>
            Create XFSStruct from cross section.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.CheckCoordinateType1(DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType,DHI.Mike1D.CrossSectionModule.CrossSectionLocated)">
            <summary>
            Coordinates of type 1 is compatible with the MIKE 11 Cross Section Editor. Requirements:
            1) Exactly two coordinates
            2) s-coordinate value of two coordinates must match first and last raw data point X value.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.GetXsData(DHI.Mike1D.CrossSectionModule.XSBase,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Get data for the given XSBase, required when setting up
            an xfs structure from a cross section.
            </summary>
            <param name="xsBase">Cross section to transfer to xfs</param>
            <param name="nRaw">Number of raw data points stored in cross section</param>
            <param name="nPrc">Number of processed data levels stored in cross section</param>
            <param name="nSel">Number of user defined processed data levels (for re-processing) stored in cross section</param>
            <returns>Xfs type of cross section</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.CreateXsBaseFromXfsType(DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec)">
            <summary>
            Create an XSBase cross section based on the type number in the xfs structure
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.GetXsSpecificFromXfs(DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Delegating method.
            Each method must make sure to load properly
            - Processing levels specs
            - Raw data
            - Processed data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.SetXsSpecificToXfs(DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType,DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Delegating method.
            Each method must make sure to specify properly
            - Type of cross section
            - Processing levels specs
            - Raw data
            - Processed data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.GetSMinMax(DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XfsCrossSectionType,System.Double@,System.Double@)">
            <summary>
            Get smallest and largest S value (raw coordinate X value)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.GetXsCommonFromXfs(DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec)">
            <summary>
            Get values from Xfs that are common for all cross section types
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.SetCoordinates(DHI.Mike1D.CrossSectionModule.CrossSectionLocated,System.Boolean,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Store coordinates to XSec
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.SetXsCommonToXfs(DHI.Mike1D.CrossSectionModule.CrossSectionLocated,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Set values to Xfs that are common for all cross section types
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.GetProcessingSpecsFromXfs(DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Get processing specs from Xfs
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.SetProcessingSpecsToXfs(System.Int32,DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Set processing specs to Xfs.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.GetRawFromXfs(DHI.Mike1D.CrossSectionModule.XSBaseRaw,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Get raw data from Xfs
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.SetRawToXfs(System.Int32,DHI.Mike1D.CrossSectionModule.XSBaseRaw,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Set raw data to Xfs
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.InitializeRawToXfs(System.Int32,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Initialize raw values to zero. Used by cross sections
            that utilize raw data for other purposes (circular diameter,
            rectangular width/height etc.)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.ExtractProcessedFromXfsPtr(System.IntPtr,System.Int32,DHI.Mike1D.CrossSectionModule.XSBase)">
            <summary>
            Extract processed data from Xfs pointer.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.GetProcessedFromXfs(DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Get processed data from Xfs
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.SetProcessedToXfs(System.Int32,DHI.Mike1D.CrossSectionModule.XSBase,DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSec@)">
            <summary>
            Set processed data to Xfs
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.NumLevelSpecsUserLevels(DHI.Mike1D.CrossSectionModule.XSBase)">
            <summary>
            Return the number of user defined levels from the processing level specification.
            Helper method.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.MarkerIndex(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            Returns the index (1-based) of a given cross section marker point, or 0
            if marker point is null.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.UTrue">
            <summary>  true value as uint16, as used by Xfs</summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.UFalse">
            <summary>  false value as uint16, as used by Xfs</summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSecDouble.LeftHighFlow">
            <summary> Also ExpDep top value </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSecDouble.LowFlow">
            <summary> Also ExpDep exponent </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionXfsAccess.XSecDouble.Uniform">
            <summary> Also constant and ExpDep bottom value </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.InterpolateXSProcessed">
            <summary>
             Class that creates a new cross section 
             as an interpolation in processed data
             between two neighbouring cross sections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.InterpolateXSProcessed.Interpolate(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.Generic.Diagnostics)">
            <summary>
             Create a new ICrossSection that is interpolated from the cross sections
             before and after the newLocation, positioned at the newLocation.
             
             It returns a <see cref="T:DHI.Mike1D.CrossSectionModule.CrossSectionLocated"/> cross section based on a <see cref="T:DHI.Mike1D.CrossSectionModule.XSProcessedInterp"/>
             that contains only processed data. I.e., it only interpolates processed data.
            </summary>
            <param name="newLocation">New location for interpolated cross section</param>
            <param name="xsBefore">Cross section before new locatino</param>
            <param name="xsAfter">Cross section after new location</param>
            <param name="diagnostics">Diagnostics instance for reporting errors. Can be null.</param>
            <returns>Interpolated cross section</returns>
            <remarks>
             The interpolation works as follows: The new cross section get the
             maximume number of levels of the two up-and down-stream cross sections.
             From the top (!) each level is matched and interpolated linearly in chainage
             <code>
             levels_new[end-i] = (1-ratio) * level_before[end-i] + ratio * level_after[end-i];
             </code>
             where end indicates the top level index of each. If one index gets below 0, the bottom level
             value is used instead.
             
             This is a quite primitive interpolation, not always giving the desired results. Especially:
             - Storage widths and areas does not match very well anymore, therefor geometric areas
               are recalculated by integrating up widths.
             - Flow areas are not recalculated, and does therefor not match storage widhts. This
               is in order to get backward compatible results (since M11 does it this way).
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSBaseRaw">
            <summary>
            A class representing a cross section with raw data attached.
            TODO: Should deserializer call 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBaseRaw.MAX_MARKER">
            <summary>
            largest value (as int) within <see cref="T:DHI.Mike1D.Generic.PreDefinedMarker"/>. Any value beyond
            indicates a user marker.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSBaseRaw._processedLocalVelocityFactors">
            <summary>
             Only used by flood maps. Calculated the first time GetLocalVelocityFactor() is called
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.#ctor">
            <summary>
            Constructor, making an open cross section.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.#ctor(System.Boolean)">
            <summary>
            Constructor, making an open or closed cross section.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.#ctor(DHI.Mike1D.CrossSectionModule.XSBaseRaw)">
            <summary>
            Constructor, making a copy of the original cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.IsOpen">
            <summary>
             Return true if cross section is open
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Points">
            <summary>
             List of points defining polygon cross section.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Initialize">
            <inheritdoc />
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.BottomLevelFromCenter(System.Double)">
            <summary>
            Return the bottom level of the cross section at a distance dx from 
            the center of the cross section. Throws an exception if dx is larger than 
            half the cross section width.
            </summary>
            <param name="dx"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetLocalVelocityFactor(System.Double)">
            <summary>
            Calculate a local velocity factor for the provided water depth. This factor
            is used when calculating a transversally distributed flow velocity.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetLocalVelocityFactorFromIntegral(System.Double)">
            <summary>
            Calculates the local velocity factor for use in <see cref="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetLocalVelocity(System.Double,System.Double,System.Double)"/>.
            <para>
            The method is seperated from the <see cref="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetLocalVelocity(System.Double,System.Double,System.Double)"/> method, since
            this can be an expensive method (integrating over the entire cross section),
            to be called once, and the result used many times by the
            <see cref="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetLocalVelocity(System.Double,System.Double,System.Double)"/> method.
            </para>
            </summary>
            <param name="waterdepth">Global water depth</param>
            <returns>A factor used in <see cref="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetLocalVelocity(System.Double,System.Double,System.Double)"/>. 0 on failure.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetLocalVelocity(System.Double,System.Double,System.Double)">
            <summary>
            Calculates a local velocity for a given x along the cross sectional profile. The result must
            be divided by GetLocalVelocityFactor().
            <para>
            The calculation is based on a parallel canal analysis, and if integrated up, 
            matches the total discharge through the cross section.
            </para>
            </summary>
            <param name="q">Discharge </param>
            <param name="x">Cross sectional coordinate, need not start at 0.</param>
            <param name="waterdepth">Global water depth</param>
            <returns>A local velocity at the x coordinate of the cross section.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.CopyValuesToOther(DHI.Mike1D.CrossSectionModule.XSBaseRaw)">
            <summary>
            Copy the values of this cross section to another cross section
            </summary>
            <param name="cs"></param>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Interpolated">
            <summary>
            whether this cross section was generated from interpolation of neighboring
            cross sections
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.RadiusType">
            <summary>
            some kind of hydraulic or resistance radius
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Selected">
            <summary>
            whether this cross section is selected for some operation, e.g. saving.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.ApplyAngle">
            <summary>
            Flag specifying whether to apply <see cref="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Angle"/> of correction.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Angle">
            <summary>
            Angle of correction between perpendicular (to river) and cross section 
            orientation [radian].
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.FlowDir">
            <summary>
            Flow direction 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.ClearZones">
            <summary>
            clear section from vegetation and dead water, setting all zone info to Normal
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.LeftLeveeBank">
            <summary>
             Point at left side of the cross section where the left levee is located.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.LowestPoint">
            <summary>
             Point at lowest part of the cross section.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.RightLeveeBank">
            <summary>
             Point at right side of the cross section where the right levee is located.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.LeftLowFlowBank">
            <summary>
             Point at left side of the cross section where the lowest flow bank is located.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.RightLowFlowBank">
            <summary>
             Point at right side of the cross section where the lowest flow bank is located.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.LeftCoordinateMarker">
            <summary>
             Point at left side of the cross section where the coordinate marker is located.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.RightCoordinateMarker">
            <summary>
             Point at right side of the cross section where the coordinate marker is located.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.SetMarkerAt(System.Int32,System.Int32)">
            <summary>
            Set a particular marker to a given 0-BASED index (within the list of points),
            or remove it (call with -1). If any other point had this marker before, it gets
            removed from that point.
            Throws IndexOutOfRangeException if list of points is empty or index is invalid.
            </summary>
            <param name="marker">the marker to set (PreDefined as int, or user-defined)</param>
            <param name="index">the index of the point to mark, or -1 to remove the marker</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetMarkerIndex(System.Int32)">
            <summary>
            Return index of a marker
            </summary>
            <param name="marker"></param>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Symmetric">
            <summary>
            Determines if the points in this cross sections makes up one side of a symmetric cross section
            Note: Not implemented yet
            Note: Not always possible.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.UpdatePointResistance">
            <summary>
            Update the resistance values in the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Points"/> in case
            the <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceDistribution"/> is
            <see cref="F:DHI.Mike1D.Generic.ResistanceDistribution.Uniform"/> or
            <see cref="F:DHI.Mike1D.Generic.ResistanceDistribution.Zones"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.UpdateMarkersToDefaults(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            clears the indicated existing markers and sets them to their default x location.
            (LeftLeveeBank: smallest x, RightLeveeBank: largest x, LowestPoint: x with
            the smallest z). Doesn't do anything for Circular, Rectangular.
            </summary>
            <param name="bLeftLeveeBank">reset marker for left levee bank?</param>
            <param name="bLowestPoint">reset marker for lowest point?</param>
            <param name="bRightLeveeBank">reset marker for right levee bank?</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetMarkerSequence(System.Int32[]@,System.Int32[]@)">
            <summary>
            Returns a sequence of markers and their indices.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.UpdatePointMarkerString">
            <summary>
            Update the <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.MarkerString"/> for
            all cross section points with a marker. Used by the GUI.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.GetMarkersOfPoint(System.Int32)">
            <summary>
            For a given cross section point (at some index), return all markers on that point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.ComputeConveyance(System.Double,System.Double,System.Double)">
            <summary>
            return the conveyance, using the formulation set in <see cref="T:DHI.Mike1D.Generic.ResistanceFormulation"/>
            Result is in base units (formulations are not unit-consistent!)
            </summary>
            <param name="resistanceFactor">relative resistance factor</param>
            <param name="area">cross section area</param>
            <param name="radius">cross section radius</param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.Validate">
            <summary>
            Validates the data. The constraints are that the levels and the areas after sorting must be monotonically increasing.
            </summary>
            <returns>String that descripes the problem.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSBaseRaw.CreateXSOpenCreateDefaultValues">
            <summary>
            Creates a default cross section with 3 points, marked 1-3 from left to right,
            coordinates (0, 1); (1, 0); (2; 1). All points' resistance factors are set 
            to 1.0 and their zones are set to normal.
            The returned cross section is not made part of this collection.
            </summary>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ICrossSection">
            <summary>
            This is the interface that all cross sections should implement. 
            The methods are mainly defined by what is needed by the engine.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.Validate">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Ensures that the resistance fomulation is not relative. If the resistance fomulation is 
            Mannings n it is changed to Mannings M and the data are changed accordingly if the resistance 
            formulation is Darcy Weisbach formulation and data are changed to Chezy.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.BaseCrossSection">
            <summary>
             Base cross section. The base cross section has no location and holds
             data in depth, not in water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetArea(System.Double)">
            <summary>
            Return the cross sectional geometric area at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetFlowArea(System.Double)">
            <summary>
            Return the cross sectional flow area at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetHydraulicRadius(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            The radius are calculated as one of : todo: check:
            Resistance Radius.
            Effective area, hydraulic radius
            Total area, hydraulic radius.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetHydraulicRadiusDerivative(System.Double)">
            <summary>
            Get the derivate of the hydraulic radius at the given water level.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.ResistanceFormulation">
            <summary>
            The ResistanceFormulation that is used for this crossSection and stored in the processed data.
            <para>
            This may differ from the ones specified in the <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.Formulation"/>, which
            is the formulation for the raw data.
            </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetResistanceFactor(System.Double)">
            <summary>
            Resistance factor for the given water level.
            This will always return absolute resistance values.
            </summary>
            <param name="waterLevel"></param>
            <remarks>Conversion from relative to absolute is handled in the prepare step</remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.ResistanceFactorProportionality">
            <summary>
            A proportionality factor that is multiplied with the resistance factor. 
            ResistanceFactorProportionality is used by the resistance factor
            boundaries to adjust the resistance factor during the simulation.
            If not set here, its value is default: 1.0
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetConveyance(System.Double)">
            <summary>
            Get the conveyance at the specified water level
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Additional storage area is a volume that the mass equation takes
            into account, but it does not influence the momentum equation. It
            could be a small pond next to the river that is filled/emptied as
            the water level in the river raises/falss.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetStorageWidth(System.Double)">
            <summary>
            Returns the width from left bank to right bank at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical discharge for a given water level
            The critical discharge is the discharge where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetNaturalDepth(System.Double,System.Double)">
            <summary>
            Gets the Natural depth for a given discharge [m3/s] and slope [dimensionless]
            The natural depth is the depth where the flow resistance and velocity
            balances, i.e., the Manning formula is fullfilled: Q = M*A*R^(2/3)*sqrt(I)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.TopoID">
            <summary>
            The TopoID set that this cross section belongs to. TODO: See where for details?
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.Info">
            <summary>
            Generel info on this cross section, user specified, can be empty. In
            Mike11 XNS editor called cross section ID (though it does not identify 
            the cross section)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.ZMax">
            <summary>
            The maximum value of Z in the cross section. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.ZMin">
            <summary>
            The minimum value of Z in the cross section (bottom level)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.ZMinFromCenter(System.Double)">
            <summary>
            The minimum value of Z in the cross section (bottom level) at a distance dx from the center of the cross section.
            </summary>
            <param name="dx"></param>
            <returns></returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.Height">
            <summary>
             Height of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.MaximumWidth">
            <summary>
             Maximum width of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.MinWaterDepth">
            <summary>
             Minimum water depth of the cross section.
             <para>
             If the water depth goes below this depth, it will be corrected
             to match this depth.
             </para>
             <para>
             This can be negative, in case the cross 
             section has a slot attached.
             </para>
            </summary>
             <para>
             In case of no slot, it is set by the <see cref="P:DHI.Mike1D.HDParameterDataAccess.SolverSettings.MinWaterDepth"/>, 
             see there for details.
             </para>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.Location">
            <summary>
            Defines the location of the current cross section. The Z-coordinate
            is the bottom level of the cross section (unless defined by the
            raw data (the open cross sections)).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.Interpolated">
            <summary>
            Returns true if the CrossSection is interpolated from other cross sections
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.ApplyCoordinates">
            <summary>
            Flag specifying whether the <see cref="P:DHI.Mike1D.CrossSectionModule.ICrossSection.Coordinates"/> is to be applied or ´not
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.Coordinates">
            <summary>
            Gets or sets the cross section coordinates, i.e., the geographical coordinates
            of line that the cross section follows.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.Extrapolate(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Returns an extrapolated CrossSection, i.e., a copy of this cross
            section at the new location.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSection.IsOpen">
            <summary>
             Return true if the cross section is open
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetFlowAreaDerivative(System.Double)">
            <summary>
            Get storagewidth as dA/dh from neighboring values in processed XS areas at waterLevel
            This is how M11 does it - ONLY USED IN M11 SCHEME WHEN COMPARING DIRECTLY WITH M11 RESULTS
            Only implemented in XSOpen for now
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.Initialize">
            <summary>
             Initialize cross section. Calculates processed data if needed.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.GetVolumeFromAdditionalSurfaceArea(System.Double)">
            <summary>
            Return the integrated additional surface area from the bottom of the top slot to waterLevel
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSection.UpdateDatum(System.Double)">
            <summary>
            Update datum for cross section
            </summary>
            <param name="newDatum"></param>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionExtensions">
            <summary>
            Static class containing extension methods related to 
            cross sections
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionExtensions.GetDelh(DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.HDParameterDataAccess.SolverSettings)">
            <summary>
            Return delh for the cross section.
            </summary>
            <param name="crossSection">Cross section to provide delh for</param>
            <param name="solverSettings">SolverSettings</param>
            <returns>delh for cross section</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionExtensions.Clone(DHI.Mike1D.CrossSectionModule.CrossSectionData)">
            <summary>
            Clone all cross sections in CrossSectionData.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionExtensions.ToProcessedFormulation(DHI.Mike1D.Generic.ResistanceFormulation)">
            <summary>
            Clone all cross sections in CrossSectionData.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionExtensions.GetConveyance(DHI.Mike1D.CrossSectionModule.XSBase,System.Int32)">
            <summary>
            Get the conveyance at the specified processed level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionExtensions.GetCapacity(DHI.Mike1D.CrossSectionModule.ICrossSection,System.Double,System.Double,DHI.Mike1D.HDParameterDataAccess.HDParameterData)">
            <summary>
            Get the capacity=conveyance*sqrt(slope) at the specified water level and slope.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionExtensions.AutoProcess(DHI.Mike1D.CrossSectionModule.CrossSectionData,System.Boolean)">
            <summary>
            Set the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.AutoProcess"/> flag for all cross sections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionExtensions.GetCrossSections(DHI.Mike1D.CrossSectionModule.CrossSectionData,DHI.Mike1D.Generic.ILocation,System.String,System.Boolean,DHI.Mike1D.CrossSectionModule.ICrossSection@,DHI.Mike1D.CrossSectionModule.ICrossSection@)">
            <summary>
            Find upstream and downstream cross section from <paramref name="crossSectionData"/>
            at <paramref name="location"/>. 
            If none exists, create an return a <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.GetVeryLargeCrossSection"/>
            </summary>
            <param name="location">Location to find cross sections at</param>
            <param name="topoID">Topo id to use when finding cross sections</param>
            <param name="crossSectionData">Cross section data to find cross sections in</param>
            <param name="reverseDirection">Boolean indicating if the structure direction is reversed</param>
            <param name="upstreamCrossSection">The upstream cross section</param>
            <param name="downstreamCrossSection">The downstream cross section</param>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionDataFactory">
            <summary>
            A factory class for reading and writing CrossSectionCollections.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionDataFactory.Open(System.String,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read CrossSectionData from file specified, assuming bridgename
            equals the extension.
            </summary>
            <param name="filePath">File to read</param>
            <param name="diagnostics">Diagnostics object to report issues to.</param>
            <returns>Populated data access component</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionDataFactory.Open(DHI.Mike1D.Generic.IConnection,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Read CrossSectionData from file specified by IConnection
            </summary>
            <param name="connection">File to read</param>
            <param name="parentDiagnostics"> </param>
            <returns>Populated data access component</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionDataFactory.Save(DHI.Mike1D.CrossSectionModule.CrossSectionData)">
            <summary>
            Write DataAccess component to file, using its supplied connection field.
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionEventHandler">
            <summary>
            event handler delegate
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSInterpolationTypes">
            <summary>
            Defines how an interpolated cross section are
            interpolated 
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSInterpolationTypes.ProcessedTopDown">
            <summary>
             Interpolates the processed data. Raw data will not be available,
             see <see cref="T:DHI.Mike1D.CrossSectionModule.InterpolateXSProcessed"/> for details.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSInterpolationTypes.Raw">
            <summary>
             Interpolates the raw data and calculates processed data from the new raw data.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSInterpolationTypes.Middling">
            <summary>
             Interpolation happens during runtime by requesting values at neighbour cross sections
             and interpolate between those. // TODO: see details XXX
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionData">
            <summary>
            A class representing a collection of cross sections, spanning multiple reaches.
            <para>
            The collection orders the cross sections in two ways: If a reach only 
            has one global cross-section, it is indexed by reachID and topoID. Other cross 
            sections which have a location including a chainage, are ordered by locationID (reachID),
            topoID and chainage.
            </para>
            <para>
            If a cross section gets its location updated after insertion
            into the collection, it needs to be removed and reinserted into the collection in 
            order to be indexed correctly.
            </para>
            <para>
            Events are not supported for COM interop, even though they appear in the type lib.
            </para>
            <para>
            All physical quantities are in SI units.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionData.RuntimeDiagnostics">
            <summary>
            Diagnostics instance for the engine net. Used during runtime.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.CreateRuntimeDiagnostics">
            <summary>
             Create a runtime Diagnostics instance. This is called from the initializer which 
             contains the cross section data since there is no initializer here (CrossSectionData is
             created during load, not initialization).
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionData._crossSectionMap">
            <summary>
            Map for fast access to crossSections. Key into first dictionary is reachID (Location.ID)
            and TopoID. The value is a set of CrossSections for the given reach (and topoID), sorted
            by chainage.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionData.CSID">
            <summary>
            Small internal class used as key when sorting the cross sections in the dictionary 
            Sorting is on reachID and then topoID.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionData.Count">
            <summary>
            returns the number of cross sections
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.Clear">
            <summary>
            Removes all cross sections from this collection.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionData.XSInterpolationType">
            <summary>
             Defines how to interpolate a cross section.
             <para>
             Default value is <see cref="F:DHI.Mike1D.CrossSectionModule.XSInterpolationTypes.ProcessedTopDown"/>
             </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.Add(DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
            Add the crossSection based on its location id and chainage and topoID. 
            <para>
            If a cross section gets its location updated after insertion
            into the collection, it needs to be removed and reinserted into the collection.
            </para>
            </summary>
            <param name="cs"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.AddGlobal(DHI.Mike1D.CrossSectionModule.ICrossSection,System.String)">
            <summary>
            Add the crossSection as a global crossSection for the entire reach.
            </summary>
            <param name="cs">Cross section to add</param>
            <param name="reachID">Id of reach where the cross section is valid</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.ElevateReachGlobal">
            <summary>
            For all reach/topo-id's with only one cross section on
            chainage 0, elevate those cross sections to reach global
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.FindCrossSection(DHI.Mike1D.Generic.ILocation,System.String)">
            <summary>
            Find a cross section based on the location and topoID. If no cross section
            is found (chainage within Constants.LOCATION_EQUAL_TOLERANCE), null is returned.
            <para>
            If the reach defined in the location has a global cross section, the global cross section 
            is returned. TODO: Consider returning null instead
            </para>
            <para>
            This is meant for editing the cross sections, use Get to always get a cross section at a location.
            </para>
            </summary>
            <param name="location">Location at which to look for a cross section</param>
            <param name="topoID">Topo id to look for</param>
            <returns>A cross section at the location. null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.FindClosestCrossSection(DHI.Mike1D.Generic.ILocation,System.String)">
            <summary>
            Find the closest cross section based on the location and topoID. If no cross section
            is found, null is returned.
            <para>
            If the reach defined in the location has a global cross section, the global cross section 
            is returned. TODO: Consider returning null instead
            </para>
            <para>
            This is meant for editing the cross sections, use Get to always get a cross section at a location.
            </para>
            </summary>
            <param name="location">Location at which to look for a cross section</param>
            <param name="topoID">Topo id to look for</param>
            <returns>A cross section at the location. null if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.RemoveCrossSection(DHI.Mike1D.Generic.ILocation,System.String)">
            <summary>
            Find and remove a cross section based on the location and topoID. If no cross section
            is found (chainage within Constants.LOCATION_EQUAL_TOLERANCE), false is returned.
            
            If the reach defined in the location has a global cross section, the global cross section 
            is removed. TODO: Consider doing nothing
            </summary>
            <param name="location">Location at which to look for a cross section to remove</param>
            <param name="topoID">Topo id to look for</param>
            <returns>True if a cross section was removed, false otherwise</returns>
            <remarks>
            If first tries to remove the crosssection with the exact chainage value. If not
            found, it removes the first one with a chainage value within Constants.LOCATION_EQUAL_TOLERANCE
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.FindGlobalCrossSection(System.String,System.String)">
            <summary>
            Find a cross section based on the reachID and topoID. The reach must have
            a global cross section defined, otherwise null is returned.
            </summary>
            <param name="reachID">ID of reach to get cross section for</param>
            <param name="topoID">Topo id to use</param>
            <returns>Global cross section for reach</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.RemoveGlobalCrossSection(System.String,System.String)">
            <summary>
            Find and removes a cross section based on the reachID and topoID. The reach must have
            a global cross section defined, otherwise nothing happens.
            </summary>
            <param name="reachID">ID of reach to get cross section for</param>
            <param name="topoID">Topo id to use</param>
            <returns>True if a cross section was removed, false otherwise</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.GetZExtremes(System.Boolean,System.Double@,System.Double@,System.Double@)">
            <summary>
            returns the global extrema for z coordinates
            </summary>
            <param name="bSelectedOnly">true iff the extrema are to be found within cross
            section with Selected = true only</param>
            <param name="dZmax">the largest z coordinate, or COMMath.DOUBLE_NaN if
            none found</param>
            <param name="dZmin">the smallest z coordinate, or COMMath.DOUBLE_NaN if
            none found</param>
            <param name="dMaxHeight">the largest difference among all cross sections'
            (zmax-zmin), or COMMath.DOUBLE_NaN if none found</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.FindNeighborCrossSections(DHI.Mike1D.Generic.ILocation,System.String,System.Boolean,DHI.Mike1D.CrossSectionModule.ICrossSection@,DHI.Mike1D.CrossSectionModule.ICrossSection@)">
            <summary>
            Find the cross section's neighbors on the same reach and with the same
            topoID. If there is another cross section at that location already, return
            its neighbors. 
            
            TODO: What to return if the branch only has one global cross section? Currently null.
            </summary>
            <param name="location">the location to look for</param>
            <param name="topoID">the topo id to look for</param>
            <param name="nonInterpolatedOnly">set to true iff only cross sections
            with Interpolated = false should be returned as neighbors</param>
            <returns>the found cross section, or null if none found.</returns>
            <param name="xsBefore">the cross sectin before location (smaller chainage), or null if none</param>
            <param name="xsAfter">the cross section after location (larger chainage), or null if none</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.MergeWith(DHI.Mike1D.CrossSectionModule.CrossSectionData)">
            <summary>
            Merge other collection into this. If duplicates, this overrides other (not updated).
            </summary>
            <param name="other">the other collection to merge into this collection.</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.FindCrossSectionsForLocationSpan(DHI.Mike1D.Generic.ILocationSpan,System.String,System.Boolean)">
            <summary>
            Gets the cross-sections on locations inside span. 
            <para>
            If <paramref name="excludeEnds"/> is true, then cross sections must be strictly inside span 
            (cross sections must be <see cref="F:DHI.Mike1D.Generic.Constants.LOCATION_EQUAL_TOLERANCE"/> inside span).
            </para>
            <para>
            If <paramref name="excludeEnds"/> is false, then cross sections on the end of the span will
            be included (within tolerance of <see cref="F:DHI.Mike1D.Generic.Constants.LOCATION_EQUAL_TOLERANCE"/>).
            </para>
            <para>
            Uses StrictContains in the locationSpan to match. If there is a global cross section
            for this reachID, then an array of length 0 is returned.
            </para>
            </summary>
            <param name="locationSpan">Location Span where all crossSections are sought</param>
            <param name="topoID">Topo-ID to use</param>
            <param name="excludeEnds">Flag specifying whether cross sections at the end of the location span should be included or not.</param>
            <returns>A list of CrossSections within LocationSpan</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.GetCrossSection(DHI.Mike1D.Generic.ILocation,System.String)">
            <summary>
            Get a cross section for a location, interpolated if none exists
            at the location. Returns null if a required interpolation is not possible.
            Returns a child if the location is found with in a location span of a cross section
            Processed data are found for the geometric interpolation 
            </summary>
            <param name="location">The location to look for</param>
            <param name="topoId">The topo id to look for</param>
            <returns>the found cross section, or null if none found.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.GetCrossSection(DHI.Mike1D.Generic.ILocation,System.String,System.Boolean)">
            <summary>
            Get a cross section for a route location, interpolated if none exists
            all the location. Returns null if a required interpolation is not possible.
            Processed data can be found in 2 different ways (see below)
            </summary>
            <param name="location">The location to look for</param>
            <param name="topoId">The topo id to look for</param>
            <param name="extrapolate">Flag specifying whether to return nearest cross section (false) or to return an extrapolated cross section (copy with new location) from the nearest cross section</param>
            <returns>The found cross section, or null if none found.</returns>
            <remarks>String comparisons are/ case-insensitive and culture-invariant.</remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.GetVeryLargeCrossSection">
            <summary>
             Get a standard very large cross section.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.GetReachTopoIdEnumerable">
            <summary>
            Return an enumerable that can iterate over all reach-id and topo-id
            combinations
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionData.CrossSectionEnumerator">
            <summary>
            Enumerator class thats enumerates the list of crossSections sorted by branch, topoid and chainage
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.CrossSectionEnumerator.#ctor(DHI.Mike1D.CrossSectionModule.CrossSectionData)">
            <summary>
             Cross section enumerator constructor
            </summary>
            <param name="CrossSections"></param>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionData.CrossSectionEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
            
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.CrossSectionEnumerator.Dispose">
            <summary>
             Dispose method does nothing.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionData.CrossSectionEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Does
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.CrossSectionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            
            <returns>
            True if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionData.CrossSectionEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling">
            <summary>
            A Cross Section middling is a cross sections that is placed 
            between two other cross sections and uses those to calculate 
            its own values using interpolation.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling._beforeRatio">
            <summary>
            Scale between up and down values on the form upratio*up + (1-upratio)*down
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.#ctor(DHI.Mike1D.Generic.ILocation,DHI.Mike1D.CrossSectionModule.ICrossSection,DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
             Create a new CrossSectionMiddling based on a location and two neighbours.
            </summary>
            <param name="location">Location must be in between neighbours</param>
            <param name="xsBefore">Cross section before location</param>
            <param name="xsAfter">Cross section after location</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.UpdateDatum(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />. 
            </returns>
            <param name="obj">An object to compare with this instance. </param>
            <exception cref="T:System.ArgumentException"><paramref name="obj" /> is not the same type as this instance. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Validate">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Ensures that the resistance fomulation is not relative. If the resistance fomulation is 
            Mannings n it is changed to Mannings M and the data are changed accordingly if the resistance 
            formulation is Darcy Weisbach formulation and data are changed to Chezy.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.BaseCrossSection">
            <summary>
             Base cross section. The base cross section has no location and holds
             data in depth, not in water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetArea(System.Double)">
            <summary>
            Return the cross sectional area, also called the flow area, 
            at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetFlowArea(System.Double)">
            <summary>
            Return the cross sectional area, also called the flow area, 
            at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetHydraulicRadius(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            The radius are calculated as one of : todo: check:
            Resistance Radius.
            Effective area, hydraulic radius
            Total area, hydraulic radius.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetHydraulicRadiusDerivative(System.Double)">
            <summary>
            Get the derivate of the hydraulic radius at the given water level.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.ResistanceFormulation">
            <summary>
            The ResistanceFormulation that is used for this crossSection.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetResistanceFactor(System.Double)">
            <summary>
            Resistance factor for the given water level.
            This will always return absolute resitance values.
            </summary>
            <param name="waterLevel"></param>
            <remarks>Conversion from relative to absolute is handled in the prepare step</remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.ResistanceFactorProportionality">
            <summary>
            A proportionality factor that is multiplied with the resistance factor. 
            ResistanceFactorProportionality is used by the resistance factor
            boundaries to adjust the resistance factor.
            Default value: 1.0
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetConveyance(System.Double)">
            <summary>
            Get the conveyance at the specified water level
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Additional storage area is a volume that the mass equation takes
            into account, but it does not influence the momentum equation. It
            could be a small pond next to the river that is filled/emptied as
            the water level in the river raises/falss.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetStorageWidth(System.Double)">
            <summary>
            Returns the width from left bank to right bank at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical discharge for a given water level
            The critical discharge is the discharge where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetNaturalDepth(System.Double,System.Double)">
            <summary>
            Gets the Natural depth for a given discharge [m3/s] and slope [dimensionless]
            The natural depth is the depth where the flow resistance and velocity
            balances, i.e., the Manning formula is fullfilled: Q = M*A*R^(2/3)*sqrt(I)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.DHI_ID">
            <summary>
            An ID that may be used by ArcGIS, for unikely identifying this cross section.
            No cross sections must share the same DHI_ID. A value of -1 means that the value is not set.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.TopoID">
            <summary>
            The TopoID set that this cross section belongs to. TODO: See where for details?
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Info">
            <summary>
            Generel info on this cross section, user specified, can be empty. In
            Mike11 XNS editor called cross section ID (though it does not identify 
            the cross section)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.ZMax">
            <summary>
            The maximum value of Z in the cross section. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.ZMin">
            <summary>
            The minimum value of Z in the cross section (bottom level)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.ZMinFromCenter(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Height">
            <summary>
             Height of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.MaximumWidth">
            <summary>
             Maximum width of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.MinWaterDepth">
            <summary>
             Minimum water depth of the cross section
             This can be negative
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Location">
            <summary>
            Defines the location of the current cross section. The Z-coordinate
            is the bottom level of the cross section (unless defined by the
            raw data (the open cross sections)).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Owner">
            <summary>
            The cross section collection that this cross section belongs to.
            Used for sending events whenever this cross section updates its state.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Interpolated">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.ApplyCoordinates">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Coordinates">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Extrapolate(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Returns an extrapolated CrossSection, i.e., a copy of this cross
            section at the new location.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.IsOpen">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetChild(DHI.Mike1D.Generic.ZLocation)">
            <summary>
            Returns a Clone of the CrossSection, where the parent keeps a reference to the child.
            If a property is changed on the parent it will reflect in the child. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetFlowAreaDerivative(System.Double)">
            <summary>
            Get storagewidth as dA/dh from neighboring values in processed XS areas at waterLevel
            This is how M11 does it - ONLY USED IN M11 SCHEME WHEN COMPARING DIRECTLY WITH M11 RESULTS
            Only implemented in XSOpen for now
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.Initialize">
            <summary>
             Initialize cross section. Calculates processed data if needed.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionMiddling.GetVolumeFromAdditionalSurfaceArea(System.Double)">
            <inheritdoc />
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionPoint">
            <summary>
            A class representing a point on the cross section
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="x">X coordinate</param>
            <param name="z">Z coordinate</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.Clone">
            <summary>
            ICloneable implementation. deep clone, including owner
            </summary>
            <returns>a copy of this cross section point</returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.Owner">
            <summary>
            the list of points of which this point is a part of
            </summary>
            <remarks>used for some validity checks, e.g., requirement that a given
            marker may exist at most once within a point list</remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.X">
            <summary>
            The X coordinate for this cross section point. [meters]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.Z">
            <summary>
            The Z coordinate for this cross section point. [meters]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.Zone">
            <summary>
            The zone type this point lies in.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.DistributedResistance">
            <summary>
            The distributed resistance factor for this point. Value
            only applies when owning cross section's ResistanceDistribution is
            Distributed. The EUM unit and type depend on the cross sections
            ResistanceFormulation. You should use <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointUtilities.GetResistance(DHI.Mike1D.CrossSectionModule.XSBaseRaw,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint,DHI.Mike1D.CrossSectionModule.CrossSectionPointList)"/> 
            to retrieve the resistance factor for the actual ResistanceDistribution.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.Index">
            <summary>
            returns the index of this point within the owning list of points
            If the latter doesn't exist, return -1.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.HasVegetation">
            <summary>
            return true iff this point's Zone is any of the vegetation zones.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.VegetationHeight">
            <summary>
            The height of vegetation (only valid if in a vegetation zone, otherwise
            zero). [meters]. IMPORTANT NOTE: In the MZ XSec editor, vegetation height can
            be non-zero in all zones (even though it doesn't make sense...)!
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.UserMarker">
            <summary>
            Returns the user marker for this point. If none exists, returns 0 (zero).
            </summary>
            <returns>Returns the user marker for this point. If none exists, returns 0 (zero).</returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.MarkerString">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPoint.ToString">
            <summary>
            Overriding ToString method in debug, to ease debugging
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionPointList">
            <summary>
            The points contained in a cross section. The points need not be
            sorted by the x value.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.CrossSectionPointList._xIncreasing">
            <summary>
            Flag determining wether x is increasing and algorithms like binary search
            can be used for finding a point based on x.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.LstPoints">
            <summary>
             List of cross section points.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Prepare">
            <summary>
            Prepare the list. Checks if points are increasing in x, 
            and allows faster searching if they are.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.GetXMax">
            <summary>
            returns the maximum x value [m], or COMMath.DOUBLE_NaN if list is empty.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.GetXMin">
            <summary>
            returns the min x value [m], or COMMath.DOUBLE_NaN if list is empty.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.FindPointIndeces(System.Double)">
            <summary>
            return all 0-BASED indedes of points at a given x, or empty array
            </summary>
            <param name="x">location</param>
            <returns>index array (within list)</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.FindPointIndeces(System.Double,System.Double)">
            <summary>
            return all 0-BASED indexes of points at a given x, or empty array
            </summary>
            <param name="x">location</param>
            <param name="xTolerance">the tolerance (in absolute x units) to search within</param>
            <returns>index array (within list)</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.CalculateLocalBottomLevel(System.Double)">
            <summary>
            Calculates the local bottom level for the coordinate, by interpolation.
            <para>
            In case more than one cross section line segment contains x, the first is
            returned.
            </para>
            </summary>
            <param name="x">Coordinate along cross section. Need not start at zero.</param>
            <returns>Local bottom level</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.FindPointIndex(System.Double,System.Boolean@)">
            <summary>
            finds the 0-BASED index (within the list) of the first point with given x coordinate,
            -1 if not found, and indicate if there are several points at that x.
            </summary>
            <param name="x">x location</param>
            <param name="bNonUnique">true iff more than 1 points are at that x location</param>
            <returns>index in list iff found, otherwise -1</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.FindPointIndex(System.Double,System.Double,System.Boolean@)">
            <summary>
            finds the 0-BASED index (within the list) of the first point with given x coordinate,
            -1 if not found, and indicate if there are several points at that x.
            </summary>
            <param name="x">x location</param>
            <param name="xTolerance">the tolerance (in absolute x units) to search within</param>
            <param name="bNonUnique">true iff more than 1 points are at that x location</param>
            <returns>index in list iff found, otherwise -1</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Clone">
            <summary>
            ICloneable implementation. deep clone, including owner
            </summary>
            <returns>a copy of this cross section point list</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.System#ICloneable#Clone">
            <summary>
            ICloneable implementation. deep clone, including owner
            </summary>
            <returns>a copy of this cross section point list</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.ToArray``1(System.Func{DHI.Mike1D.CrossSectionModule.ICrossSectionPoint,``0})">
            <summary>
            Method to extract a specific property from all cross section points.
            </summary>
            <example>
            To extract all x coordinates, use:
            <code>
            double[] x = xsBaseRaw.Points.ToArray(point => point.X);
            </code>
            </example>
            <param name="selector">Selector that extracts the specific property</param>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Count">
            <summary>
            The number of points defining this cross section.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.IsReadOnly">
            <summary>
            Always false
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Clear">
            <summary>
            clear the list of points
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.CopyTo(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Item(System.Int32)">
            <summary>
            Indexer. For more compact .Net code. Getter calls <seealso cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.GetPointAt(System.Int32)"/>,
            setter calls <seealso cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.ReplacePointAt(System.Int32,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)"/>.
            </summary>
            <param name="index">The 0-based index of the point</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Contains(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            Determines whether the collection contains a specific point.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.IndexOf(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire 
            list. -1 if not found.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Add(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            Appends a point to the collection of points defining this cross section.
            To insert into the collection, use <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Insert(System.Int32,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)"/>. 
            </summary>
            <param name="pPoint">The point to add.</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.AddRange(System.Collections.Generic.IEnumerable{DHI.Mike1D.CrossSectionModule.ICrossSectionPoint})">
            <summary>
            Appends several points to the collection of points defining this cross section.
            </summary>
            <param name="pPoints">The points to add.</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Insert(System.Int32,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
             <summary>
             Inserts a point into the collection of points defining this cross section.
             To append to the collection, use <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Add(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)"/>.
             </summary>
             <param name="pPoint">The point to insert.</param>
            <param name="index">the 0-BASED position to insert in.</param> 
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.InsertRange(System.Int32,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint[])">
             <summary>
             Inserts several points into the collection of points defining this cross section.
             To append to the collection, use <see cref="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Add(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)"/>.
             </summary>
             <param name="pPoints">The points to insert.</param>
            <param name="index">the 0-BASED position to insert in.</param> 
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.RemoveRange(System.Int32,System.Int32)">
             <summary>
             Remove a point from the collection of points defining this cross section.
             Sets Owner of that point to null. Note: indexes are shifted when starting
             points are removed.
             </summary>
            <param name="startIndex">the 0-BASED position of the first point to remove.</param> 
            <param name="count">number of points to remove</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.RemoveAt(System.Int32)">
             <summary>
             Remove a point from the collection of points defining this cross section.
             Sets Owner of that point to null. 
             </summary>
            <param name="index">the 0-BASED position of the point to remove.</param> 
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.Remove(DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
            <summary>
            Removes the first occurrence of a specific point
            </summary>
            <param name="point">Point to remove</param>
            <returns>True if removed, false if not found</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.ReplacePointAt(System.Int32,DHI.Mike1D.CrossSectionModule.ICrossSectionPoint)">
             <summary>
             Replace a point int the collection of points defining this cross section with a new one.
             Sets Owner of the removed point to null.
             </summary>
            <param name="index">the 0-BASED position of the existing point.</param> 
            <param name="newPoint">the point to replace with</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.GetPointAt(System.Int32)">
            <summary>
            return the point for a given 0-BASED index. Can be used in COM. 
            </summary>
            <param name="index">the index</param>
            <returns>a point</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.OnDeserializedMethod(System.Runtime.Serialization.StreamingContext)">
            <summary>
            When deserialized, the NetworkReachDataSet_networkData back-pointer 
            needs to be re-established as it was before serialization.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionPointList.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.FlowResistance">
            <summary>
             Holds information about cross section resistance.
             <para>
             It contains information on the formulation used, <see cref="T:DHI.Mike1D.Generic.ResistanceFormulation"/>,
             and also the resistance values unless they are tabulated. 
             </para><para>
             If resistance values are tabulated, 
             <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.DepthDependence"/> == <see cref="F:DHI.Mike1D.Generic.ResistanceDepthDependence.Tabulated"/>, 
             they should be looked up in the processed data of the cross sections.
             </para><para>
             If the <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.DepthDependence"/> == <see cref="F:DHI.Mike1D.Generic.ResistanceDepthDependence.Exponent"/>
             the following formula is used:
             <code>
             r(d,h) = r_b + (r_t - r_b) * Math.Pow(d / h, c);
             </code>
             with depth derivative
             <code>
             r'(d,h) = (c/h)(r_t - r_b) * Math.Pow(d / h, c-1);
             </code>
             where r_b is <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceValue"/>
             r_t is <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceTopValue"/>
             and c is <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ExpDepExponent"/>
             </para><para>
             During simulation the engine works on Mannings M or Chezy, and converts the
             other resistance formulations to one of those. The converted/modified values and 
             formulations are stored in the <see cref="T:DHI.Mike1D.CrossSectionModule.XSBase"/>.
             </para>
             </summary>
             <remarks>
             Remember to set as well the resistance value as the type. 
             </remarks>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceLeftHighFlow">
            <summary>
            resistance value in the left high flow zone
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceRightHighFlow">
            <summary>
            resistance value in the right high flow zone
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceLowFlow">
            <summary>
            resistance value in the low flow zone
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.FlowResistance._initialResistanceValue">
            <summary>
            Used by pipe design module: The pipe design module changes
            the resitance value of the cross section. In order to reset 
            to the original resistance values, this is required.
            This is not a state variable, but updated as part of the
            pipe design procedure
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.FlowResistance.Formulation">
            <summary>
            Gets and sets the resistance formulation.
            <para>
            This is the formulation stored in the cross section database (xns11 file).
            During calculations, use the <see cref="P:DHI.Mike1D.CrossSectionModule.XSBase.ModifiedFormulation"/>
            which will match the <see cref="M:DHI.Mike1D.CrossSectionModule.XSBase.GetResistanceFactor(System.Int32,System.Double)"/> methods.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceDistribution">
            <summary>
            Distribution of resistance.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.FlowResistance.DepthDependence">
            <summary>
            Gets the resistance depth dependence, which is derived from
            the <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceDistribution"/>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceValue">
            <summary>
            Gets and sets the constant/uniform resistance value. The meaning of its value
            depends on <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.Formulation"/>. 
            <para>
            When the exponential depth dependent formulation is used, this is used
            as the bottom value.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceVegetationValue">
            <summary>
            Gets and sets the resistance value in the vegetation zones. The meaning of its value
            depends on <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.Formulation"/>. Only applicable when vegetation is enabled
            and raw data is available.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ExpDepExponent">
            <summary>
             Exponent value, used when <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.DepthDependence"/> == <see cref="F:DHI.Mike1D.Generic.ResistanceDepthDependence.Exponent"/>.
             A value of 1 (default) means linear variation between bottom and top value, a value less than one
             gives a value below the linear variation, and above one gives a value above the linear variation. 
             Typical values are in the range of [0.1,5].
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ResistanceTopValue">
            <summary>
             Top value, used when <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.DepthDependence"/> == <see cref="F:DHI.Mike1D.Generic.ResistanceDepthDependence.Exponent"/>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.SetExponentValues(System.Double,System.Double,System.Double)">
            <summary>
             Set exponent values, used when <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.DepthDependence"/> == Exponent
             The bottomValue and topValue follows the <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.Formulation"/>.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.IsTabulated">
            <summary>
             True if the resistance depth dependence is tabulated.
            </summary>
            <remarks>
             When true, then the FlowResistance object does not hold
             information on actual resistance values. Those are then
             tabulated in the cross section processed data. 
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.GetNonTabulatedResistanceValue(System.Double,System.Double)">
            <summary>
             Return the resistance value for a non-tabulated depth dependence.
            </summary>
            <param name="depth">Depth in cross section</param>
            <param name="height">Height of cross section</param>
            <returns>Resistance value for the given depth-height</returns>
            <exception cref="T:System.Exception">Throws an exception if the depth dependence is tabulated</exception>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.GetNonTabulatedResistanceDerivative(System.Double,System.Double)">
            <summary>
             Return the resistance derivative value for a non-tabulated depth dependence.
            </summary>
            <param name="depth">Depth in cross section</param>
            <param name="height">Height of cross section</param>
            <returns>Resistance value for the given depth-height</returns>
            <exception cref="T:System.Exception">Throws an exception if the depth dependence is tabulated</exception>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.Validate">
            <summary>
             Validate data consistency
            </summary>
            <exception cref="T:DHI.Mike1D.Generic.Mike1DException"></exception>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.FlowResistance.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.Interp(DHI.Mike1D.CrossSectionModule.FlowResistance,DHI.Mike1D.CrossSectionModule.FlowResistance,System.Double)">
            <summary>
             Interpolate FlowResistance parameters by the given ratio. If either before or 
             after FlowResistance are null, null is returned. It fails if the resistance 
             formulation or the depth dependence differs.
             Interpolation is like:
             v = (1-ratio)*v_us + ratio*v_ds
            </summary>
            <param name="before">Before parameters</param>
            <param name="after">After parameters</param>
            <param name="afterRatio">Downstream ratio</param>
            <returns>An interpolated </returns>
            <exception cref="T:DHI.Mike1D.Generic.Mike1DException"></exception>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.ConvertToStandardResistances(DHI.Mike1D.Generic.ResistanceFormulation,DHI.Mike1D.Generic.ResistanceFormulation@,System.Double[],System.Double[]@,System.Double[])">
            <summary>
            Convert from the current formulation to the new/standard formulation.
            
            To make inplace conversion, give the resistance array
            to both of the currentResistances and newResistances arguments.
            
            Not all type of conversions are supported. Currently only :
             - Mannings n is converted to Mannings M
            </summary>
            <param name="currentFormulation">Formulation to convert from</param>
            <param name="newFormulation">Outputs the new/standard formulation</param>
            <param name="currentResistances">Current resistance values</param>
            <param name="newResistances">New resistance values. If no conversion takes place, newResistances will point to currentResistances. If null, then it will be created automatically</param>
            <param name="hydraulicRadii">Hydraulic radii, to be used for some of the conversions.</param>
            <returns>True if a conversion has taken place. False if no conversion has taken place.</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.ConvertResistances(DHI.Mike1D.Generic.ResistanceFormulation,DHI.Mike1D.Generic.ResistanceFormulation,System.Double[],System.Double[]@,System.Double[])">
            <summary>
             Convert resistances from current formulation to new formalation
             
             To make inplace conversion, give the resistance array
             to both of the currentResistances and newResistances arguments.
             
             Not all type of conversions are supported. Currently only :
              - Mannings n to Mannings M
            </summary>
            <param name="currentFormulation">Current formulation</param>
            <param name="newFormulation">New formulation</param>
            <param name="currentResistances">Array of current resistances.</param>
            <param name="newResistances">Array to store converted resistances. If using the same as for currentResistances, that will be updated</param>
            <param name="hydraulicRadii">Array of hydraulic radii, to be used for some of the conversions only</param>
            <returns>true if conversion was successfull, false otherwise</returns>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.FlowResistance._controlStategyId">
            <summary>
            If the flow resistance is being controlled, then _controlStategyId contains the ID of the
            active control strategy
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.Control(System.DateTime,System.DateTime,System.Double,System.Int32)">
            <summary>
            Setter for controllable entity. Used by the control module.
            Can safely be called multiple times with the same timeN.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.FlowResistance.ResetControlledState">
            <summary>
            Reset controlled state
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.Hydraulics">
            <summary>
            Some simple formulas and lots of legacy code for calculating flow area, 
            storage width, hydraulic radius for cross sections. Uses 1-BASED indexing.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.Hydraulics.AWR23_C">
            <summary>
            area, width, and radius^(2/3) for CIRCULAR Pipe
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.Hydraulics.AWR23_R">
            <summary>
            Rectangular (Quadratic) Pipe
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Hydraulics.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Hydraulics.DarcyWeisbachK2ChezyC(System.Double,System.Double)">
            <summary>
            Converts from the Darcy Weisbach equivalent sand roughness to
            the Chezy roughness number.
            </summary>
            <param name="eqvSandRoughness">Also called equivalent grain diameter, k_s</param>
            <param name="hydraulicRadius">Hydraulic radius</param>
            <returns>Chezy number</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Hydraulics.Manningsn2ManningsM(System.Double)">
            <summary>
            convert a resistance from Manning's n to Manning's M formulation - the reciprocal.
            An input argument of zero causes an exception.
            </summary>
            <param name="resist">original reistance</param>
            <returns>converted resistance</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Hydraulics.ComputeConveyance(DHI.Mike1D.Generic.ResistanceFormulation,System.Double,System.Double,System.Double)">
            <summary>
            return the conveyance [m^3/s].
            </summary>
            <param name="resistType">which theory?</param>
            <param name="resistance">resistance, different EUM item type, dependent on 
            the resistance formulation, but value must always be in the corresponding base unit.</param>
            <param name="area">cross section area [m^2]</param>
            <param name="radius">cross section radius [m]</param>
            <returns>conveyance</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Hydraulics.CalculateOpen(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double[],System.Int32@,System.Double@,System.Double@,System.Double[],System.Double@,System.Int32@,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@,System.Boolean@,System.Double[],System.Double@,System.Int32@,System.Int32@,System.Int32@,System.Boolean@,System.Boolean@)">
            <remarks>was nested procedure, therefore the many arguments</remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Hydraulics.CalculateClosed(System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double[],System.Double[],System.Double@)">
            <summary>
            WJS 6-91 ... procedure for calculating processed data for closed sections
            Note: The relres values are not used, and a hydraulic radius formulation is
            adopted for all cases.
            </summary>
            <remarks>was nested procedure, thus the many arguments</remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.Hydraulics.Calculate(System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[],System.Double[],System.Double[],System.Int32,System.Double,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <param name="h_act">The water level where the parameters are to be calculated</param>
            <param name="top1_pos">Marker 1 index - 1-based</param>
            <param name="top2_pos">Marker 3 index - 1-based</param>
            <param name="left_flood_bank">Marker 4 index - 1-based</param>
            <param name="right_flood_bank">Marker 5 index - 1-based</param>
            <param name="n_unit">number of x-z points in cross section</param>
            <param name="x">X coordinates - (0/1 based?)</param>
            <param name="z">Y coordinates - (0/1 based?)</param>
            <param name="relres">relative resistance ???</param>
            <param name="resistance_type">See enum ResistanceFormulation</param>
            <param name="resistance_scale_number">???TRUE CONSTANT RESISTANCE NUMBER???</param>
            <param name="radius_type">See enum RadiusType</param>
            <param name="closed_section">True if closed cross section (should never be, handled instead by XSPolygon</param>
            <param name="ifst">Marker 1 index + 1 - first index used for integration</param>
            <param name="ilst">Marker 3 index - 1 - last index used for intergration</param>
            <param name="area">Processed area</param>
            <param name="storw">Processed StorageWidth</param>
            <param name="radius">Processed hydraulic radius</param>
            <param name="resnum">Processed resistence number</param>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ICrossSectionFilter">
            <summary>
            simple interface definition for a filter for cross section, used, e.g., in
            partial loading of a cross section collection. A particular implementation will
            have additional members. Note: there is a CrossSectionFilter class that implements
            this interface.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSectionFilter.Passes(DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
            return true iff a particular cross section passes the filter
            </summary>
            <param name="cs">the cross section to test</param>
            <returns>true iff pass</returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge">
            <summary>
            interface definition for a bridge for loading and, optionally, saving a 
            cross section collection.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.CrossSectionData">
            <summary>
            set the object to be filled in and/or saved
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.FileExtension">
            <summary>
            return the standard file extension, including the dot ".", or empty 
            string if not applicable
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.CanSave">
            <summary>
            return true iff this bridge can save data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.FilterForOpen">
            <summary>
            can set a filter for partial loading.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.Specification">
            <summary>
            any additional information used by a particular bridge
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.Open">
            <summary>
            Load data, repsectiving any <see cref="P:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.FilterForOpen"/> if set.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.Save">
            <summary>
            (try to) save all cross sections, return number saved
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.SaveSelected">
            <summary>
            (try to) save all cross sections that have Selected = true, return number saved
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ICrossSectionBridge.Validate(System.String@)">
            <summary>
            Check the data source, return true iff ok.
            </summary>
            <param name="sErrMsg">string with any error message, otherwise empty string</param>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint">
            <summary>
             Point on a cross section.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.Owner">
            <summary>
            the list of points of which this point is a part
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.Index">
            <summary>
            returns the index of this point within the (sorted by x) list of points
            of the owning cross section. If the latter doesn't exist, return -1.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.X">
            <summary>
            The X coordinate for this cross section point. [meters]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.Z">
            <summary>
            The Z coordinate for this cross section point. [meters]
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.Zone">
            <summary>
            The zone type this point lies in.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.DistributedResistance">
            <summary>
            The distributed resistance factor for this point. Value
            only applies of owning cross section's ResistanceDistribution is
            Distributed. The EUM unit and type depend on the cross sections
            ResistanceFormulation. You should use CrossSectionPoint.GetResistance to retrieve the 
            resistance factor for the actual ResistanceDistribution; the getter is "at your
            risk".
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.HasVegetation">
            <summary>
            return true iff this point's Zone is any of the vegetation zones.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.VegetationHeight">
            <summary>
            The height of vegetation (only valid if in a vegetation zone, otherwise
            zero). [meters]. IMPORTANT NOTE: In the MZ XSec editor, vegetation height can
            be non-zero in all zones (even though it doesn't make sense...)!
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.UserMarker">
            <summary>
            Returns the user marker for this point. If none exists, returns 0 (zero).
            </summary>
            <returns>Returns the user marker for this point. If none exists, returns 0 (zero).</returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ICrossSectionPoint.MarkerString">
            <summary>
            String representation of markers on this cross section point. Used by GUI.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs">
            <summary>
            level-related specifications for pre-processing of cross section data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.#ctor(DHI.Mike1D.CrossSectionModule.XSBase)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.Clone">
            <summary>
            ICloneable. Make a copy of this.
            </summary>
            <returns>a clone of this</returns>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.Option">
            <summary>
            how to do pre-processing
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.MinLevel">
            <summary>
            if <see cref="T:DHI.Mike1D.Generic.ProcessingOption"/> is Equidistant or UserDefined, the lower end of range, 
            or NotANumber if not applicable or set
            <para>
            MinLevel is relative to raw data, and must not include any datum offset
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.MaxLevel">
            <summary>
            if <see cref="T:DHI.Mike1D.Generic.ProcessingOption"/> is Equidistant or UserDefined, the upper end of range, 
            or NotANumber if not applicable or set
            <para>
            MaxLevel is relative to raw data, and must not include any datum offset
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.ProcessedLevelsStartAtZero">
            <summary>
             True if the processed levels should be forced to start at zero (MU approach)
             even if the raw data does not do so.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.TopExtension">
            <summary>
             Type of top extension of processed data.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.UserDefLevels">
            <summary>
            the levels for user-defined processing (absolute elevations in [m]!), or
            null if none. Must be strictly monotonically increasing.
            Apart from these, the relative min and max levels, plus the datum, from
            the raw data will also be part of the processed levels. NOTE: if you set
            an individual value within the array, you must re-process the hydraulic data.
            <para>
            Levels are relative to raw data, and must not include any datum offset
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.NoOfLevels">
            <summary>
            careful: there can be a value for the number of levels to use, which, if 
            <see cref="T:DHI.Mike1D.Generic.ProcessingOption"/> is UserDefined, will be equal to the Length of
            <see cref="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.UserDefLevels"/> - but this number can also be set independently.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.ProcessingLevelsSpecs.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter">
            <summary>
            basic filter for cross sections, e.g., for partial loading or display.
            allows filtering by branch name(s), TopoId(s), and area.
            TODO: If use, reimplement using dictionary instead of arrays, for performance.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.Branches">
            <summary>
            the branches to filter, case insensitive. Returns empty array if none. 
            Set to empty array or to null to deactivate.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.TopoIDs">
            <summary>
            the TopoIDs to filter, case insensitive. Returns empty array if none. 
            Set to empty array or to null to deactivate.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.SetArea(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            the geographic area to filter. Requires that a cross section has end point
            coordinates defined, otherwise it won't pass. Set all coordinates to
            COMMath.DOUBLE_NaN to deactivate.
            </summary>
            <param name="xmin">leftmost x coordinate, or COMMath.DOUBLE_NaN
            if not applicable</param>
            <param name="ymin">lowermost y coordinate or COMMath.DOUBLE_NaN</param>
            <param name="xmax">rightmost x coordinate or COMMath.DOUBLE_NaN</param>
            <param name="ymax">uppermost y coordinate or COMMath.DOUBLE_NaN</param>
            <param name="bIncludePartiallyWithinArea">iff true, let cross sections that
            are only partially within the given area pass as well</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.GetArea(System.Double@,System.Double@,System.Double@,System.Double@,System.Boolean@)">
            <summary>
            the geographic area to filter. Requires that a cross section has end point
            coordinates defined, otherwise it won't pass. Not active if all coordinates
            are COMMath.DOUBLE_NaN.
            </summary>
            <param name="xmin">leftmost x coordinate, or COMMath.DOUBLE_NaN
            if not applicable</param>
            <param name="ymin">lowermost y coordinate or COMMath.DOUBLE_NaN</param>
            <param name="xmax">rightmost x coordinate or COMMath.DOUBLE_NaN</param>
            <param name="ymax">uppermost y coordinate or COMMath.DOUBLE_NaN</param>
            <param name="bIncludePartiallyWithinArea">iff true, lets cross sections that
            are only partially within the given area pass as well</param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.PassesBranchFilter(System.String)">
            <summary>
            internal so it can be also used by standard bridges without an instantiated
            ICrossSection object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.PassesTopoIDFilter(System.String)">
            <summary>
            internal so it can be also used by standard bridges without an instantiated
            CrossSection object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.PassesSpatial(DHI.Mike1D.Generic.Spatial.Geometry.ICoordinateSequence)">
            <summary>
            internal so it can be also used by standard bridges without an instantiated
            CrossSection object
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.Passes(DHI.Mike1D.CrossSectionModule.ICrossSection)">
            <summary>
            returns true if the argument passes the filter
            </summary>
            <param name="cs">argument</param>
            <returns>true iff pass</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.OnDeserializedMethod(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initialize derived fields after object is deserialized.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.StandardCrossSectionFilter.ExtensionData">
            <summary>
            Holds data from an extended DataContract
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge">
            <summary>
            data bridge to/from an xns11 file
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.#ctor(DHI.Mike1D.CrossSectionModule.CrossSectionData)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.CrossSectionData">
            <summary>
            lets you set the object to be filled in
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.CanSave">
            <summary>
            returns true, as this bridge can save data
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.FileExtension">
            <summary>
            returns ".xns11"
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.Specification">
            <summary>
            not used by this bridge
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.FilterForOpen">
            <summary>
            a filter for partial loading. Detects if set value is a StandardCrossSectionFilter,
            in which case performance will be faster.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.Validate(System.String@)">
            <summary>
            Cannot really check on the file itself, so will always return true
            </summary>
            <param name="sErrMsg">empty string returned</param>
            <returns>true always</returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.Open(DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Load data.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.Save">
            <summary>
            save all cross sections
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionXnsBridge.Clone(DHI.Mike1D.CrossSectionModule.CrossSectionData)">
            <summary>
            Clone all cross sections in CrossSectionData.
            </summary>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.CrossSectionLocated">
            <summary>
             <para>
             A cross section with a location (ZLocation). Has a pointer to an <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.BaseCrossSection"/>. The
             <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.BaseCrossSection"/> can be reused by many <see cref="T:DHI.Mike1D.CrossSectionModule.CrossSectionLocated"/>.
             </para>
             <para>
             Contains <see cref="T:DHI.Mike1D.Generic.ZLocation"/>, <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Coordinates"/>, <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Info"/>, 
             <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.MinWaterDepth"/>, <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.DHI_ID"/>. Rest is extracted from the <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.BaseCrossSection"/>.
             </para>
             <para>
             Buffering of previous water level is handled here. 
             </para>
             <para>
             Also does translation from water level to depth (<see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.BaseCrossSection"/> can be depth based.). 
             The levels in the BaseCrossSection uses Location.Z as zero level.
             </para>
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Validate">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Prepare(DHI.Mike1D.HDParameterDataAccess.HDParameterData,DHI.Mike1D.Generic.IDiagnostics)">
            <summary>
            Ensures that the resistance formulation is not relative. If the resistance formulation is
            Mannings n it is changed to Mannings M and the data are changed accordingly if the resistance
            formulation is Darcy Weisbach formulation and data are changed to Chezy.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.UpdateDatum(System.Double)">
            <summary>
            Update datum for cross section
            </summary>
            <param name="newDatum"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetArea(System.Double)">
            <summary>
            Return the cross sectional geometric area
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetFlowArea(System.Double)">
            <summary>
            Return the cross sectional flow area, which may differ from
            the geometrical area due to water not being part of the flow
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetHydraulicRadius(System.Double)">
            <summary>
            Returns the hydraulic radius for the given water level. 
            The radius is calculated as one of: 
            Resistance radius, effective area hydraulic radius, or total area hydraulic radius
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetHydraulicRadiusDerivative(System.Double)">
            <summary>
            Get the derivate of the hydraulic radius at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetResistanceFactor(System.Double)">
            <summary>
            Resistance factor for the given water level.
            This will always return absolute resitance values.
            </summary>
            <param name="waterLevel"></param>
            <remarks>Conversion from relative to absolute is handled in the prepare step</remarks>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.ResistanceFactorProportionality">
            <summary>
            A proportionality factor that is always multiplied to the tabulated or constant
            resistance factor. The ProportionalityFactor is used by the resistance factor
            boundaries to adjust the resistance factor during the simulation. This is not
            a state variable. Default value: 1.0
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetResistanceFactorDerivative(System.Double)">
            <summary>
            Get the derivative of the resistance factor at the given water level
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetConveyance(System.Double)">
            <summary>
            Get the conveyance at the specified water level
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetStorageWidth(System.Double)">
            <summary>
            Returns the width from left bank to right bank at the given water level.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetAdditionalSurfaceArea(System.Double)">
            <summary>
            Additional storage area is a surface area that the mass equation takes
            into account, but it does not influence the momentum equation. It
            could be a small pond next to the river that is filled/emptied as
            the water level in the river raises/falss.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetCriticalDepth(System.Double)">
            <summary>
            Gets the Critical depth for a given discharge - [m3/s]
            The critical depth is the depth where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetCriticalDischarge(System.Double)">
            <summary>
            Gets the Critical discharge for a given water level
            The critical discharge is the discharge where the flow changes 
            from supercritical to subcritical flow.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetNaturalDepth(System.Double,System.Double)">
            <summary>
            Gets the Natural depth for a given discharge [m3/s] and slope [dimensionless]
            The natural depth is the depth where the flow resistance and velocity
            balances, i.e., the Manning formula is fullfilled: Q = M*A*R^(2/3)*sqrt(I)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.ApplyCoordinates">
            <summary>
            Flag specifying whether the <see cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Coordinates"/> is to be applied or ´not
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Coordinates">
            <summary>
            Gets or sets the cross section coordinates, i.e., the geographical coordinates
            of line that the cross section follows.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.ResistanceFormulation">
            <summary>
            The ResistanceFormulation that is used for this crossSection and stored in the processed data.
            <para>
            This may differ from the ones specified in the <see cref="P:DHI.Mike1D.CrossSectionModule.FlowResistance.Formulation"/>, which
            is the formulation for the raw data.
            </para>
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.TopoID">
            <summary>
            The TopoID set that this cross section belongs to. TODO: See where for details?
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Info">
            <summary>
            Generel info on this cross section, user specified. Can be empty. In
            Mike11 XNS editor called cross section ID (though it does not identify 
            the cross section)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.ZMax">
            <summary>
            The maximum value of Z in the cross section. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.ZMin">
            <summary>
            The minimum value of Z in the cross section (bottom level)
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.ZMinFromCenter(System.Double)">
            <summary>
            The minimum value of Z in the cross section (bottom level)
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Height">
            <summary>
             Height of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.MaximumWidth">
            <summary>
             Height of the cross section
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.MinWaterDepth">
            <summary>
             Minimum water depth of the cross section
             This can be negative
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Location">
            <summary>
            Defines the location of the current cross section. The Z-coordinate
            is the bottom level of the cross section (unless defined by the
            raw data (the open cross sections)).
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.BaseCrossSection">
            <summary>
             Get cross section which this location points to
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Interpolated">
            <summary>
            Returns true if the CrossSection is interpolated from other cross sections
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Extrapolate(DHI.Mike1D.Generic.ILocation)">
            <summary>
            Returns an extrapolated CrossSection, i.e., a copy of this cross
            section at the new location.
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.IsOpen">
            <summary>
             Return true if the cross section is open
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetChild(DHI.Mike1D.Generic.ZLocation)">
            <summary>
            Returns a Clone of the CrossSection, where the parent keeps a reference to the child.
            If a property is changed on the parent it will reflect in the child. 
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetFlowAreaDerivative(System.Double)">
            <summary>
            Get storagewidth as dA/dh from neighboring values in processed XS areas at waterLevel
            This is how M11 does it - ONLY USED IN M11 SCHEME WHEN COMPARING DIRECTLY WITH M11 RESULTS
            Only implemented in XSOpen for now
            </summary>
            <param name="waterLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Initialize">
            <summary>
             Initialize cross section. Calculates processed data if needed.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetVolumeFromAdditionalSurfaceArea(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.DHI_ID">
            <summary>
            a unique ID allowing tracing of ICrossSection objects' histories in code flow.
            Persistent in xns11 files only through a hack, by prepending it to the Info
            (name) field. The xns11 bridge will filter this out, but not other xns11 readers.
            </summary>
            <remarks>
            Location is also unique, but cannot be used for identification, as there
            may be a need to edit it for logical reason. This ID is used in M11 GIS.
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.CompareTo(System.Object)">
            <summary>
            IComparable implementation. Calls IComparable on the <seealso cref="P:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Location"/> members,
            if that returns 0, if that returns 0 calls CompareTo on the Topo_ID, calls CompareTo on the DHI_ID members,.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance. Does not clone base cross section. 
            To also cloe base cross section, use DeepClone()
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.DeepClone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance. Also clones base cross section. 
            To keep the same base cross section, use Clone()
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetFrictionValues(System.Double,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Values required to calculate friction factor for higher order friction term
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.GetGeoReferencedCoords(System.Double[]@,System.Double[]@)">
            <summary>
            If cross section coordinates are valid, returns the geographic (in the landscape's 
            plane) coordinates of all points, otherwise null. Raw data must be present.
            </summary>
            <param name="geoX">the Cartesian X coordinates of all points (NOT the 
            longitudinal coordinates)</param>
            <param name="geoY">the Cartesian Y coordinates of all points</param>
            <returns>true if ok</returns>
            <remarks>The Euclidean distance between the coordinate points may not
            match the cross sectional coordinate. 
            </remarks>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.CompareBy(DHI.Mike1D.Generic.ILocation,System.String)">
            <summary>
            Predicate to find ICrossSection by Location and topo_id.
            </summary>
            <param name="Location"></param>
            <param name="Topo_ID"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.CompareBy(System.String,System.String)">
            <summary>
            Predicate to find ICrossSection by ID/BranchName and Topo_ID
            </summary>
            <param name="ID"></param>
            <param name="Topo_ID"></param>
            <returns></returns>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.CrossSectionLocated.CompareBy(DHI.Mike1D.Generic.ILocationSpan,System.String)">
            <summary>
            Predicate to find ICrossSection by LocationSpan and Topo_ID. Uses StrictlyContains
            </summary>
            <param name="LocationSpan"></param>
            <param name="Topo_ID"></param>
            <returns></returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSPolygon">
            <summary>
             Closed polygon cross section. Polygon cross sections are defined by a list of points.
             Remember to call CalculateProcessedData() before use.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSPolygon.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSPolygon.#ctor(DHI.Mike1D.CrossSectionModule.XSBaseRaw)">
            <summary>
             Construct a polygon cross section from XSBaseRaw
            </summary>
            <param name="xsBaseRaw"></param>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSPolygon.Clone">
            <summary>
            ICloneable implementation. deep clone, including owner
            </summary>
            <returns>a copy of this cross section</returns>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter">
            <summary>
            Class that puts a processed top slot on an XSPolygon, by adding
            50 (default) extra layers on top of the existing processed data.
            The extra layers follows an exponentially decreasing width profile.
            The area of the cross section in the slot is kept constant (i.e. when
            water level is increasing, water dissapears, and when water decreases
            again, the water reappears)
            
            It stores the original processed data and is capable of reverting
            when the calculation has finished.
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter.NumberOfSlotLevels">
            <summary>
            Number of levels to add above existing processed data.
            Default: 50
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter.HeightFraction">
            <summary>
            Height of the added top slot, as a fraction of the original cross section height.
            Default: 1.0
            </summary>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter.TopWidthFraction">
            <summary>
            The fraction of the MaxWidth that is to be used as 
            top width (width at infinity level) in the slot. Default 0.01.
            </summary>
            <remarks>
            The epspar in the MU Delphi code
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter.InterfaceHeightFraction">
            <summary>
            The fraction of the MaxWidth that is to be used as 
            height of the top slot interface (top part of original cross section
            that is modified to match the slot). Default 0.05.
            </summary>
            <remarks>
            Matching the fpar*epspar in the MU Delphi code
            </remarks>
        </member>
        <member name="F:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter.SlotConveyanceFactor">
            <summary>
            A factor correcting the hydraulic radius such that
            the conveyance at the top of the slot is this factor
            larger than the conveyance at the top of the original cross section.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter.Revert">
            <summary>
            Revert the processed data in the XSPolygon to the original data
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter.Process">
            <summary>
            Process the XSPolygon
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSPolygonProcessedTopSlotter.CalculateExpDecreasingWidth(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate width based on a decreasing exponential formulation
            </summary>
            <param name="slope">Angle from level axis to width curve at start-level (called tanv0 in MU)</param>
            <param name="topWidth">Width at infinity level of slot</param>
            <param name="startWidth">Width at slot start level</param>
            <param name="slotStartLevel">Level where slot starts</param>
            <param name="level">Level to calculate width for. Must be larger than slot start level</param>
            <returns>Width at given level</returns>
            <remarks>
            Compared to the MU implementation of this function, to get the same result, call this with
            CalculateExpDecreasingWidth(2*slope, ...)
            </remarks>
        </member>
        <member name="T:DHI.Mike1D.CrossSectionModule.XSProcessedInterp">
            <summary>
             A class representing a cross section that is
             interpolated from the processed data of two 
             other cross sections.
             
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSProcessedInterp.#ctor">
            <summary>
             Default constructor. 
            </summary>
        </member>
        <member name="P:DHI.Mike1D.CrossSectionModule.XSProcessedInterp.OpenCloseType">
            <summary>
             Type of cross section: Open, ClosedCircular, ClosedRectangular, or ClosedIrregular.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSProcessedInterp.Validate">
            <summary>
            Validates that this cross sections is set up correctly.
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSProcessedInterp.BottomLevelFromCenter(System.Double)">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:DHI.Mike1D.CrossSectionModule.XSProcessedInterp.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
    </members>
</doc>
